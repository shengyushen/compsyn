!_TAG_FILE_FORMAT	1	/without ;"/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted/
ADD	parser.ml	/^  | ADD of (Lexing.position*Lexing.position)$/;
AND3	parser.ml	/^  | AND3 of (Lexing.position*Lexing.position)$/;
AT	parser.ml	/^  | AT of (Lexing.position*Lexing.position)$/;
BASE_NUMBER	parser.ml	/^  | BASE_NUMBER of (string)$/;
BIT_AND	parser.ml	/^  | BIT_AND of (Lexing.position*Lexing.position)$/;
BIT_EQU	parser.ml	/^  | BIT_EQU of (Lexing.position*Lexing.position)$/;
BIT_NEG	parser.ml	/^  | BIT_NEG of (Lexing.position*Lexing.position)$/;
BIT_OR	parser.ml	/^  | BIT_OR of (Lexing.position*Lexing.position)$/;
BIT_XOR	parser.ml	/^  | BIT_XOR of (Lexing.position*Lexing.position)$/;
CAPITAL_E	parser.ml	/^  | CAPITAL_E$/;
CASE_EQU	parser.ml	/^  | CASE_EQU of (Lexing.position*Lexing.position)$/;
CASE_INE	parser.ml	/^  | CASE_INE of (Lexing.position*Lexing.position)$/;
COLON	parser.ml	/^  | COLON of (Lexing.position*Lexing.position)$/;
COMMA	parser.ml	/^  | COMMA of (Lexing.position*Lexing.position)$/;
Circuit_obj	circuit_obj.ml	1;
DIV	parser.ml	/^  | DIV of (Lexing.position*Lexing.position)$/;
DOLLOR	parser.ml	/^  | DOLLOR of (Lexing.position*Lexing.position)$/;
DOLLOR_HOLD	parser.ml	/^  | DOLLOR_HOLD$/;
DOLLOR_PERIOD	parser.ml	/^  | DOLLOR_PERIOD$/;
DOLLOR_RECOVERY	parser.ml	/^  | DOLLOR_RECOVERY$/;
DOLLOR_SETUP	parser.ml	/^  | DOLLOR_SETUP$/;
DOLLOR_SETUPHOLD	parser.ml	/^  | DOLLOR_SETUPHOLD$/;
DOLLOR_SKEW	parser.ml	/^  | DOLLOR_SKEW$/;
DOLLOR_SYSTEM_IDENTIFIER	parser.ml	/^  | DOLLOR_SYSTEM_IDENTIFIER of (string)$/;
DOLLOR_WIDTH	parser.ml	/^  | DOLLOR_WIDTH$/;
DOT	parser.ml	/^  | DOT of (Lexing.position*Lexing.position)$/;
Dependent	dependent.ml	1;
EOF	parser.ml	/^  | EOF of (Lexing.position*Lexing.position)$/;
EOL	parser.ml	/^  | EOL of (Lexing.position*Lexing.position)$/;
Edge	rtl.ml	/^type eventype=Noedge | Edge$/;
Elabmod	elabmod.ml	1;
Expression	expression.ml	1;
FLOAT_NUMBER	parser.ml	/^  | FLOAT_NUMBER of (string)$/;
GATETYPE	parser.ml	/^  | GATETYPE of (string)$/;
GE	parser.ml	/^  | GE of (Lexing.position*Lexing.position)$/;
GT	parser.ml	/^  | GT of (Lexing.position*Lexing.position)$/;
IDENTIFIER	parser.ml	/^  | IDENTIFIER of (string)$/;
JING	parser.ml	/^  | JING of (Lexing.position*Lexing.position)$/;
KEY_ALWAYS	parser.ml	/^  | KEY_ALWAYS of (Lexing.position*Lexing.position)$/;
KEY_ASSIGN	parser.ml	/^  | KEY_ASSIGN of (Lexing.position*Lexing.position)$/;
KEY_BEGIN	parser.ml	/^  | KEY_BEGIN of (Lexing.position*Lexing.position)$/;
KEY_CASE	parser.ml	/^  | KEY_CASE of (Lexing.position*Lexing.position)$/;
KEY_CASEX	parser.ml	/^  | KEY_CASEX of (Lexing.position*Lexing.position)$/;
KEY_CASEZ	parser.ml	/^  | KEY_CASEZ of (Lexing.position*Lexing.position)$/;
KEY_DEFAULT	parser.ml	/^  | KEY_DEFAULT of (Lexing.position*Lexing.position)$/;
KEY_DEFPARAM	parser.ml	/^  | KEY_DEFPARAM of (Lexing.position*Lexing.position)$/;
KEY_DISABLE	parser.ml	/^  | KEY_DISABLE of (Lexing.position*Lexing.position)$/;
KEY_EDGE	parser.ml	/^  | KEY_EDGE of (Lexing.position*Lexing.position)$/;
KEY_ELSE	parser.ml	/^  | KEY_ELSE of (Lexing.position*Lexing.position)$/;
KEY_END	parser.ml	/^  | KEY_END of (Lexing.position*Lexing.position)$/;
KEY_ENDCASE	parser.ml	/^  | KEY_ENDCASE of (Lexing.position*Lexing.position)$/;
KEY_ENDFUNCTION	parser.ml	/^  | KEY_ENDFUNCTION of (Lexing.position*Lexing.position)$/;
KEY_ENDMODULE	parser.ml	/^  | KEY_ENDMODULE of (Lexing.position*Lexing.position)$/;
KEY_ENDSPECIFY	parser.ml	/^  | KEY_ENDSPECIFY of (Lexing.position*Lexing.position)$/;
KEY_ENDTASK	parser.ml	/^  | KEY_ENDTASK of (Lexing.position*Lexing.position)$/;
KEY_EVENT	parser.ml	/^  | KEY_EVENT of (Lexing.position*Lexing.position)$/;
KEY_FOR	parser.ml	/^  | KEY_FOR of (Lexing.position*Lexing.position)$/;
KEY_FORCE	parser.ml	/^  | KEY_FORCE of (Lexing.position*Lexing.position)$/;
KEY_FOREVER	parser.ml	/^  | KEY_FOREVER of (Lexing.position*Lexing.position)$/;
KEY_FORK	parser.ml	/^  | KEY_FORK of (Lexing.position*Lexing.position)$/;
KEY_FUNCTION	parser.ml	/^  | KEY_FUNCTION of (Lexing.position*Lexing.position)$/;
KEY_IF	parser.ml	/^  | KEY_IF of (Lexing.position*Lexing.position)$/;
KEY_INITIAL	parser.ml	/^  | KEY_INITIAL of (Lexing.position*Lexing.position)$/;
KEY_INOUT	parser.ml	/^  | KEY_INOUT of (Lexing.position*Lexing.position)$/;
KEY_INPUT	parser.ml	/^  | KEY_INPUT of (Lexing.position*Lexing.position)$/;
KEY_INTEGER	parser.ml	/^  | KEY_INTEGER of (Lexing.position*Lexing.position)$/;
KEY_JOIN	parser.ml	/^  | KEY_JOIN of (Lexing.position*Lexing.position)$/;
KEY_LARGE	parser.ml	/^  | KEY_LARGE of (Lexing.position*Lexing.position)$/;
KEY_MEDIUM	parser.ml	/^  | KEY_MEDIUM of (Lexing.position*Lexing.position)$/;
KEY_MODULE	parser.ml	/^  | KEY_MODULE of (Lexing.position*Lexing.position)$/;
KEY_NEGEDGE	parser.ml	/^  | KEY_NEGEDGE of (Lexing.position*Lexing.position)$/;
KEY_OR	parser.ml	/^  | KEY_OR of (Lexing.position*Lexing.position)$/;
KEY_OUTPUT	parser.ml	/^  | KEY_OUTPUT of (Lexing.position*Lexing.position)$/;
KEY_PARAMETER	parser.ml	/^  | KEY_PARAMETER of (Lexing.position*Lexing.position)$/;
KEY_POSEDGE	parser.ml	/^  | KEY_POSEDGE of (Lexing.position*Lexing.position)$/;
KEY_REAL	parser.ml	/^  | KEY_REAL of (Lexing.position*Lexing.position)$/;
KEY_REG	parser.ml	/^  | KEY_REG of (Lexing.position*Lexing.position)$/;
KEY_RELEASE	parser.ml	/^  | KEY_RELEASE of (Lexing.position*Lexing.position)$/;
KEY_REPEAT	parser.ml	/^  | KEY_REPEAT of (Lexing.position*Lexing.position)$/;
KEY_SCALARED	parser.ml	/^  | KEY_SCALARED of (Lexing.position*Lexing.position)$/;
KEY_SMALL	parser.ml	/^  | KEY_SMALL of (Lexing.position*Lexing.position)$/;
KEY_SPECIFY	parser.ml	/^  | KEY_SPECIFY of (Lexing.position*Lexing.position)$/;
KEY_SPECPARAM	parser.ml	/^  | KEY_SPECPARAM of (Lexing.position*Lexing.position)$/;
KEY_TASK	parser.ml	/^  | KEY_TASK of (Lexing.position*Lexing.position)$/;
KEY_TIME	parser.ml	/^  | KEY_TIME of (Lexing.position*Lexing.position)$/;
KEY_VECTORED	parser.ml	/^  | KEY_VECTORED of (Lexing.position*Lexing.position)$/;
KEY_WAIT	parser.ml	/^  | KEY_WAIT of (Lexing.position*Lexing.position)$/;
KEY_WHILE	parser.ml	/^  | KEY_WHILE of (Lexing.position*Lexing.position)$/;
LBRACE	parser.ml	/^  | LBRACE of (Lexing.position*Lexing.position)$/;
LBRACKET	parser.ml	/^  | LBRACKET of (Lexing.position*Lexing.position)$/;
LE	parser.ml	/^  | LE of (Lexing.position*Lexing.position)$/;
LEADTO	parser.ml	/^  | LEADTO of (Lexing.position*Lexing.position)$/;
LEFT_SHIFT	parser.ml	/^  | LEFT_SHIFT of (Lexing.position*Lexing.position)$/;
LITTLE_E	parser.ml	/^  | LITTLE_E$/;
LOGIC_AND	parser.ml	/^  | LOGIC_AND of (Lexing.position*Lexing.position)$/;
LOGIC_EQU	parser.ml	/^  | LOGIC_EQU of (Lexing.position*Lexing.position)$/;
LOGIC_INE	parser.ml	/^  | LOGIC_INE of (Lexing.position*Lexing.position)$/;
LOGIC_NEG	parser.ml	/^  | LOGIC_NEG of (Lexing.position*Lexing.position)$/;
LOGIC_OR	parser.ml	/^  | LOGIC_OR of (Lexing.position*Lexing.position)$/;
LPAREN	parser.ml	/^  | LPAREN of (Lexing.position*Lexing.position)$/;
LT	parser.ml	/^  | LT of (Lexing.position*Lexing.position)$/;
MOD	parser.ml	/^  | MOD of (Lexing.position*Lexing.position)$/;
MUL	parser.ml	/^  | MUL of (Lexing.position*Lexing.position)$/;
Main	main.ml	1;
Misc	misc.ml	1;
Misc2	misc2.ml	1;
NETTYPE	parser.ml	/^  | NETTYPE of (string)$/;
No_such_clock	rtl.ml	/^exception No_such_clock$/;
Noedge	rtl.ml	/^type eventype=Noedge | Edge$/;
PATHTO	parser.ml	/^  | PATHTO of (Lexing.position*Lexing.position)$/;
PATHTOSTAR	parser.ml	/^  | PATHTOSTAR of (Lexing.position*Lexing.position)$/;
Parser	parser.ml	1;
Print_v	print_v.ml	1;
QUESTION_MARK	parser.ml	/^  | QUESTION_MARK of (Lexing.position*Lexing.position)$/;
QUESTION_MARK_COLON	parser.ml	/^  | QUESTION_MARK_COLON of (Lexing.position*Lexing.position)$/;
RBRACE	parser.ml	/^  | RBRACE of (Lexing.position*Lexing.position)$/;
RBRACKET	parser.ml	/^  | RBRACKET of (Lexing.position*Lexing.position)$/;
RED_NAND	parser.ml	/^  | RED_NAND of (Lexing.position*Lexing.position)$/;
RED_NOR	parser.ml	/^  | RED_NOR of (Lexing.position*Lexing.position)$/;
RIGHT_SHIFT	parser.ml	/^  | RIGHT_SHIFT of (Lexing.position*Lexing.position)$/;
RPAREN	parser.ml	/^  | RPAREN of (Lexing.position*Lexing.position)$/;
Rtl	rtl.ml	1;
SATISFIABLE	elabmod.ml	/^type result = SATISFIABLE | UNSATISFIABLE$/;
SEMICOLON	parser.ml	/^  | SEMICOLON of (Lexing.position*Lexing.position)$/;
SINGLEASSIGN	parser.ml	/^  | SINGLEASSIGN of (Lexing.position*Lexing.position)$/;
STRENGTH0	parser.ml	/^  | STRENGTH0 of (string)$/;
STRENGTH1	parser.ml	/^  | STRENGTH1 of (string)$/;
STRING	parser.ml	/^  | STRING of (string)$/;
SUB	parser.ml	/^  | SUB of (Lexing.position*Lexing.position)$/;
Statement	statement.ml	1;
T_add1	typedef.ml	/^	| T_add1 of primary$/;
T_add2	typedef.ml	/^	| T_add2 of expression*expression$/;
T_always_statement	typedef.ml	/^		| T_always_statement   of statement$/;
T_arrayassign	typedef.ml	/^	  T_arrayassign of int*int*expression	(*only for defining array assignment*)$/;
T_assignment	typedef.ml	/^	T_assignment of lvalue*expression$/;
T_bit_and2	typedef.ml	/^	| T_bit_and2 of expression*expression$/;
T_bit_equ	typedef.ml	/^	| T_bit_equ of expression*expression$/;
T_bit_or2	typedef.ml	/^	| T_bit_or2 of expression*expression$/;
T_bit_xor2	typedef.ml	/^	| T_bit_xor2 of expression*expression$/;
T_bitneg	typedef.ml	/^	| T_bitneg of primary$/;
T_blocking_assignment	typedef.ml	/^		T_blocking_assignment of blocking_assignment$/;
T_blocking_assignment_delay	typedef.ml	/^	| T_blocking_assignment_delay of lvalue*expression*delay_control$/;
T_blocking_assignment_direct	typedef.ml	/^	  T_blocking_assignment_direct of lvalue*expression$/;
T_blocking_assignment_event	typedef.ml	/^	| T_blocking_assignment_event of lvalue*expression*event_control$/;
T_case_equ	typedef.ml	/^	| T_case_equ of expression*expression$/;
T_case_ine	typedef.ml	/^	| T_case_ine of expression*expression$/;
T_case_item_default	typedef.ml	/^	| T_case_item_default of statement$/;
T_case_item_normal	typedef.ml	/^	T_case_item_normal of (expression list)*statement$/;
T_case_statement	typedef.ml	/^		| T_case_statement of expression*(case_item list)$/;
T_casex_statement	typedef.ml	/^		| T_casex_statement of expression*(case_item list)$/;
T_casez_statement	typedef.ml	/^		| T_casez_statement of expression*(case_item list)$/;
T_charge_strength_LARGE	typedef.ml	/^	| T_charge_strength_LARGE$/;
T_charge_strength_MEDIUM	typedef.ml	/^	| T_charge_strength_MEDIUM$/;
T_charge_strength_NOSPEC	typedef.ml	/^	| T_charge_strength_NOSPEC$/;
T_charge_strength_SMALL	typedef.ml	/^	T_charge_strength_SMALL$/;
T_continuous_assign	typedef.ml	/^		| T_continuous_assign   of continuous_assign$/;
T_continuous_assign_assign	typedef.ml	/^	T_continuous_assign_assign of drive_strength*delay*(assignment list)$/;
T_continuous_assign_net	typedef.ml	/^	| T_continuous_assign_net of string*drive_strength*expandrange*delay*(assignment list)$/;
T_delay_NOSPEC	typedef.ml	/^	 | T_delay_NOSPEC$/;
T_delay_control	typedef.ml	/^and	delay_control	= T_delay_control of expression$/;
T_delay_id	typedef.ml	/^	 | T_delay_id of string list$/;
T_delay_minmax1	typedef.ml	/^	 | T_delay_minmax1 of mintypmax_expression$/;
T_delay_minmax3	typedef.ml	/^	 | T_delay_minmax3 of mintypmax_expression*mintypmax_expression*mintypmax_expression$/;
T_delay_number	typedef.ml	/^	 T_delay_number of number$/;
T_delay_statement	typedef.ml	/^		| T_delay_statement of delay_control*statement$/;
T_disable_statement	typedef.ml	/^		| T_disable_statement of string  $/;
T_div	typedef.ml	/^	| T_div of expression*expression$/;
T_drive_strength	typedef.ml	/^	T_drive_strength of string*string$/;
T_drive_strength_NOSPEC	typedef.ml	/^	| T_drive_strength_NOSPEC$/;
T_event_control_evexp	typedef.ml	/^	| T_event_control_evexp of event_expression list$/;
T_event_control_id	typedef.ml	/^	T_event_control_id of string list$/;
T_event_declaration	typedef.ml	/^		| T_event_declaration   of string list$/;
T_event_expression	typedef.ml	/^	T_event_expression of expression$/;
T_event_expression_negedge	typedef.ml	/^	| T_event_expression_negedge of expression$/;
T_event_expression_posedge	typedef.ml	/^	| T_event_expression_posedge of expression$/;
T_event_statement	typedef.ml	/^		| T_event_statement of event_control*statement$/;
T_expandrange_NOSPEC	typedef.ml	/^	| T_expandrange_NOSPEC$/;
T_expandrange_range	typedef.ml	/^	T_expandrange_range of range$/;
T_expandrange_scalared	typedef.ml	/^	| T_expandrange_scalared of range$/;
T_expandrange_vectored	typedef.ml	/^	| T_expandrange_vectored of range$/;
T_expression_NOSPEC	typedef.ml	/^	| T_expression_NOSPEC of int$/;
T_for_statement	typedef.ml	/^		| T_for_statement of assignment*expression*assignment*statement$/;
T_force_statement	typedef.ml	/^		| T_force_statement of assignment$/;
T_forever_statement	typedef.ml	/^		| T_forever_statement of statement$/;
T_function_avoid_amb	typedef.ml	/^		| T_function_avoid_amb   of range_or_type*string*(module_item list)*statement$/;
T_gate_declaration	typedef.ml	/^		| T_gate_declaration of string*drive_strength*delay*(gate_instance list)$/;
T_gate_instance	typedef.ml	/^	T_gate_instance of string*(expression list)$/;
T_ge	typedef.ml	/^	| T_ge of expression*expression$/;
T_gt	typedef.ml	/^	| T_gt of expression*expression$/;
T_if_else_statement	typedef.ml	/^		| T_if_else_statement of expression*statement*statement$/;
T_if_statement	typedef.ml	/^		| T_if_statement of expression*statement$/;
T_initial_statement	typedef.ml	/^		| T_initial_statement   of statement$/;
T_inout_declaration	typedef.ml	/^		| T_inout_declaration    of range*(string list)$/;
T_input_declaration	typedef.ml	/^		| T_input_declaration    of range*(string list)$/;
T_integer_declaration	typedef.ml	/^		| T_integer_declaration   of register_variables list$/;
T_le	typedef.ml	/^	| T_le of expression*expression$/;
T_leadto_event	typedef.ml	/^		| T_leadto_event of string$/;
T_leftshift	typedef.ml	/^	| T_leftshift of expression*expression$/;
T_list_of_module_connections_named	typedef.ml	/^	| T_list_of_module_connections_named of named_port_connection list$/;
T_list_of_module_connections_unnamed	typedef.ml	/^	T_list_of_module_connections_unnamed of expression list$/;
T_logic_and2	typedef.ml	/^	| T_logic_and2 of expression*expression$/;
T_logic_equ	typedef.ml	/^	| T_logic_equ of expression*expression$/;
T_logic_ine	typedef.ml	/^	| T_logic_ine of expression*expression$/;
T_logic_or2	typedef.ml	/^	| T_logic_or2 of expression*expression$/;
T_logicneg	typedef.ml	/^	| T_logicneg of primary$/;
T_lt	typedef.ml	/^	| T_lt of expression*expression$/;
T_lvalue_arrbit	typedef.ml	/^	| T_lvalue_arrbit  of (string list)*expression$/;
T_lvalue_arrrange	typedef.ml	/^	| T_lvalue_arrrange of (string list)*expression*expression$/;
T_lvalue_concat	typedef.ml	/^	| T_lvalue_concat of expression list$/;
T_lvalue_id	typedef.ml	/^	T_lvalue_id of string list$/;
T_mintypmax_expression_1	typedef.ml	/^	T_mintypmax_expression_1 of expression$/;
T_mintypmax_expression_3	typedef.ml	/^	| T_mintypmax_expression_3 of expression*expression*expression$/;
T_mod	typedef.ml	/^	| T_mod of expression*expression$/;
T_module_def	typedef.ml	/^		T_module_def of string*(port list)*(module_item list)$/;
T_module_def_NOSPEC	typedef.ml	/^		| T_module_def_NOSPEC$/;
T_module_instance	typedef.ml	/^	T_module_instance of string*list_of_module_connections$/;
T_module_instantiation	typedef.ml	/^		| T_module_instantiation   of string*drive_strength*(expression list)*(module_instance list)$/;
T_mul2	typedef.ml	/^	| T_mul2 of expression*expression$/;
T_named_port_connection	typedef.ml	/^	T_named_port_connection of string*expression$/;
T_net_declaration	typedef.ml	/^		| T_net_declaration    of string*charge_strength*expandrange*delay*(string list)$/;
T_non_blocking_assignment	typedef.ml	/^		| T_non_blocking_assignment of non_blocking_assignment$/;
T_non_blocking_assignment_delay	typedef.ml	/^	| T_non_blocking_assignment_delay of lvalue*expression*delay_control$/;
T_non_blocking_assignment_direct	typedef.ml	/^	  T_non_blocking_assignment_direct of lvalue*expression$/;
T_non_blocking_assignment_event	typedef.ml	/^	| T_non_blocking_assignment_event of lvalue*expression*event_control$/;
T_number_base	typedef.ml	/^	| T_number_base of int*char*(string)$/;
T_number_float	typedef.ml	/^	| T_number_float of float$/;
T_number_unsign	typedef.ml	/^	T_number_unsign of int$/;
T_output_declaration	typedef.ml	/^		| T_output_declaration    of range*(string list)$/;
T_par_block	typedef.ml	/^		| T_par_block of string*(module_item list)*(statement list)$/;
T_param_assignment	typedef.ml	/^	T_param_assignment of (string list)*expression$/;
T_parameter_declaration	typedef.ml	/^		T_parameter_declaration of param_assignment list$/;
T_parameter_override	typedef.ml	/^		| T_parameter_override   of param_assignment list$/;
T_primary	typedef.ml	/^	  T_primary of primary$/;
T_primary_4arrayassign	typedef.ml	/^	| T_primary_4arrayassign of (arrayassign list)   (*only for defining array assignment*)$/;
T_primary_arrbit	typedef.ml	/^	| T_primary_arrbit of (string list)*expression$/;
T_primary_arrrange	typedef.ml	/^	| T_primary_arrrange of (string list)*expression*expression$/;
T_primary_concat	typedef.ml	/^	| T_primary_concat of expression list$/;
T_primary_funcall	typedef.ml	/^	| T_primary_funcall of (string list)*(expression list)$/;
T_primary_id	typedef.ml	/^	| T_primary_id of string list$/;
T_primary_minmaxexp	typedef.ml	/^	| T_primary_minmaxexp of mintypmax_expression$/;
T_primary_multiconcat	typedef.ml	/^	| T_primary_multiconcat of expression*(expression list)$/;
T_primary_num	typedef.ml	/^	T_primary_num of number$/;
T_primary_sysfuncall	typedef.ml	/^	| T_primary_sysfuncall of (string list)*(expression list)$/;
T_range	typedef.ml	/^	T_range of expression*expression$/;
T_range_NOSPEC	typedef.ml	/^	| T_range_NOSPEC$/;
T_range_int	typedef.ml	/^	| T_range_int of int*int		(*this can only be generated by Rtl.elab_range*)$/;
T_range_or_type_INTEGER	typedef.ml	/^	| T_range_or_type_INTEGER$/;
T_range_or_type_NOSPEC	typedef.ml	/^	| T_range_or_type_NOSPEC$/;
T_range_or_type_REAL	typedef.ml	/^	| T_range_or_type_REAL$/;
T_range_or_type_range	typedef.ml	/^	T_range_or_type_range of range$/;
T_real_declaration	typedef.ml	/^		| T_real_declaration   of string list$/;
T_reduce_and	typedef.ml	/^	| T_reduce_and of primary$/;
T_reduce_nand	typedef.ml	/^	| T_reduce_nand of primary$/;
T_reduce_nor	typedef.ml	/^	| T_reduce_nor of primary$/;
T_reduce_or	typedef.ml	/^	| T_reduce_or of primary$/;
T_reduce_xnor	typedef.ml	/^	| T_reduce_xnor of primary$/;
T_reduce_xor	typedef.ml	/^	| T_reduce_xor of primary$/;
T_reg_declaration	typedef.ml	/^		| T_reg_declaration   of range*(register_variables list)$/;
T_register_variables_ID	typedef.ml	/^	T_register_variables_ID of string $/;
T_register_variables_IDrange	typedef.ml	/^	| T_register_variables_IDrange of string*expression*expression$/;
T_release_statement	typedef.ml	/^		| T_release_statement of lvalue$/;
T_repeat_statement	typedef.ml	/^		| T_repeat_statement of expression*statement$/;
T_rightshift	typedef.ml	/^	| T_rightshift of expression*expression$/;
T_selection	typedef.ml	/^	| T_selection of expression*expression*expression$/;
T_seq_block	typedef.ml	/^		| T_seq_block of string*(module_item list)*(statement list)$/;
T_specify_block	typedef.ml	/^		| T_specify_block   of specify_item list$/;
T_statement_NOSPEC	typedef.ml	/^		| T_statement_NOSPEC$/;
T_string	typedef.ml	/^	| T_string of string$/;
T_sub1	typedef.ml	/^	| T_sub1 of primary$/;
T_sub2	typedef.ml	/^	| T_sub2 of expression*expression$/;
T_system_task_enable	typedef.ml	/^		| T_system_task_enable of string*(expression list)$/;
T_task	typedef.ml	/^		| T_task   of string*(module_item list)*statement$/;
T_task_enable	typedef.ml	/^		| T_task_enable of string*(expression list)		$/;
T_time_declaration	typedef.ml	/^		| T_time_declaration   of register_variables list$/;
T_wait_statement	typedef.ml	/^		| T_wait_statement of expression*statement$/;
T_while_statement	typedef.ml	/^		| T_while_statement of expression*statement$/;
Tobj_dff_declaration	circuit_obj.ml	/^	| Tobj_dff_declaration   of range (*this come from Tobj_reg_declaration subtyping, and add its clock*)$/;
Tobj_dffarray_declaration	circuit_obj.ml	/^	| Tobj_dffarray_declaration   of range*((int*(triger_expression list)) list) (*this come from Tobj_regarray_declaration subtyping, and add its clock*)$/;
Tobj_input_declaration	circuit_obj.ml	/^	| Tobj_input_declaration of range$/;
Tobj_integer_declaration	circuit_obj.ml	/^	| Tobj_integer_declaration   of expression$/;
Tobj_latch_declaration	circuit_obj.ml	/^	| Tobj_latch_declaration   of range*expression$/;
Tobj_latcharray_declaration	circuit_obj.ml	/^	| Tobj_latcharray_declaration   of range*((int*expression) list)$/;
Tobj_module_instantiation	circuit_obj.ml	/^	| Tobj_module_instantiation of module_item$/;
Tobj_net_declaration	circuit_obj.ml	/^	| Tobj_net_declaration    of range$/;
Tobj_output_declaration	circuit_obj.ml	/^	| Tobj_output_declaration of range$/;
Tobj_parameter_declaration	circuit_obj.ml	/^	Tobj_parameter_declaration of expression$/;
Tobj_pred_declaration	circuit_obj.ml	/^	| Tobj_pred_declaration    of expression (*they are 1 bit net type,but hold special predicate for control flow abstraction*)$/;
Tobj_real_declaration	circuit_obj.ml	/^	| Tobj_real_declaration   of expression$/;
Tobj_reg_declaration	circuit_obj.ml	/^	| Tobj_reg_declaration   of range$/;
Tobj_regarray_declaration	circuit_obj.ml	/^	| Tobj_regarray_declaration   of range*((int*expression) list)$/;
Triger_expression	circuit_obj.ml	/^type triger_expression = Triger_expression of expression*event_expression$/;
Typedef	typedef.ml	1;
UNSAT	elabmod.ml	/^exception UNSAT$/;
UNSATISFIABLE	elabmod.ml	/^type result = SATISFIABLE | UNSATISFIABLE$/;
UNSIGNED_NUMBER	parser.ml	/^  | UNSIGNED_NUMBER of (string)$/;
Very	very.ml	1;
__ocaml_lex_comment_rec	very.ml	/^and __ocaml_lex_comment_rec nest lexbuf __ocaml_lex_state =$/;
__ocaml_lex_endline_rec	very.ml	/^and __ocaml_lex_endline_rec lexbuf __ocaml_lex_state =$/;
__ocaml_lex_tables	very.ml	/^let __ocaml_lex_tables = {$/;
__ocaml_lex_verilog_rec	very.ml	/^and __ocaml_lex_verilog_rec lexbuf __ocaml_lex_state =$/;
addGuard	elabmod.ml	/^	method addGuard clslist pred = begin$/;
addco	elabmod.ml	/^	method addco hn co = begin$/;
alloc_index	elabmod.ml	/^	method alloc_index num= begin$/;
appendcomment	elabmod.ml	/^	method appendcomment str cls = begin$/;
arrayassign	typedef.ml	/^and	arrayassign	=$/;
assignment	typedef.ml	/^and	assignment	=$/;
binstring2int	misc2.ml	/^and binstring2int num = begin$/;
blocking_assignment	typedef.ml	/^and	blocking_assignment	=$/;
blocking_assignment2regnamelist	statement.ml	/^and blocking_assignment2regnamelist blkass = begin$/;
case_item	typedef.ml	/^and	case_item	=$/;
caseitem2stm	misc2.ml	/^and caseitem2stm ci = begin$/;
cat_string	elabmod.ml	/^	method cat_string str1 str2 = begin$/;
charge_strength	typedef.ml	/^and	charge_strength	=$/;
ci2reglist	statement.ml	/^and ci2reglist ci = begin$/;
circuit_hst	elabmod.ml	/^	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 $/;
circuit_obj	circuit_obj.ml	/^class circuit_obj = fun obj1 hn1 ->$/;
clause_list	elabmod.ml	/^	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]$/;
clause_list_multiple	elabmod.ml	/^	val mutable clause_list_multiple : ((int list)*string) list = []$/;
clause_list_multiple_saved	elabmod.ml	/^	val mutable clause_list_multiple_saved : ((int list)*string) list = []$/;
clkname	elabmod.ml	/^	val mutable clkname = "" $/;
comb_always_list	elabmod.ml	/^	val mutable comb_always_list : (statement*(string list)) list = []$/;
comment	very.ml	/^and comment nest lexbuf =$/;
compose	print_v.ml	/^let compose f g = function x -> f(g(x))$/;
compsyn	elabmod.ml	/^	method compsyn (delay:int) (length:int) (instrlist:string list) (outstrlist:string list) = begin$/;
compsyn	rtl.ml	/^	method compsyn (delay:int) (length:int) (instrlist:string list) (outstrlist:string list) = begin$/;
connect_multiple_instance_step3	elabmod.ml	/^	method connect_multiple_instance_step3 start_bound end_bound = begin$/;
construct_offset	elabmod.ml	/^	method construct_offset baseidx li ri idx2beoff= begin$/;
construct_range_onidx	elabmod.ml	/^	method construct_range_onidx baseidx li ri = begin$/;
cont_ass_list	elabmod.ml	/^	val mutable cont_ass_list : assignment list = []$/;
continuous_assign	typedef.ml	/^and	continuous_assign	=$/;
dbg_print	misc.ml	/^and dbg_print str = begin$/;
decstring2binstring	misc2.ml	/^and decstring2binstring strg = begin$/;
delay	typedef.ml	/^and	delay	=$/;
delay_control	typedef.ml	/^and	delay_control	= T_delay_control of expression$/;
delunderscore	parser.mly	/^let delunderscore strg = String.concat "" (Str.split (Str.regexp "['_']+") strg)$/;
dep_ci	dependent.ml	/^and dep_ci ci = begin$/;
dep_expression	dependent.ml	/^and dep_expression exp = begin$/;
dep_prim	dependent.ml	/^and dep_prim prim =begin$/;
dep_statement	dependent.ml	/^let rec dep_statement stat = begin$/;
drive_strength	typedef.ml	/^and	drive_strength	=$/;
duplist	misc2.ml	/^and duplist lst num = begin$/;
elabModName	main.ml	/^let elabModName = Sys.argv.(2) ;;$/;
elabmod	elabmod.ml	/^class elabmod = $/;
elaborate	rtl.ml	/^	method elaborate elabModName = begin$/;
elaboratedModuleList	rtl.ml	/^	val mutable elaboratedModuleList : elabmod list = []$/;
encode2SAT_comb_always_list	elabmod.ml	/^	method encode2SAT_comb_always_list envpred = begin$/;
encode2SAT_contass_list	elabmod.ml	/^	method encode2SAT_contass_list = begin$/;
encode2SAT_explictname	elabmod.ml	/^	method encode2SAT_explictname = begin$/;
encode2SAT_seq_always_list	elabmod.ml	/^	method encode2SAT_seq_always_list envpred= begin$/;
encode_ADD	elabmod.ml	/^	method encode_ADD vec1 vec2 = begin$/;
encode_ADD_1bit	elabmod.ml	/^	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin$/;
encode_AND2_res	elabmod.ml	/^	method encode_AND2_res r b1 b2  = begin$/;
encode_ASSIGN	elabmod.ml	/^	method encode_ASSIGN idx1 idx2 = begin$/;
encode_EQU	elabmod.ml	/^	method encode_EQU idx1 idx2 = begin$/;
encode_EQU_res	elabmod.ml	/^	method encode_EQU_res r b1 b2 = begin$/;
encode_INEV	elabmod.ml	/^	method encode_INEV l1 l2 = begin$/;
encode_INE_res	elabmod.ml	/^	method encode_INE_res r b1 b2  = begin$/;
encode_NEG	elabmod.ml	/^	method encode_NEG idx1 idx2 = begin$/;
encode_NEG_ASSIGN	elabmod.ml	/^	method encode_NEG_ASSIGN idx1 idx2 = begin$/;
encode_OR2_res	elabmod.ml	/^	method encode_OR2_res r b1 b2 = begin$/;
encode_Red_AND	elabmod.ml	/^	method encode_Red_AND li bitlst  = begin$/;
encode_Red_NAND	elabmod.ml	/^	method encode_Red_NAND li bitlst  = begin$/;
encode_Red_NOR	elabmod.ml	/^	method encode_Red_NOR li bitlst  = begin$/;
encode_Red_OR	elabmod.ml	/^	method encode_Red_OR li bitlst  = begin$/;
encode_SEL_res	elabmod.ml	/^	method encode_SEL_res r b1 b2 pred = begin$/;
encode_XOR2_res	elabmod.ml	/^	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 $/;
encode_ass	elabmod.ml	/^	method encode_ass ass = begin$/;
encode_exp	elabmod.ml	/^	method encode_exp exp = begin$/;
encode_nba_incomb	elabmod.ml	/^	method encode_nba_incomb nba envpred = begin$/;
encode_nba_inseq	elabmod.ml	/^	method encode_nba_inseq nba envpred = begin$/;
encode_number	elabmod.ml	/^	method encode_number num = begin$/;
encode_oneInstance2SAT_step1	elabmod.ml	/^	method encode_oneInstance2SAT_step1  = begin$/;
encode_pred	elabmod.ml	/^	method encode_pred exp = begin$/;
encode_prim	elabmod.ml	/^	method encode_prim prim = begin$/;
encode_statement_incomb	elabmod.ml	/^	method encode_statement_incomb envpred stat = begin$/;
encode_statement_inseq	elabmod.ml	/^	method encode_statement_inseq envpred stat  = begin$/;
endline	very.ml	/^and endline lexbuf =$/;
event_control	typedef.ml	/^and	event_control	=$/;
event_expression	typedef.ml	/^and	event_expression	=$/;
eventype	rtl.ml	/^type eventype=Noedge | Edge$/;
exp2int_simple	expression.ml	/^let rec exp2int_simple exp = begin$/;
exp2lv	misc2.ml	/^and exp2lv exp =begin$/;
exp2lv	print_v.ml	/^and exp2lv exp = begin$/;
exp2reglist	statement.ml	/^and exp2reglist exp = begin$/;
expandrange	typedef.ml	/^and	expandrange	=$/;
expression	typedef.ml	/^and	expression	=$/;
extract_idlst_from_exp	misc2.ml	/^and extract_idlst_from_exp exp = begin$/;
extract_idlst_from_prim	misc2.ml	/^let rec extract_idlst_from_prim prim = begin$/;
extract_var_from_eventexp	misc2.ml	/^and extract_var_from_eventexp evexp = begin$/;
falsepred	elabmod.ml	/^	val falsepred =2$/;
final_index_oneinst	elabmod.ml	/^	val mutable final_index_oneinst = 0$/;
findOneModuleInVerystruct	rtl.ml	/^	method findOneModuleInVerystruct modName = begin$/;
find_inass	elabmod.ml	/^	method find_inass res_intlst idx = begin$/;
find_pin_exp	elabmod.ml	/^	method find_pin_exp pinname npclst = begin$/;
find_pin_exp	print_v.ml	/^and find_pin_exp pinname npclst = begin$/;
findco	elabmod.ml	/^	method findco hn = begin$/;
findco_str	elabmod.ml	/^	method findco_str str = begin$/;
findoutclock	print_v.ml	/^and findoutclock portlst moditmlst = begin$/;
gate_instance	typedef.ml	/^and	gate_instance	=$/;
gen_list_from_interval	misc2.ml	/^and gen_list_from_interval idxlft idxrgt = begin$/;
gen_list_from_interval_step	misc2.ml	/^and gen_list_from_interval_step idxlft idxrgt step= begin (*interval means from idxlft idxrgt-1 or +1, dont make them equal*)$/;
gen_multiple_instance_step2	elabmod.ml	/^	method gen_multiple_instance_step2 bound = begin$/;
get1b0	misc2.ml	/^and get1b0 = T_primary(T_primary_num(T_number_base(1,'b',"0")))$/;
get1b1	misc2.ml	/^and get1b1 = T_primary(T_primary_num(T_number_base(1,'b',"1")))$/;
get_depidlst_from_always_comb	misc2.ml	/^and get_depidlst_from_always_comb stm = begin$/;
get_endpos	parser.mly	/^let get_endpos pos2 = begin$/;
get_hn	circuit_obj.ml	/^	method get_hn = hn$/;
get_int_bits_as_prim	misc2.ml	/^and get_int_bits_as_prim ivalue left right = begin$/;
get_largest_varindex_incls	elabmod.ml	/^	method get_largest_varindex_incls cls = begin$/;
get_largest_varindex_inclslst	elabmod.ml	/^	method get_largest_varindex_inclslst clslst= begin$/;
get_lvidlst_from_always_comb	misc2.ml	/^and get_lvidlst_from_always_comb stm = begin$/;
get_obj	circuit_obj.ml	/^	method get_obj = obj$/;
get_pos	parser.mly	/^let get_pos (pos : Lexing.position ) = begin$/;
get_rng_width	misc2.ml	/^and get_rng_width rng = begin$/;
get_str_from_strlst	misc2.ml	/^and get_str_from_strlst strlst = begin$/;
get_str_from_strlst	print_v.ml	/^and get_str_from_strlst strlst = String.concat "\/" strlst$/;
get_width	circuit_obj.ml	/^	method get_width = begin$/;
getid	circuit_obj.ml	/^	method getid = strlst$/;
getname	circuit_obj.ml	/^	method getname =  String.concat "\/" strlst$/;
getname	elabmod.ml	/^	method getname = name$/;
hex2bin	misc2.ml	/^and hex2bin c = begin$/;
hexstring2binstring	misc2.ml	/^and hexstring2binstring strg = begin$/;
hierachcal_name	circuit_obj.ml	/^class hierachcal_name = fun strlst1 ->$/;
hn	circuit_obj.ml	/^	val hn : hierachcal_name = hn1$/;
id2exp	misc2.ml	/^and id2exp id = begin$/;
id2string	statement.ml	/^and id2string strlst = begin$/;
idequ	misc2.ml	/^and idequ id1 id2 = begin$/;
idlst_intersect	misc2.ml	/^and idlst_intersect idlst1 idlst2 = begin$/;
idx2name	elabmod.ml	/^	method idx2name idx_unmapped = begin$/;
init	elabmod.ml	/^	method init module2beElaborated tempdirname1 = begin$/;
inputFileChannle	main.ml	/^let inputFileChannle = open_in inputFileName;;$/;
inputFileName	main.ml	/^let inputFileName = Sys.argv.(1) ;;$/;
int2bin	misc2.ml	/^and int2bin i = begin(*notice that the order is reversed*)$/;
int2exp_width	misc2.ml	/^and int2exp_width i w= begin$/;
intconst2exp	misc2.ml	/^and intconst2exp i = T_primary(T_primary_num(T_number_unsign(i)))$/;
integer_declaration	typedef.ml	/^and	integer_declaration	= register_variables list$/;
is_T_parameter_declaration	misc2.ml	/^and is_T_parameter_declaration mi = begin$/;
is_false	misc2.ml	/^and is_false exp = begin$/;
is_idlst_intersect	misc2.ml	/^and is_idlst_intersect idlst1 idlst2 = begin$/;
is_inrange	elabmod.ml	/^	method is_inrange rng off = begin$/;
is_pure_blocking_assignment	misc2.ml	/^and is_pure_blocking_assignment stm = begin$/;
is_pure_nonblocking_assignment	misc2.ml	/^and is_pure_nonblocking_assignment stm = begin$/;
is_true	misc2.ml	/^and is_true exp = begin$/;
is_write_after_read	misc2.ml	/^and is_write_after_read  stm  = begin$/;
isdff	elabmod.ml	/^	method isdff name = begin$/;
last_index	elabmod.ml	/^	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)$/;
last_index_saved	elabmod.ml	/^	val mutable last_index_saved = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)$/;
lexbuf	main.ml	/^let lexbuf = Lexing.from_channel inputFileChannle;;$/;
list_headlst	misc2.ml	/^and list_headlst lst num = begin$/;
list_iter_interleave	misc2.ml	/^and list_iter_interleave operate inter lst = begin$/;
list_last	misc2.ml	/^and list_last lst = begin$/;
list_last	print_v.ml	/^and list_last lst = begin$/;
list_of_module_connections	typedef.ml	/^and	list_of_module_connections	=$/;
list_taillst	misc2.ml	/^and list_taillst lst num = begin$/;
lr2list	elabmod.ml	/^	method lr2list li ri = begin$/;
lst_lastn	misc.ml	/^and lst_lastn lst n = begin$/;
lv2regnamelist	statement.ml	/^and lv2regnamelist lv = begin$/;
lvalue	typedef.ml	/^and	lvalue 		=$/;
lvalue2idlst	misc2.ml	/^and lvalue2idlst lv = begin$/;
map_ass2var	elabmod.ml	/^	method map_ass2var bound res_intlst = begin$/;
map_lv2index	elabmod.ml	/^	method map_lv2index lv = begin (*return the list of index from left to right*)$/;
mintypmax_expression	typedef.ml	/^and	mintypmax_expression	=$/;
module_def	typedef.ml	/^type	module_def	=$/;
module_instance	typedef.ml	/^and	module_instance	=$/;
module_item	typedef.ml	/^and	module_item	=$/;
name	elabmod.ml	/^	val mutable name = ""$/;
name2idxlist	elabmod.ml	/^	method name2idxlist name = begin$/;
name2range	elabmod.ml	/^	method name2range name = begin$/;
nameInportlist	elabmod.ml	/^	method nameInportlist name1 = begin$/;
name_index_lst	elabmod.ml	/^	val mutable name_index_lst : (string*(int*int)) list = []  $/;
named_port_connection	typedef.ml	/^and	named_port_connection	=$/;
non_blocking_assignment	typedef.ml	/^and	non_blocking_assignment	=$/;
non_blocking_assignment2regnamelist	statement.ml	/^and non_blocking_assignment2regnamelist nba = begin$/;
num2int_simple	expression.ml	/^and num2int_simple num = begin$/;
number	typedef.ml	/^and	number	=$/;
obj	circuit_obj.ml	/^	val obj : tobj = obj1$/;
offset2idx	elabmod.ml	/^	method offset2idx left right baseidx offset = baseidx + abs(offset - left)$/;
oldtime	misc.ml	/^let oldtime=ref (Unix.gettimeofday ());;$/;
param_assignment	typedef.ml	/^and	param_assignment	=$/;
parse_error	parser.mly	/^let parse_error str = begin$/;
parse_satres	elabmod.ml	/^	method parse_satres reslogname = begin$/;
port	typedef.ml	/^and	port		=$/;
portlist	elabmod.ml	/^	val mutable portlist = []$/;
pos_cn	parser.mly	/^let pos_cn = ref 0;;$/;
pos_fn	parser.mly	/^let pos_fn = ref "";;$/;
pos_ln	parser.mly	/^let pos_ln = ref 0;;$/;
prim2int_simple	expression.ml	/^and prim2int_simple prim = begin$/;
prim2reglist	statement.ml	/^and prim2reglist prim = begin$/;
primary	typedef.ml	/^and	primary		=$/;
print	circuit_obj.ml	/^	method print vchout = Printf.fprintf vchout "%s" (self#getname)$/;
print	elabmod.ml	/^	method print dumpout = begin$/;
print_blank	print_v.ml	/^let print_blank voutch a = begin$/;
print_blank_endline	print_v.ml	/^let print_blank_endline voutch a = begin$/;
print_cnf	elabmod.ml	/^	method print_cnf clslst dumpout_cnf dly len prefix forward instrlist outstrlist= begin$/;
print_comma	print_v.ml	/^let print_comma voutch a = begin$/;
print_comma_endline	print_v.ml	/^let print_comma_endline voutch a = begin$/;
print_dot	print_v.ml	/^let print_dot voutch a = begin$/;
print_id	print_v.ml	/^let print_id voutch id = begin$/;
print_or	print_v.ml	/^let print_or voutch a = begin$/;
print_orendline	print_v.ml	/^let print_orendline voutch a = begin$/;
print_rtl	rtl.ml	/^	method print_rtl modName dumpout = begin$/;
print_simplyendline	print_v.ml	/^let print_simplyendline voutch a = begin$/;
print_v_arrayassign	print_v.ml	/^and print_v_arrayassign voutch arrass = begin$/;
print_v_assignment	print_v.ml	/^and print_v_assignment voutch ass = begin$/;
print_v_case_item	print_v.ml	/^and print_v_case_item voutch caseit = begin$/;
print_v_charge_strength	print_v.ml	/^and print_v_charge_strength voutch chg_strg = begin$/;
print_v_delay	print_v.ml	/^and print_v_delay voutch dly = begin$/;
print_v_delay_control	print_v.ml	/^and print_v_delay_control voutch dlyctl = begin$/;
print_v_drive_strength	print_v.ml	/^and print_v_drive_strength voutch drvstr = begin$/;
print_v_event_control	print_v.ml	/^and print_v_event_control voutch evnctl = begin$/;
print_v_event_expression	print_v.ml	/^and print_v_event_expression voutch evnexp = begin$/;
print_v_expandrange	print_v.ml	/^and print_v_expandrange voutch exprang = begin$/;
print_v_expression	print_v.ml	/^and print_v_expression voutch exp = begin$/;
print_v_expression_exlif	print_v.ml	/^and print_v_expression_exlif voutch exp = begin$/;
print_v_gate_instance	print_v.ml	/^and print_v_gate_instance voutch gi = begin$/;
print_v_list_of_module_connections	print_v.ml	/^and print_v_list_of_module_connections voutch connectlst = begin$/;
print_v_lvalue	print_v.ml	/^and print_v_lvalue voutch lv = begin$/;
print_v_mintypmax_expression	print_v.ml	/^and print_v_mintypmax_expression voutch minmaxexp = begin$/;
print_v_module_def	print_v.ml	/^and print_v_module_def voutch inst_module_def = begin$/;
print_v_module_instance	print_v.ml	/^and print_v_module_instance voutch mi = begin$/;
print_v_module_item	print_v.ml	/^and print_v_module_item voutch moditm = begin$/;
print_v_module_item_gates	print_v.ml	/^and print_v_module_item_gates voutch  clkstr moditm = begin$/;
print_v_module_item_inputs	print_v.ml	/^and print_v_module_item_inputs voutch clkstr moditm = begin$/;
print_v_module_item_outputs	print_v.ml	/^and print_v_module_item_outputs voutch moditm = begin$/;
print_v_named_port_connection	print_v.ml	/^and print_v_named_port_connection voutch namedconn = begin$/;
print_v_named_port_connection_exlif	print_v.ml	/^and print_v_named_port_connection_exlif voutch namedconn rng= begin$/;
print_v_number	print_v.ml	/^let print_v_number voutch numb = begin$/;
print_v_param_assignment	print_v.ml	/^and print_v_param_assignment voutch pa = begin$/;
print_v_primary	print_v.ml	/^let rec print_v_primary voutch prim = begin$/;
print_v_primary_exlif	print_v.ml	/^and print_v_primary_exlif voutch prim = begin$/;
print_v_printlst	print_v.ml	/^let print_v_printlst voutch lst dofunc sepfunc = begin$/;
print_v_range	print_v.ml	/^and print_v_range voutch rng = begin$/;
print_v_register_variable	print_v.ml	/^and print_v_register_variable voutch regv = begin$/;
print_v_source_text	print_v.ml	/^and print_v_source_text voutch inst_T_module_def_lst = begin$/;
print_v_statement	print_v.ml	/^and print_v_statement voutch stat = begin$/;
proc_MI	elabmod.ml	/^	method proc_MI mi= begin$/;
proc_T_always_statement	elabmod.ml	/^	method proc_T_always_statement stat = begin$/;
proc_T_always_statement_comb	elabmod.ml	/^	method proc_T_always_statement_comb stat = begin$/;
proc_T_always_statement_seq	elabmod.ml	/^	method proc_T_always_statement_seq stat = begin$/;
proc_T_continuous_assign	elabmod.ml	/^	method proc_T_continuous_assign cont_ass = begin$/;
proc_T_input_declaration	elabmod.ml	/^	method proc_T_input_declaration range namelst = begin$/;
proc_T_net_declaration	elabmod.ml	/^	method proc_T_net_declaration nettypename exprng namelst = begin$/;
proc_T_output_declaration	elabmod.ml	/^	method proc_T_output_declaration range namelst = begin$/;
proc_T_reg_declaration	elabmod.ml	/^	method proc_T_reg_declaration  rng regvarlst = begin$/;
proc_name_index	elabmod.ml	/^	method proc_name_index inst res_intlst ni = begin$/;
range	typedef.ml	/^and	range	=$/;
range_or_type	typedef.ml	/^and	range_or_type	=$/;
regcnt	elabmod.ml	/^	val mutable regcnt = 0 ;$/;
register_variables	typedef.ml	/^and	register_variables	=$/;
remove_last	misc2.ml	/^and remove_last lst = begin$/;
result	elabmod.ml	/^type result = SATISFIABLE | UNSATISFIABLE$/;
rng2list	elabmod.ml	/^	method rng2list rng = begin$/;
rng2lr	elabmod.ml	/^	method rng2lr rng= begin$/;
rng_baseidx_2_idxlist	elabmod.ml	/^	method rng_baseidx_2_idxlist rng baseidx = begin$/;
rplco	elabmod.ml	/^	method rplco hn co = begin$/;
rtl	rtl.ml	/^class rtl  = fun very_struct_init tmpdirname1  ->$/;
seq_always_list	elabmod.ml	/^	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)$/;
setcomment	elabmod.ml	/^	method setcomment str cls = begin$/;
source_text	parser.ml	/^let source_text (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =$/;
specify_item	typedef.ml	/^and	specify_item	= int$/;
starttime	misc.ml	/^let starttime=ref (Unix.gettimeofday ());;$/;
statement	typedef.ml	/^and	statement	=$/;
statement2regnamelist	statement.ml	/^let rec statement2regnamelist stat = begin$/;
str2exp	misc2.ml	/^and str2exp str = begin$/;
string2base_number	parser.mly	/^let string2base_number strg =$/;
string2charlist	misc.ml	/^and string2charlist str = begin$/;
string_equ	misc.ml	/^let string_equ str1 str2 =$/;
strlst	circuit_obj.ml	/^	val strlst : (string list ) = strlst1$/;
suggest_name_for_exp	misc2.ml	/^and suggest_name_for_exp exp = begin$/;
suggest_name_for_prim	misc2.ml	/^and suggest_name_for_prim prim = begin$/;
tempdirname	elabmod.ml	/^	val mutable tempdirname = ""$/;
tmpdirname	rtl.ml	/^	val tmpdirname = tmpdirname1$/;
tobj	circuit_obj.ml	/^type tobj = $/;
token	parser.ml	/^type token =$/;
triger_expression	circuit_obj.ml	/^type triger_expression = Triger_expression of expression*event_expression$/;
truepred	elabmod.ml	/^	val truepred = 1$/;
uniqlst	misc.ml	/^let rec uniqlst lst =begin$/;
unique_name_generator	misc.ml	/^let unique_name_generator () =$/;
uniquenamereg	misc.ml	/^let uniquenamereg = ref 0;;$/;
uniquify_idlst	misc2.ml	/^and uniquify_idlst idlst = begin$/;
verilog	very.ml	/^let rec verilog lexbuf =$/;
very_struct	main.ml	/^let very_struct = Parser.source_text Very.verilog lexbuf ;;$/;
very_struct	rtl.ml	/^	val very_struct = very_struct_init$/;
yyact	parser.ml	/^let yyact = [|$/;
yycheck	parser.ml	/^let yycheck = "\\030\\000\\$/;
yydefred	parser.ml	/^let yydefred = "\\000\\000\\$/;
yydgoto	parser.ml	/^let yydgoto = "\\002\\000\\$/;
yygindex	parser.ml	/^let yygindex = "\\000\\000\\$/;
yylen	parser.ml	/^let yylen = "\\002\\000\\$/;
yylhs	parser.ml	/^let yylhs = "\\255\\255\\$/;
yynames_block	parser.ml	/^let yynames_block = "\\$/;
yynames_const	parser.ml	/^let yynames_const = "\\$/;
yyrindex	parser.ml	/^let yyrindex = "\\000\\000\\$/;
yysindex	parser.ml	/^let yysindex = "\\085\\000\\$/;
yytable	parser.ml	/^let yytable = "\\103\\000\\$/;
yytables	parser.ml	/^let yytables =$/;
yytablesize	parser.ml	/^let yytablesize = 4437$/;
yytransl_block	parser.ml	/^let yytransl_block = [|$/;
yytransl_const	parser.ml	/^let yytransl_const = [|$/;
