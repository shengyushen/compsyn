(*correctly found the parameter, but
1 can not characterize
2 too slow
*)

open Printf
open Typedef
open Circuit_obj
open Print_v
open Misc
open Statement
open Str
open Clauseman
open Interp
open Bddssy
open Aig
open Statement

exception UNSAT

		

class elabmod = 
object (self)

	(*these will be generated in init method*)
	val mutable name = ""
	val mutable portlist = []
	val mutable tempdirname = ""
	
	(*these will be generated in elaborate method*)
	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 
	val mutable clkname = "" 
	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)
	val mutable comb_always_list : (statement*(string list)) list = []
	val mutable cont_ass_list : assignment list = []

	(*these will be generatesd in encode_oneInstance2SAT_step1 method*)
	(*
		relation between varaibles name and its index
		the int pair in name_index_lst is for dff only, 
			the first one is current state, 
			the second one is for next state, which should be the first one plus rng width
		for other case
			only the first one is meaningful
			the second one must be -1
		
	*)
	val mutable name_index_lst : (string*(int*int)) list = []  
	
	val mutable lock_oneinst : bool = false
	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable final_index_oneinst = 0
	
	val truepred = 1
	val falsepred =2
	val assertion_shengyushen ="assertion_shengyushen"
	(*these will generated by multiple instance generation*)

	(*to prevent incidently change of clause_list_multiple and last_index*)
	val mutable lock_multiple : bool = false
	val mutable clause_list_multiple : ((int list)*string) list = []
	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	(*these will be generated by compsyn*)
	(*they will never be changed after assignment*)
	val mutable instrlist = []
	val mutable outstrlist = []
	val mutable non_proctocol_input_list = []
	
	(*they will never be changed after assignment*)
	val mutable bv_instrlist = []
	val mutable bv_outstrlist = []
	val mutable bv_non_proctocol_input_list = []

	val mutable rstSigName = ""
	val mutable rstValue = 3
	val mutable initStateClauseList = []
	
	val mutable ddM = CaddieBdd.init 0 64 256 512

  method getResetSignalIndex = begin
		assert(rstSigName<>"");
		assert(rstValue==0 || rstValue ==1);
		try
			fst (List.assoc rstSigName name_index_lst)  
		with  Not_found  -> begin
			dbg_print "FATAL : not found";
			dbg_print rstSigName;
			exit 1;
		end
	end
	
	method shiftCycleIndex shift idx = begin
		assert ( final_index_oneinst != 0 );
		let res = idx + shift * final_index_oneinst 
		in begin
			assert ( res <= last_index );
			res
		end
	end

	method shiftCycleList shift v = begin
		List.map (self#shiftCycleIndex shift) v
	end

	method print dumpout = begin
		fprintf dumpout "module %s (\n" name;
		list_iter_interleave (fun x -> fprintf dumpout "   %s " (get_str_from_strlst x)) (fun x -> fprintf dumpout " , \n") portlist;
		fprintf dumpout "\n);\n";
		
		(*print out all input*)
		let print_input key cont = begin
			match cont#get_obj with
			Tobj_input_declaration(rng) -> begin
				fprintf dumpout "   input ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_input circuit_hst
		;
		
		(*print out all output*)
		let print_output key cont = begin
			match cont#get_obj with
			Tobj_output_declaration(rng) -> begin
				fprintf dumpout "   output ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_output circuit_hst
		;
		
		(*print out all wire*)
		let print_wire key cont = begin
			match cont#get_obj with
			Tobj_net_declaration(rng) -> begin
				fprintf dumpout "   wire ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_wire circuit_hst
		;
		
		(*print out all reg*)
		let print_reg key cont = begin
			match cont#get_obj with
			Tobj_reg_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| Tobj_dff_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_reg circuit_hst
		;
		
		(*print out all seq*)
		let print_seq seq_always = begin
			match seq_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(posedge %s) begin\n" clkname;
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
		end
		in
		List.iter print_seq seq_always_list
		;
		
		(*print out all comb*)
		let print_comb comb_always = begin
			match comb_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(\n";
				
				let deplist = dep_statement_wrap stat
				in
				list_iter_interleave (fun x -> fprintf dumpout " %s " x) (fun x -> fprintf dumpout " or ") deplist
				;
				
				fprintf dumpout ") begin\n";
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
		end
		in
		List.iter print_comb comb_always_list
		;
		
		(*print out all cont assign*)
		let print_cont_ass cont_ass = begin
			match cont_ass with
			T_assignment(lv,exp) -> begin
				fprintf dumpout "assign  ";
				print_v_lvalue dumpout lv;
				fprintf dumpout " = ";
				print_v_expression dumpout exp;
				fprintf dumpout ";\n"
			end
			(*| _ -> ()*)
		end
		in
		List.iter print_cont_ass cont_ass_list
		;
		
		fprintf dumpout "endmodule\n"
	end

	method getname = name

	method addco str co = begin
		(*Printf.printf "adding %s\n" str ;*)
		Hashtbl.add circuit_hst str co
	end

	method rplco str co = begin
		(*Printf.printf "replacing %s\n" str ;*)
		Hashtbl.replace circuit_hst str co
	end

	method findco str = begin
		try 
			Hashtbl.find circuit_hst str
		with Not_found -> begin
			Printf.printf "fatal error : undefined hn %s are treated as wire\n" str;
			exit 1
			(*following code is for those large number of undefined net*)
			(*self#addco hn (new circuit_obj (Tobj_net_declaration(T_range_NOSPEC,T_expression_NOSPEC(1)))  hn);
			Hashtbl.find circuitobj_hst hn#getname *)
		end
	end

	method nameInportlist name1 = begin
		let check_portname pt = begin
			match pt with 
			[ptn] -> string_equ ptn name1
			|_ -> begin
				Printf.printf "fatal error : port name should not be a list\n";
				exit 1
			end
		end
		in 
		let portfound = List.filter check_portname  portlist
		in begin
			if (List.length portfound) != 1 then begin
				Printf.printf "fatal error : portfound is not unique\n";
				exit 1
			end
		end
	end
	
	method proc_T_input_declaration range namelst = begin
		let proc_one_input name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn = new hierachcal_name [name1]
			in
			let inCircuitObj = new circuit_obj (Tobj_input_declaration(range))  newhn
			in
			self#addco name1 inCircuitObj
		end
		in 
		List.iter proc_one_input namelst
	end
	
	method proc_T_output_declaration range namelst = begin
		let proc_one_output name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn = new hierachcal_name [name1]
			in
			let outCircuitObj = new circuit_obj (Tobj_output_declaration(range))  newhn
			in
			self#addco name1 outCircuitObj
		end
		in 
		List.iter proc_one_output namelst
	end
	
	method proc_T_net_declaration nettypename exprng namelst = begin
		if (string_equ nettypename "wire") != true then begin
			Printf.printf "fatal error : only supported wire\n";
			Printf.printf "%s\n" nettypename;
			exit 1
		end
		;
		let rng = match exprng with
		T_expandrange_range(rng1) -> rng1
		| T_expandrange_NOSPEC -> T_range_NOSPEC
		|_ -> begin
			Printf.printf "fatal error : only supported T_expandrange_range\n";
			exit 1
		end
		in begin
			let proc_one_net netn = begin
				(*add it to circuit object list*)
				let newhn = new hierachcal_name [netn]
				in
				let netCircuitObj = new circuit_obj (Tobj_net_declaration(rng))  newhn
				in
				self#addco netn netCircuitObj
			end
			in 
			List.iter proc_one_net namelst
		end
	end
	
	method proc_T_reg_declaration  rng regvarlst = begin
		let proc_one_reg regvar = begin
			(*add it to circuit object list*)
			match regvar with
			T_register_variables_ID(regname) -> begin
				let newhn = new hierachcal_name [regname]
				in
				let regCircuitObj = new circuit_obj (Tobj_reg_declaration(rng))  newhn
				in
				self#addco regname regCircuitObj
			end
			| T_register_variables_IDrange(regname,lexp,rexp) -> begin
				Printf.printf "fatal error : not supported T_register_variables_IDrange\n";
				exit 1
			end
		end
		in 
		List.iter proc_one_reg regvarlst
	end
	
	method proc_T_continuous_assign cont_ass = begin
		let asslst = begin
			match cont_ass with
			T_continuous_assign_assign(_,_,asslst1) -> asslst1
			| T_continuous_assign_net(nettypename,_,exprng,_,asslst1) -> begin
				(*i need to first put them into circuit object list*)
				begin
					let ass2name ass = begin
						match ass with 
						T_assignment(lv,_) -> begin
							match lv with 
							T_lvalue_id([nm]) -> nm
							| _ -> begin
								Printf.printf "fatal error : only supported T_lvalue_id 2\n";
								exit 1
							end
						end
					end
					in
					let namelst = List.map ass2name asslst1
					in
					self#proc_T_net_declaration nettypename exprng namelst
				end
				;
				asslst1
			end
		end
		in  cont_ass_list <- asslst @ cont_ass_list
		(*begin
			let proc_ass ass = begin
				match ass with
				T_assignment(lv,exp) -> begin
					match lv with
					T_lvalue_id([nm]) -> begin
						let hn = new hierachcal_name [nm]
						in
						let rngold = begin
							match ((self#findco nm)#get_obj) with
							Tobj_net_declaration(rngo,_) -> rngo
							| _ -> begin
								Printf.printf "fatal error : only should find Tobj_net_declaration \n";
								exit 1
							end
						end
						in
						let co = new circuit_obj (Tobj_net_declaration(rngold,exp)) hn
						in
						self#rplco nm co
					end
					| T_lvalue_arrbit
					| _ -> begin
						Printf.printf "fatal error : only supported T_lvalue_id 1\n";
						print_v_lvalue stdout lv;
						exit 1
					end
				end
			end
			in
			List.iter proc_ass asslst
		end*)
	end
	
	method proc_T_always_statement_seq stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				if (List.length evexplst) != 1 then begin
					Printf.printf "fatal error : only supported sync set and reset regs\n";
					exit 1
				end
				;
				(*set the clock*)
				let clkeve =(List.hd evexplst)
				in begin
					match clkeve with 
					T_event_expression_posedge(exp) -> begin
						match exp with
						T_primary(T_primary_id([clkn])) -> begin
							if (string_equ clkname "") then clkname <- clkn
							else if (string_equ clkname clkn) then clkname <- clkn
							else begin
								Printf.printf "fatal error : only supported one clock\n";
								exit 1
							end
						end
						| _ -> begin
							Printf.printf "fatal error : only supported id as clock name\n";
							exit 1
						end
					end
					| _ -> begin
						Printf.printf "fatal error : only supported T_event_expression_posedge\n";
						exit 1
					end
				end
				;
				(*extract the reg name list*)
				let regnamelist = statement2regnamelist_wrap stat_sub
				in begin
					(*add these reg's definition to list*)
					seq_always_list <- (stat_sub,regnamelist) :: seq_always_list
					;
					(*change them to dff*)
					let proc_reg regname = begin
						let hn = new hierachcal_name [regname]
						in
						let co = self#findco regname
						in begin
							match co#get_obj with
							Tobj_reg_declaration(rngr) -> begin
								self#rplco regname (new circuit_obj (Tobj_dff_declaration(rngr)) hn)
							end
							| Tobj_dff_declaration(_) -> begin
								Printf.printf "warning : why it is already dff?\n";
								Printf.printf "%s\n" regname;
							end
							| _ -> begin
								Printf.printf "fatal error : object in always statement should be declared as reg\n";
								Printf.printf "%s\n" regname;
								exit 1
							end
						end
					end
					in
					List.iter proc_reg regnamelist
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement_comb stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			let regnamelist = statement2regnamelist_wrap stat_sub
			in
			comb_always_list <- (stat_sub,regnamelist) :: comb_always_list
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				let isedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> true
					| T_event_expression_negedge(_) -> true
					| _ -> false
				end
				and notedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> false
					| T_event_expression_negedge(_) -> false
					| _ -> true
				end
				in
				if (List.for_all isedgeevent evexplst) then self#proc_T_always_statement_seq stat
				else if (List.for_all notedgeevent evexplst) then self#proc_T_always_statement_comb stat
				else begin
					Printf.printf "fatal error : edge and non edge event at the same time\n";
					exit 1
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_MI mi = begin
		match mi with
		T_parameter_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_declaration\n";
			exit 1
		end
		| T_input_declaration(range,namelst) -> 
			self#proc_T_input_declaration range namelst
		| T_output_declaration(range,namelst) -> 
			self#proc_T_output_declaration range namelst
		| T_inout_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_inout_declaration\n";
			exit 1
		end
		| T_net_declaration(netname,_,exprng,_,namelst) -> 
			self#proc_T_net_declaration netname exprng namelst
		| T_reg_declaration(rng,regvarlst) -> 
			self#proc_T_reg_declaration rng regvarlst
		| T_time_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_time_declaration\n";
			exit 1
		end
		| T_integer_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_integer_declaration\n";
			exit 1
		end
		| T_real_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_real_declaration\n";
			exit 1
		end
		| T_event_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_event_declaration\n";
			exit 1
		end
		| T_gate_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_gate_declaration\n";
			exit 1
		end
		| T_module_instantiation(_) -> begin
			Printf.printf "fatal error : not supported T_module_instantiation\n";
			exit 1
		end
		| T_parameter_override(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_override\n";
			exit 1
		end
		| T_continuous_assign(cont_ass) ->  
			self#proc_T_continuous_assign cont_ass
		| T_specify_block(_) -> begin
			Printf.printf "fatal error : not supported T_specify_block\n";
			exit 1
		end
		| T_initial_statement(_) -> begin
			Printf.printf "fatal error : not supported T_initial_statement\n";
			exit 1
		end
		| T_always_statement(stat) -> 
			self#proc_T_always_statement stat
		| T_task(_,_,_) -> begin
			Printf.printf "fatal error : not supported T_task\n";
			exit 1
		end
		| T_function_avoid_amb(_,_,_,_) -> begin
			Printf.printf "fatal error : not supported T_function_avoid_amb\n";
			exit 1
		end
	end

	method init module2beElaborated tempdirname1 = begin
		match module2beElaborated with
		T_module_def(modName,portlist1,milist) -> begin
			name <- modName;
			portlist <- portlist1;
			tempdirname <- tempdirname1;
			(*processing mi list*)
			List.iter (self#proc_MI) milist
		end
		| _ -> begin
			Printf.printf "fatal error : only T_module_def\n";
			exit 1
		end
	end
	
	method name2idxlist name = begin
		let baseidx = begin
			let (x1,_)= List.assoc name name_index_lst
			in x1
		end
		and rng = self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method name2idxlist_nxt name = begin
		let baseidx = begin
			let (_,x1)= List.assoc name name_index_lst
			in x1
		end
		and rng = self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method is_assertion (name_index:(string*int)) = begin
		match name_index with 
		(nm,_) -> begin
			string_equ nm assertion_shengyushen
		end
	end

	method constrain_assertion li = begin (*li is from bound-1 to 0*)
		(*let maxidx = get_largest_varindex_inclslst clause_list_multiple in*)
		(*2014/11/16 Shen : we dont need to run in list mode as assertion_shengyushen have only one element*)
		(*let ov = List.concat (List.map self#name2idxlist [assertion_shengyushen]) in *)
		let ov = self#name2idxlist assertion_shengyushen in 
		let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov in
		List.map (fun x -> (*assert (x<= maxidx) ;*)([x],assertion_shengyushen) ) ov_0
	end

	method try_assertion start_i end_i = begin
		if(end_i<start_i) then []
		else begin
			let old_assclslst = self#constrain_assertion end_i
			and cur_assclslst = self#try_assertion start_i (end_i-1)
			in
			old_assclslst@cur_assclslst
		end
	end

	(*return the new result of equ*)
	method alloc_and_equ_res ov_pair_lst = begin
		match ov_pair_lst with 
		(a, b) -> begin
			let r = self#alloc_index 1
			in
			let equres = self#encode_EQU_res r a b
			in 
			(r,equres)
		end
	end
	
	(*from here on is the list of method of complementary synthesis*)


(*	method tryPCSAT p l r assLst = begin
		(*dbg_print (sprintf "tryPCSAT p %d l %d r %d" p l r);*)
		(*this do not include the input constrain*)
		(*NOTICE Shen : we dont enforce the assLst in construct_nonloop now,
		we have a new gen_invassertion for it*)
		let target=self#construct_nonloop p l r assLst  in begin
			self#set_unlock_multiple;
			self#append_clause_list_multiple  [([target],"target")]
		end
		;

		(*force the input of p+l and p+l+1+r+p+l to be diff*)
		self#set_unlock_multiple;
		let ov = bv_instrlist	in 
		let ov_0 = List.map (fun x -> x+ (p+l)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+l+1+r+p+l)*final_index_oneinst) ov in
		self#append_clause_list_multiple  (self#encode_INEV (ov_0) (ov_b)) 
		;
		(*dbg_print "  after generating clauses";*)

		check_clslst_maxidx clause_list_multiple last_index;
		let res=Dumpsat.dump_sat_withclear clause_list_multiple in begin
			(*dbg_print "exiting tryPCSAT";*)
			if(res == UNSATISFIABLE) then false
			else if(res == SATISFIABLE) then true
			else assert false
		end
	end

	method minimizeL p l r assLst = begin
		assert (p>=0);
		assert (r>=0);
		if (l>=(-r+1)) then begin
			let res=self#tryPCSAT p (l-1) r assLst in begin
				if(res) then l
				else self#minimizeL p (l-1) r assLst 
			end
		end
		else if(l==0) then 0
		else assert false
	end

	method minimizeR p l r assLst = begin
		assert (p>=0);
		assert (l>=0);
		if (r>=1) then begin
			let res=self#tryPCSAT p l (r-1) assLst in begin
				if(res) then r
				else self#minimizeR p l (r-1) assLst 
			end
		end
		else if(r==0) then 0
		else assert false
	end

	method minimizeLR p l r assLst = begin
		(*this is the simplest implementation*)
		(*(p,l,r)*)
		(*this one really minimize it*)
		let newr=self#minimizeR p l r assLst in
		let newl=self#minimizeL p l newr assLst in begin
			(newl,newr)
		end
	end
*)

	method getNonProtocolInputList allinputs  = begin
		assert(rstSigName<>"");
		(*non protocol inputs*)
		let is_non_protocol key = begin
			if(((List.mem key instrlist)==false) && ((string_equ key rstSigName)==false)) then begin
				true
			end
			else begin
				false
			end
		end
		in
		List.filter is_non_protocol allinputs
	end

	method dumpCNF cnfname_1inst= begin
		(*
			dump to sat *_1inst.cnf, for verification purpose,
			I will write another program to map the *_1inst.cnf back to verilog,
			such that it can be verified by formality
		*)
		(*Printf.printf "start to do 1 \n" ;*)
		begin
			print_endline "";
			print_endline  cnfname_1inst;
		
			let dumpout_cnf = open_out cnfname_1inst
			in
			self#print_cnf clause_list dumpout_cnf 0 1 0 0 
			;
			close_out dumpout_cnf
		end
	end

	method inferInitState  = begin
	  (*by default we use a 10 step unrolling and infer the final state value*)
		(*unroll for 10 steps*)
		self#set_unlock_multiple;
		let (clause_list_multiple_aux,last_index_aux) = self#gen_multiple_instance_step2 10
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*connecting them*)
		let clslst =(self#connect_multiple_instance_step3 0 9) in begin
			self#append_clause_list_multiple  clslst ;
		end
		;
    
		(*forcing the resetSignalName*)
    let lrlst=lr2list 0 9 in
		let resetSignalIndex= self#getResetSignalIndex in
		let cls=begin
			match rstValue with 
			1 -> ([resetSignalIndex],"") 
			|0 ->([-resetSignalIndex],"") 
			|_-> assert false
		end in
		let clslst=List.map (fun shiftidx -> shiftcls [] (shiftidx*final_index_oneinst) cls) lrlst in begin
			self#append_clause_list_multiple clslst;
		end
		;

		self#set_lock_multiple;


		let dff_idxpairlst = List.filter (isdff_name_index) name_index_lst in
    let dff_idxlst=List.map (fun x -> match x with (_,(idx,_))-> idx) dff_idxpairlst in
    let solverIdx = MultiMiniSAT.allocSolver () in 
  	let res=Dumpsat.dump_sat solverIdx clause_list_multiple in
		let dff_idx_ass_lst1=begin
			assert (res==SATISFIABLE);
			List.map (fun x -> Dumpsat.get_assignment solverIdx (x+9*final_index_oneinst)) dff_idxlst
		end in
		let dff_idx_ass_lst = List.map (fun x -> match x with (idx,v)-> (idx-9*final_index_oneinst,v)) dff_idx_ass_lst1 
		in begin
		  MultiMiniSAT.closeSolver solverIdx;
			let proc_prt idx_ass = begin
				match idx_ass with 
				(idx,true) -> begin
					printf " init %s(%d) = 1\n" (self#idx2name idx) idx
				end
				| (idx,false) -> begin
					printf " init %s(%d) = 0\n" (self#idx2name idx) idx
				end
			end in
			List.iter proc_prt dff_idx_ass_lst;
			dff_idx_ass_lst
		end
	end

	method parsingResetCondition resetCondition = begin
		printf "reset condition is %s\n" resetCondition;
		let regexpResetCondition=Str.regexp "\\([a-zA-Z0-9_]+\\)==1'b\\([01]\\)" in
		let resetSignalName=begin
			let res=Str.string_match regexpResetCondition resetCondition 0 in begin
				if(res==false) then begin
					dbg_print "FATAL : Invalid reset condition";
					exit 1;
				end;
			end;
			Str.replace_first regexpResetCondition "\\1" resetCondition 
		end 
		and resetValue     = begin
			(*try 
				List.assoc rstSigName name_index_lst
			with Not_found -> begin
			  printf "%s+++\n" rstSigName;
  			dbg_print "FATAL : invalid reset signal name";
				assert false
			end;*)
			let v=Str.replace_first regexpResetCondition "\\2" resetCondition  in begin
				match v with 
				"0" -> 0
				|"1" -> 1
				|_ -> assert false
			end
		end 
		in begin
			(*save it here such that rstSigName can be used in getNonProtocolInputList*)
 			rstSigName <- resetSignalName ;
 			rstValue   <- resetValue ;
		end;
	end


	method genIOandCNF instrlist1 outstrlist1 = begin
  	self#set_lock_oneinst;
  
  	(*****************************************)
  	(*setting the input and output vars*)
  	(*****************************************)
  	instrlist <- instrlist1 ;
  	outstrlist <- outstrlist1 ;
  	
		let getAllInputList = begin
			(*find out all input ports*)
			let ext_input key cont last_res = begin
				match cont#get_obj with
				Tobj_input_declaration(_) -> begin
					key::last_res
				end
				| _ -> last_res
			end
			in
			Hashtbl.fold ext_input circuit_hst []
		end in
  	let allinputs = getAllInputList in begin
  		non_proctocol_input_list <- self#getNonProtocolInputList 	allinputs;
  	end;
  	
  	(*++++++++++++++++*)
  	(*++++++++++++++++*)
  	(*encoding the transition relation's CNF*)
  	(*++++++++++++++++*)
  	(*++++++++++++++++*)
  	dbg_print "encode_oneInstance2SAT_step1" ;
  	let clslst_one_inst =self#encode_oneInstance2SAT_step1 in begin
  		self#set_unlock_oneinst;
  		(*set it into the clslst_one_inst*)
  		self#append_clause_list_oneinst clslst_one_inst ; 
  		(*record the final largest index*)
  		self#set_last_index_oneinst last_index;
  		self#set_lock_oneinst;
  	end ;
  
  	(*their var index*)
  	bv_instrlist <- List.concat (List.map self#name2idxlist instrlist) ;
  	bv_outstrlist <- List.concat (List.map self#name2idxlist outstrlist) ;
  	bv_non_proctocol_input_list <- List.concat (List.map self#name2idxlist non_proctocol_input_list) ;
  
  	(*****************************************)
  	(*write out the encoded CNF*)
  	(*****************************************)
  	(*let cnfname_1inst = String.concat "" [tempdirname ; "dumpout/inst1_" ; name ;".cnf"] in
  	self#dumpCNF cnfname_1inst ;*)
  
  	(*dont allow to change the clause_list_multiple *)
  	self#set_lock_multiple;
		
		(*print out the set of input, output npi and reset*)
		printf "\n+++++ start of non protocol input list +++\n";
		List.iter (printf " ^%s^ ") non_proctocol_input_list ;
		printf "\n+++++ start of protocol input list +++\n";
		List.iter (printf " ^%s^ ")  instrlist;
		printf "\n+++++ start of protocol output list +++\n";
		List.iter (printf " ^%s^ ")  outstrlist;
		printf "\n+++++reset signal ++++++++++++++\n";
		printf "%s\n" rstSigName;
		printf "%d\n" rstValue;
		flush stdout;
	end

	method compsyn  (instrlist1:string list) (outstrlist1:string list) (resetCondition:string) = begin
    (*parsing the reset condition*)
		self#parsingResetCondition resetCondition;
  	(*initalizing*)
		self#genIOandCNF instrlist1 outstrlist1;
  	(*set the current time to be used by dbg_print*)
  	set_current_time;
  
  	(*++++++++++++++++*)
  	(*++++++++++++++++*)
  	(*following is relational code*)
  	(*++++++++++++++++*)
  	(*++++++++++++++++*)
  	(*****************************************)
  	(*finding out init state*)
  	(*****************************************)
  	let dff_idx_ass_lst_InitState = self#inferInitState  in 
  	let proc_idx_ass2Literal idxass = begin
  		match idxass with
  		(idx,false) -> ([-idx],"init")
  		| (idx,true) -> ([idx],"init")
  		|_-> assert false
  	end 
		in begin
  		initStateClauseList <- List.map proc_idx_ass2Literal dff_idx_ass_lst_InitState ;
			printf "initial clause list\n";
			let proc_prt x = begin
				match x with 
				(intlist,_) -> begin
					List.iter (printf " %d ") intlist;printf "\n"
				end
			end 
			in begin
				List.iter proc_prt initStateClauseList ;
				flush stdout;
			end
		end;
		
  	(*****************************************)
  	(*major loop of inferring predicate*)
  	(*****************************************)
  	let (_,asslst) = self#inferPredicateUniq in
		let simass     = simplify_withBDD (invert_assertion (or_assertion asslst)) ddM in 
		let simass_inv = simplify_withBDD ( (or_assertion asslst)) ddM in begin
			printf "final assertion is \n";
			self#print_itpo simass;
			printf "\n";

			printf "final inverted assertion is \n";
			self#print_itpo simass_inv;
			printf "\n";

  		MultiMiniSAT.checkClosed ();

			

		end
	end

	method genDecoderFunction iv shift ov instCNF = begin
		let maxidxR=get_largest_varindex_inclslst instCNF in 
		let shiftedIV=List.map (fun x -> x+shift) iv in 
		let clslst_shift = begin
			List.iter (fun x -> assert(x<=maxidxR)) shiftedIV;
			List.iter (fun x -> assert(x<=maxidxR)) ov;
			shiftclslst instCNF ov maxidxR
		end 
		in 
		characterization_interp_AB_mass iv shift instCNF clslst_shift maxidxR ov
	end

	method bitnamelst2namerangelst bitlst = begin
		let spl x = begin
			let nm = self#idx2name x in 
			let spllst = split (regexp "\[\|\]") nm in begin 
				(*although this may leas to warning in compilation,
					but it is actually necessary to regexp*)
				match spllst with
				[] -> assert false;
				|[nmm] -> begin
					assert(nm = nmm);
					(nm,-1)
				end
				|[nmm;value] -> begin
					(nmm,(int_of_string value))
				end
				|_ -> assert false
			end
		end in
		let dividedNameRangelst = List.map spl bitlst in
		let rec genarray dnrlst res = begin
			match dnrlst with 
			[] -> res
			|dnr::dnrtl -> begin
				match dnr with
				(nm,-1) -> begin
					genarray dnrtl ((nm,[])::res)
				end
				|(nm,v) -> begin
					assert(v>=0);
					let (elst,nelst)= List.partition (fun x -> match x with (nm2,_) -> nm2= nm) res in begin
						match elst with
						[] -> begin
							genarray dnrtl ((nm,[v])::res)
						end
						|[(nm2,vl2)] -> begin
							assert (nm = nm2);
							genarray dnrtl ((nm,(v::vl2))::nelst)
						end
						|_ -> assert false
					end
				end
			end
		end in
		let nameidxlstlst = genarray dividedNameRangelst [] in
		List.map (fun x -> match x with (nm,[]) -> (nm,-1,-1) | (nm,vlst)-> let (l,r)= Intlist.list2lr vlst in (nm,l,r)) nameidxlstlst 
	end


	method getVisitedPosList  arr_itpo = begin
			let size = Array.length arr_itpo in
			let visitedPosArray = Array.make size false in
			let frontie=ref [] 
			in
			let rec interpObj2str interpObj = begin
				match interpObj with
				TiterpCircuit_true -> ()
				| TiterpCircuit_false -> ()
				| TiterpCircuit_refcls(clsidx) -> begin
					assert(clsidx<size);
					if((Array.get visitedPosArray clsidx)==false) then begin
						Array.set visitedPosArray clsidx true;
						frontie := clsidx :: (!frontie) ;
					end
				end
				| TiterpCircuit_refvar(varidx) -> ()
				| TiterpCircuit_and(interpObjlst) -> begin
					List.iter (interpObj2str ) interpObjlst
				end
				| TiterpCircuit_or(interpObjlst) -> begin
					List.iter (interpObj2str ) interpObjlst
				end
				| TiterpCircuit_not(interpObj) -> begin
					interpObj2str interpObj
				end
				| TiterpCircuit_printed(clsidx) -> assert false
				| _ -> assert false
			end
			in begin
				(*insert size-1 into the frontie*)
				Array.set visitedPosArray (size -1) true;
				frontie := [size-1] ;

				while ((isEmptyList (!frontie)) ==false) do
					let curF=List.hd (!frontie) in begin
						frontie := List.tl (!frontie);
						(*pop out the first element of frontie*)
						interpObj2str (Array.get arr_itpo curF);
					end
				done;

				let arrayIX= (Array.mapi (fun i x  ->  (i,x)) visitedPosArray) in
				let listIX=Array.to_list arrayIX in
				List.map fst (List.filter snd listIX )
			end
	end


	method generateDecoderVerilog prefix left right idx2decfunList = begin
		let decoderVerilog = open_out "resulting_dual_cnf.v" 
		and bvo = self#bitnamelst2namerangelst bv_outstrlist 
		and bvi = self#bitnamelst2namerangelst bv_instrlist 
		in begin
			fprintf decoderVerilog  "module resulting_dual(\n";

			(*generating input specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
			end in
			List.iter prtbit bvo;

			(*generating output specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
			end in
			List.iter prtbit bvi;

			fprintf decoderVerilog  "  clk);\n";


			fprintf decoderVerilog  "input  clk;\n";

			(*generating input specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "input  %s;\n" nm;
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "input [%d:%d]  %s;\n" l r nm;
				end
			end in
			List.iter prtbit bvo;

			(*generating output specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "output  %s;\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "output [%d:%d]  %s;\n" l r nm
				end
			end in
			List.iter prtbit bvi;

			(*all the decoder's input's wire definition*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "wire   cycle%d_%s ;\n" (prefix+left+right) nm;
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "wire  [%d:%d]  cycle%d_%s ;\n" l r (prefix+left+right) nm ;
				end
			end in
			List.iter prtbit bvo;

      (*all the wire declaration for each itpo*)
			let findVisited  idx2decfun = begin
				(*find out the visited pos in decfun*)
				match idx2decfun with
				(idx,decfun) -> begin
					let visitedPosList=self#getVisitedPosList decfun in
					(idx,decfun, visitedPosList)
				end
			end
			in
			let idx2decfun2VisitedList=List.map findVisited idx2decfunList in
			let prtWire idx2decfun = begin
				match idx2decfun with
				(idx,decfun,visitedPos) -> 
					List.iter (fun x -> fprintf decoderVerilog "wire w_%d_%d ;\n" idx x) visitedPos
			end
			in begin
				List.iter prtWire idx2decfun2VisitedList;
			end;


			(*generaing the pipelined registers*)
			if(prefix<=(prefix+left+right-1)) then begin
  			let lrlst = lr2list prefix (prefix+left+right-1) in begin
  				let prtbit frm x = begin
  					match x with 
  					(nm,-1,r) -> begin
  						assert (r =(-1));
  						fprintf decoderVerilog "reg  cycle%d_%s;\n" frm nm
  					end
  					| (nm,l,r) -> begin
  						assert(l!=(-1));
  						assert(r!=(-1));
  						fprintf decoderVerilog "reg [%d:%d]  cycle%d_%s;\n" l r frm nm
  					end
  				end in
  				List.iter (fun frm -> (List.iter (prtbit frm) bvo) ) lrlst
  			end
  			;
  			let lrlst = lr2list prefix (prefix+left+right-1) in begin
  				let prtbit frm x = begin
  					match x with
  					(nm,-1,r) -> begin
  						assert (r =(-1));
  						fprintf decoderVerilog "always @(posedge clk) begin\n";
  						fprintf decoderVerilog "  cycle%d_%s <= cycle%d_%s;\n" frm nm (frm+1) nm;
  						fprintf decoderVerilog "end\n\n";
  					end
  					| (nm,l,r) -> begin
						  assert(l>=r);
  						fprintf decoderVerilog "always @(posedge clk) begin\n";
							for i = r to l do
  						  fprintf decoderVerilog "  cycle%d_%s[%d] <= cycle%d_%s[%d];\n" frm nm i (frm+1) nm i;
							done;
  						fprintf decoderVerilog "end\n\n";
  					end
  				end in
  				List.iter (fun frm -> (List.iter (prtbit frm) bvo) ) lrlst
  			end
  			;
			end
			;

      (*all the decoder's input's assignment to the last cycles*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "assign   cycle%d_%s =%s;\n" (prefix+left+right) nm nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					assert(l>=r);

					for i = r to l do
				  	fprintf decoderVerilog "assign  cycle%d_%s[%d] =%s[%d];\n"  (prefix+left+right) nm i nm i
					done;
				end
			end in
			List.iter prtbit bvo;

			let findVisited  idx2decfun = begin
				(*find out the visited pos in decfun*)
				match idx2decfun with
				(idx,decfun) -> begin
					let visitedPosList=self#getVisitedPosList decfun in
					(idx,decfun, visitedPosList)
				end
			end
			in
			let idx2decfun2VisitedList=List.map findVisited idx2decfunList in
			let prtFunction idx2decfun = begin
				match idx2decfun with
				(idx,decfun,visitedPos) -> begin
					fprintf decoderVerilog "assign %s = w_%d_%d ;\n" (self#idx2name idx) idx ((Array.length decfun)-1);
					List.iter (fun i -> self#print_itpo_verilog_file decoderVerilog (Array.get decfun i) idx i) visitedPos
				end
			end 
			in begin
				List.iter prtFunction idx2decfun2VisitedList;
			end;

			fprintf decoderVerilog  "endmodule\n\n";

			close_out decoderVerilog;
		end
	end

	method inferPredicateUniq  = begin
	  (**********************)
		(* increacing bound*)
	  (**********************)
		let bnd= ref 1
		and stop = ref false 
		and inferedAssertionList = ref [] in begin
  		while ((!stop)==false) do
				bnd := (!bnd) +1 ;
				printf "bnd %d\n" (!bnd);
				printf "inferedAssertionList len %d\n" (List.length (!inferedAssertionList));
        let (resNonloop,targetNonloop)=self#checkNonloop 
																					(!bnd) 
																					(!bnd) 
																					(!bnd) 
																					(!inferedAssertionList) 
				in begin
					match resNonloop with
					UNSATISFIABLE  -> begin
						printf "checkNonloop OK\n";
						stop := true;
					end
					| _ -> begin
						assert(resNonloop==SATISFIABLE);
						(*continue to loop case*)
						let (resLoop,newInferedAssertion) = self#checkLoop 
						                                          (!bnd) 
																											(!bnd) 
																											(!bnd) 
																											targetNonloop
																											(!inferedAssertionList)
						in begin
							assert(resLoop==UNSATISFIABLE);
							(*printf "new assertion\n";
							List.iter (fun itpo ->  self#print_itpo itpo; printf "\n") newInferedAssertion;*)
							dbg_print "exiting checkLoop";
							inferedAssertionList := newInferedAssertion @ (!inferedAssertionList);
						end
					end
				end
	  	done;
			((!bnd),(!inferedAssertionList))
		end
	end

	method checkNonloop p l r inferedAssertionList = begin
		dbg_print "checkNonloop";
		let target = self#construct_nonloop
										p 
										l 
										r 
		and (largestIdx,clslst_invass)=self#gen_invassertion p l r inferedAssertionList
		in 
		let res=Dumpsat.dump_sat_withclear (clslst_invass@(([target],"target")::clause_list_multiple)) in
		(res,target)
	end

	method checkLoop p l r targetNonloop inferedAssertionList = begin
		printf "p %d l %d r %d final_index_oneinst %d\n" p l r final_index_oneinst;
		printf "bi len %d npi leng %d\n" (List.length bv_instrlist) (List.length bv_non_proctocol_input_list);
		dbg_print "checkLoop";
		let targetLoop=self#construct_loop p l r  targetNonloop  
		and (largestIdx_invass,clslst_invass)=self#gen_invassertion p l r inferedAssertionList in
    let iv_0 = self#shiftCycleList (p+l) (bv_instrlist@bv_non_proctocol_input_list) in
    let (res,itpolst)=allsat_interp_BDD_loop_symmatry 
												clause_list_multiple 
												targetLoop 
												iv_0
												clslst_invass
												largestIdx_invass
												(self#construct_varlst2assumption p l r ) 
												ddM 
												true
		in begin
			(*we need to map res back to base frame*)
			List.iter (fun itpo -> check_itpo_var_membership itpo iv_0) itpolst;
			let itpolst_map=List.map (fun x -> shiftAssertion x (-((p+l)*final_index_oneinst)) ) itpolst in
			(res,itpolst_map)
		end
	end

	method construct_loop (p:int) (l:int) (r:int) target  = begin
		(*this one assume all > 0*)
		assert(p>=0);
		assert(l>=0);
		assert(r>=0);
		self#set_unlock_multiple ;
		let target_loop_p = self#double_loop p l r 0 p
		and target_loop_l = self#double_loop p l r p (p+l)
		and target_loop_r = self#double_loop p l r (p+l+1) (p+l+1+r-1)
		in
		let target_all = self#alloc_index 1
		in
		let cls_red_and_all = self#encode_Red_AND target_all [target;target_loop_p;target_loop_l;target_loop_r]
		in begin
			assert (target_loop_p!= target_loop_l);
			assert (target_loop_p!= target_loop_r);
			assert (target_loop_l!= target_loop_r);
			self#append_clause_list_multiple cls_red_and_all ;

			(*further enforcing the init state*)
			assert((isEmptyList initStateClauseList)==false);
			let shiftedClauseList=List.map (shiftcls [] ((p+l+1+r)*final_index_oneinst)) initStateClauseList  in begin
				self#append_clause_list_multiple  initStateClauseList;
				self#append_clause_list_multiple  shiftedClauseList;
			end;

			self#set_lock_multiple ;
			target_all
		end
	end


	method construct_nonloop_1copy (p:int) (l:int) (r:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop = begin
		(*this one allow l<0 but must > -r+1*)
		Printf.printf "construct_nonloop_1copy p %d l %d r %d\n" p l r;
		flush stdout;
		assert(p>=0);
		assert(l >= -r);
		assert(r>=0);
		self#set_unlock_multiple;
		
		self#set_clause_list_multiple [];
		self#set_last_index final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		l instance for left expansion
		1 instance for current input 
		r instance for right expansion
		*2 for another expansion
		*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 (p + (max l 0) + 1 + r ))
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*constrain the assertion wire*)
		(*2014Dec03 Shen we will not use assertion any more*)
		(*if (List.length (List.filter (self#is_assertion) name_index_lst)) > 0 then
			self#append_clause_list_multiple (self#try_assertion 0 (p+(max l 0 )+1+r-1))
		else begin
			printf "             warning : not found assertion_shengyushen\n";
			flush stdout;
		end
		;*)
		
		(*connect the first p+1+r instance*)
		let clslst =(self#connect_multiple_instance_step3 0 (p+(max l 0 )+r)) in begin
			self#append_clause_list_multiple  clslst ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)
		
		(*TODO : shift the assertion to proper cycle*)
		let ass_nonloop = List.map 
			(fun x -> shiftAssertion x ((p+(max l 0 ))*final_index_oneinst)) 
			infered_assertion_array_lst_old_nonloop 
		and ass_loop   = List.map 
			(fun x -> shiftAssertion x ((p+(max l 0))*final_index_oneinst)) 
			infered_assertion_array_lst_old_loop   
		in begin
			(*force the infered_assertion_array_lst_old to be invalid*)
			if((List.length ass_nonloop)!=0) then begin
				(*let orass_sim = List.map (fun x -> simplify_withBDD x ddM) ass_nonloop*)
				(*2014/11/16 Shen dont simply it here to speedup*)
				let orass_sim =  ass_nonloop
				in
				self#force_assertion (or_assertion orass_sim);
			end
			;
			List.iter (fun x -> self#force_assertion (invert_assertion x)) ass_loop;
		end
	end

	method gen_invassertion p l r inferedAssertionList = begin
		let currentMaxIdx= ref last_index 
		and currentClsList = ref [] 
		and ass1 = List.map (fun x -> shiftAssertion x ((p+l)*final_index_oneinst        )) inferedAssertionList 
		and ass2 = List.map (fun x -> shiftAssertion x ((p+l+p+l+1+r)*final_index_oneinst)) inferedAssertionList in
		let force_assertion_alone arr_itpo1= begin
			let (topidx,last_index_new,clslst_2beappend)= encode_assertion arr_itpo1 (!currentMaxIdx)
			in begin(*this is the function enabler*)
				assert (topidx<= last_index_new);
				currentMaxIdx := last_index_new;
				currentClsList :=  (([topidx],"f i")::clslst_2beappend)@(!currentClsList);
				check_clslst_maxidx (!currentClsList) (!currentMaxIdx);
				()
			end
		end 
		in begin
			List.iter (fun x -> force_assertion_alone (invert_assertion x)) (ass1@ass2);
			((!currentMaxIdx),(!currentClsList))
		end
	end

	(*notice that we only 
		unroll the R, 
		force the nonreset condition
		input non-equ
		output equ
		npi all equ
	*)
	method construct_nonloop 
						(p:int) 
						(l:int) 
						(r:int) 
	= begin
		(*this one allow l<0 but must > -r+1*)
		assert(p>=0);
		(*Printf.printf "l %d r %d\n" l r; 
		flush stdout;*)
		assert(l >= -r);
		assert(r>=0);
		self#set_unlock_multiple;
		
		self#set_clause_list_multiple [];
		self#set_last_index final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		l instance for left expansion
		1 instance for current input 
		r instance for right expansion
		*2 for another expansion
		*)
		let (clslst_aux,last_index_aux) = self#gen_multiple_instance_step2 ((p+l+1+r)*2)
		in begin
			self#set_clause_list_multiple clslst_aux;
			self#set_last_index last_index_aux;
		end
		;
		
    (*enforcing the non reset consition*)
		let clause_list_multiple_aux = (self#gen_nonreset ((p+l+1+r)*2))
		in begin
			self#append_clause_list_multiple  clause_list_multiple_aux ;
		end
		;

		(*connect the first p+1+r instance*)
		let clslst =self#connect_multiple_instance_step3 0 (p+l+1+r-1) in begin
			self#append_clause_list_multiple  clslst ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)
		
		(*connect the secnod p+1+r instance*)
		let clslst2=self#connect_multiple_instance_step3 (p+l+1+r) ((p+l+1+r)*2-1) 
		in begin
			self#append_clause_list_multiple  clslst2 ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)

		(*we again have the input constrain nonequal back*)
    let ov_0 = self#shiftCycleList (p+l) bv_instrlist
    and ov_b = self#shiftCycleList (p+l+1+r+p+l) bv_instrlist in begin
	    self#append_clause_list_multiple  (self#encode_INEV (ov_0) (ov_b))
		end
		;

   (*force the npi to be the same*)
    let npi_lst=bv_non_proctocol_input_list
    and npi_cycle_lst = lr2list 1 ((p+l+1+r)*2-1)
    in
    let proc_npi_cycle i = begin
      let npi_lst_i = self#shiftCycleList i npi_lst
      in
      self#append_clause_list_multiple (self#encode_EQUV (npi_lst) (npi_lst_i))
    end
    in
    List.iter proc_npi_cycle npi_cycle_lst
    ;

		(*force the output of p to p+l+1+r-1 to be the same*)
		(*here l can be negative, while above l must be larger than 0*)
		let ov = bv_outstrlist
		and outputframe_idx = lr2list p (p+l+1+r-1)
		in
		let ov_b_1 = List.concat (List.map (fun frm ->  self#shiftCycleList frm ov ) outputframe_idx)
		in
		let ov_b_2 = self#shiftCycleList (p+l+1+r) ov_b_1
		in
		let (target,oclslist)= self#encode_EQUV_res ov_b_1 ov_b_2 
		in begin
			self#append_clause_list_multiple oclslist ;
			self#set_lock_multiple;
			target
		end
	end

	method double_loop (p:int) (l:int) (r:int) starti endi = begin
		let dff_idxpairlst = List.filter (isdff_name_index) name_index_lst
		in
		let dff_curlst = List.map (fun x -> match x with (_,(y,_)) -> y) dff_idxpairlst
		in begin
			let lilst = lr2list starti (endi-1)
			in
			let proc_liequ li = begin
				let ov_li  = self#shiftCycleList li dff_curlst
				and rilst = lr2list (li+1) endi
				in
				let proc_riequ ri = begin
					let ov_ri  = self#shiftCycleList ri dff_curlst
					in
					let ov_pair_lst = List.combine ov_li ov_ri
					in
					let (res_lst,cls_lstlst) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst)
					in
					let ov_pair_lst_shift = List.map (fun x -> match x with (v1,v2) -> (self#shiftCycleIndex (p+l+1+r) v1,self#shiftCycleIndex (p+l+1+r) v2)) ov_pair_lst
					in
					let (res_lst_shift,cls_lstlst_shift) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst_shift)
					and rii = self#alloc_index 1
					in begin
						(*List.iter (fun clslst -> printf "clslst : \n"; List.iter (fun cls -> printf "cls \n"; List.iter (fun idx -> printf " %d " idx) (fst cls); printf "\n") clslst) cls_lstlst_shift;
						printf "last_index %d\n" last_index;
						printf "p %d l %d r %d final_index_oneinst %d" p l r final_index_oneinst;
						flush stdout;*)
						check_clslst_maxidx (List.concat cls_lstlst_shift) last_index;
						self#append_clause_list_multiple ((List.concat cls_lstlst) @ (List.concat cls_lstlst_shift) @ (self#encode_Red_AND rii (res_lst @ res_lst_shift))) ;
						check_clslst_maxidx clause_list_multiple last_index;
						rii
					end
				end
				in
				List.map (proc_riequ) rilst
			end
			in 
			let li_equ_var_lst = List.concat (List.map (proc_liequ) lilst)
			and riii = self#alloc_index 1
			in begin
				self#append_clause_list_multiple (self#encode_Red_OR riii li_equ_var_lst);
				check_clslst_maxidx clause_list_multiple last_index;
				riii
			end
		end
	end

	method construct_varlst2assumption (p:int) (l:int) (r:int)  = begin
		(*let ov = bv_instrlist@bv_non_proctocol_input_list*)
		(*2014 Dec 06 Shen we dont need to constrain bv_non_proctocol_input_list
		becasue it is always the same across all steps, 
		and we already use it as important vars on step p+l*)
		let ov = bv_instrlist
		and cycle_list = lr2list 0 (((p+l+1+r)*2)-1) in
		let cycle_list_filtered = List.filter (fun x -> (x!=(p+l) )) cycle_list in
		let input_cycle_i i = self#shiftCycleList i ov in
		List.concat ( List.map input_cycle_i  cycle_list_filtered) 
	end

	method force_assertion arr_itpo1= begin
		let (topidx,last_index_new,clslst_2beappend)= encode_assertion arr_itpo1 last_index
		in begin(*this is the function enabler*)
			assert (topidx<= last_index_new);
			(*printf "force_assertion last_index %d last_index_new %d\n" last_index last_index_new;*)
			self#set_last_index last_index_new;
			self#append_clause_list_multiple (([topidx],"f i")::clslst_2beappend);
			check_clslst_maxidx clause_list_multiple last_index;
			()
		end
	end

	(*src_i<dst_i*)
	method connect_dffpair src_i dst_i dffpair = begin
	   if (src_i>= dst_i) then begin
		Printf.printf "connect_dffpair src_i %d must smaller than dst_i %d\n" src_i dst_i;
		exit 1
	   end
	   else begin
		match dffpair with
		(nm,(current_idx,next_index)) -> begin
			(*make sure it is actually dff*)
			(*if self#isdff nm then begin*)
				let current_off = dst_i*final_index_oneinst
				and next_off   = src_i*final_index_oneinst
				in
				let new_current_idx = current_off+current_idx
				and new_next_index = next_off+next_index
				in 
				let (rli,rlr)= rng2lr (self#name2range nm)
				in
				let (rli_real_cur,rlr_real_cur)= rng2lr (construct_range_onidx new_current_idx rli rlr)
				and (rli_real_nxt,rlr_real_nxt)= rng2lr (construct_range_onidx new_next_index rli rlr)
				in begin
					if (rli_real_cur == new_current_idx) && (new_current_idx-new_next_index == final_index_oneinst*(dst_i-src_i)-(abs(rlr-rli)+1)) && (rli_real_cur-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1== rli_real_nxt) then begin
						(*encode every bit in this range*)
						let rec connect_1bitdff idxi idxr = begin
							if idxi>idxr then []
							else begin
								let oldcl = connect_1bitdff (idxi+1) idxr
								and newmapped = (self#encode_EQU idxi (idxi-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1))
								in
								let newmapped_commented = List.map (setcomment (sprintf "connecting dff %s from instance %d to %d" nm src_i dst_i)) newmapped 
								in
								newmapped_commented @ oldcl
							end
						end
						in
						connect_1bitdff rli_real_cur rlr_real_cur
					end
					else begin
						Printf.printf "fatal error : improper connect_dffpair\n";
						Printf.printf "rli_real_cur %d\n" rli_real_cur;
						Printf.printf "rlr_real_cur %d\n" rlr_real_cur;
						Printf.printf "new_current_idx %d\n" new_current_idx;
						Printf.printf "new_next_index %d\n" new_next_index;
						Printf.printf "rlr %d\n" rlr;
						Printf.printf "rli %d\n" rli;
						Printf.printf "final_index_oneinst %d\n" final_index_oneinst;
						Printf.printf "rli_real_nxt %d\n" rli_real_nxt;
						Printf.printf "rlr_real_nxt %d\n" rlr_real_nxt;
						exit 1
					end
				end
			(*end
			else begin
				Printf.printf "fatal error : it should be dff\n";
				exit 1
			end*)
		end
	   end
	end


	(*to connect next state of one instance to current state of last instance*)
	method connect_multiple_instance_step3 start_bound end_bound = begin
		let dff_idxpair = List.filter (isdff_name_index) name_index_lst
		in 
		let connect_inst i = begin
			assert (i < end_bound);
			let connect_current_instance = List.map (self#connect_dffpair i (i+1)) dff_idxpair in
			List.concat connect_current_instance
		end
		in begin
			assert(end_bound>start_bound);
			let lstConnect = lr2list start_bound (end_bound-1) in 
			let clslstList = List.map connect_inst lstConnect in
			List.concat clslstList
		end
	end


	method encode_instance ii = begin
		let off = ii*final_index_oneinst
		in 
		let cls_off offf cls = begin
			let lit_off offff lit = begin
				if lit > 0 then lit+offff
				else lit -offff
			end
			in
			(List.map (lit_off offf) (fst cls)),(snd cls)
			(* avoiding adding comment to save time *)
			(*appendcomment (cat_string "instance " (string_of_int ii)) ((List.map (lit_off offf) (fst cls)),(snd cls)) *)
		end
		in
		List.map (cls_off off) clause_list
	end

	(*generate multiple instance, which bound is the number*)
	method gen_multiple_instance_step2 num = begin
		let lrlst = lr2list 0 (num-1)
		in
		let clslst_lst = List.map (self#encode_instance) lrlst
		in
		((List.concat clslst_lst),(final_index_oneinst*num))
	end

	method encode_instance_nonreset ii = begin
		let clause_nonrst = begin
			let rstIdx=self#getResetSignalIndex in begin 
				match rstValue with
				0 -> ([rstIdx],"")
				| 1 -> ([-rstIdx],"")
				|_ -> assert false
			end
		end in
		let off = ii*final_index_oneinst
		in 
		let cls_off offf cls = begin
			let lit_off offff lit = begin
				if lit > 0 then lit+offff
				else lit -offff
			end
			in
			(List.map (lit_off offf) (fst cls)),(snd cls)
		end
		in
		cls_off off clause_nonrst
	end

	method gen_nonreset num = begin
		let lrlst = lr2list 0 (num-1)
		in
		List.map (self#encode_instance_nonreset) lrlst
	end

	(* encoding the transition relation*)
	method encode_oneInstance2SAT_step1  = begin
		(*index for explictly named vars, such as input output wire reg dff*)
		self#encode2SAT_explictname;
		(*this is the true encode*)

		(*Printf.printf "start to do 1 encode2SAT_explictname \n" ;*)


		(*encode the seq_always_list*)
		let seq_clslst = self#encode2SAT_seq_always_list truepred
		and comb_clslst = self#encode2SAT_comb_always_list truepred
		and cont_clslst = self#encode2SAT_contass_list
		in
		seq_clslst@comb_clslst@cont_clslst
	end
	
	method encode2SAT_contass_list = begin
		(*Printf.printf "start to do 1 encode2SAT_contass_list \n" ;*)
		List.concat (List.map (self#encode_ass) cont_ass_list)
	end
	
	method encode_ass ass = begin
		match ass with
		T_assignment(lv,exp) -> begin
			let truepred =1
			in 
			self#encode_nba_incomb (T_non_blocking_assignment_direct(lv,exp)) truepred
		end
	end
	
	method encode2SAT_comb_always_list envpred = begin
		(*Printf.printf "start to do 1 encode2SAT_comb_always_list \n" ;*)
		let encode_comb_always comb_always = begin
			match comb_always with
			(stat,_) -> self#encode_statement_incomb envpred stat   
		end
		in
		List.concat (List.map encode_comb_always comb_always_list)
	end
	
	method encode_statement_incomb envpred stat = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_incomb dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_incomb nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predclslst)= self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex ,(self#encode_Red_AND oldindex [envpred;expidx] ))
				end
				in
				newpred_clslst @ (self#encode_statement_incomb newpred stat_sub  ) @ predclslst
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predclslst)= self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in 
				let thenpredclslist = self#encode_Red_AND thenpred [envpred;expidx1] 
				and elsepredclslist = self#encode_Red_AND elsepred [envpred;expidx2] 
				in 
				predclslst @ thenpredclslist @ elsepredclslist @ (self#encode_statement_incomb thenpred stat1) @ (self#encode_statement_incomb elsepred stat2 )
			end
		end
		| T_case_statement(exp,cilst) -> begin
			let rec case2ifelse cl = begin
				match cl with
				[] -> begin
					Printf.printf "fatal error : you should not reach [] in case statement\n";
					exit 1
				end
				| [T_case_item_normal(explst,st1);T_case_item_default(stlast)] -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,stlast)
				end
				| (T_case_item_normal(explst,st1))::tl -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,(case2ifelse tl))
				end
				| _ -> begin
					Printf.printf "fatal error : you should not reach here in case statement\n";
					exit 1
				end
			end
			in
			self#encode_statement_incomb envpred (case2ifelse cilst)
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_incomb envpred) statlst  )
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	
	method encode2SAT_seq_always_list envpred = begin
		(*Printf.printf "start to do 1 encode2SAT_seq_always_list \n" ;*)
		let encode_seq_always seq_always = begin
			match seq_always with
			(stat,_) -> self#encode_statement_inseq envpred stat   
		end
		in
		List.concat (List.map encode_seq_always seq_always_list)
	end
	
	method encode_nba_incomb nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_incomb only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)= self#encode_exp exp
			and lvidx_lst = self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_incomb lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen = min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common = Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common = Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst = List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method encode_statement_inseq envpred stat  = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_inseq nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predcl)= self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex,(self#encode_Red_AND oldindex [envpred;expidx]))
				end
				in 
				predcl @ newpred_clslst @ (self#encode_statement_inseq newpred stat_sub)
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predcl)= self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in begin
					let thenpredclslist = self#encode_Red_AND thenpred [envpred;expidx1] 
					and elsepredclslist = self#encode_Red_AND elsepred [envpred;expidx2] 
					in 
					predcl @ (thenpredclslist @ elsepredclslist) @ (self#encode_statement_inseq thenpred stat1) @ (self#encode_statement_inseq elsepred stat2 )
				end
			end
		end
		| T_case_statement(exp,cilst) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_case_statement\n";
			exit 1
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_inseq envpred) statlst)
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	(*return positive , negative index and clause list*)
	method encode_pred exp = begin
		let (idxlst,cl)= self#encode_exp exp
		in 
		let idx = begin
			match idxlst with
			[pred] -> pred
			| _ -> begin
				Printf.printf "fatal error : invalid length of encode_pred\n";
				exit 1
			end
		end
		in 
		(*negative relationship*)
		let oldindex = self#alloc_index 1
		in
		(idx,oldindex,(self#encode_NEQ idx oldindex)@cl)
	end
	(*return the list of exp bit and list of clause*)
	method encode_prim prim = begin
		match prim with
		T_primary_num(num) -> self#encode_number num 
		| T_primary_id([name]) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1  (*even for a dff, prim will always use current state*)
			end
			and rng = self#name2range name
			in 
			((rng_baseidx_2_idxlist rng baseidx),[])
		end
		| T_primary_id([]) -> begin
			Printf.printf "fatal error : not supported T_primary_id with zero string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_id(idlst) -> begin
			Printf.printf "fatal error : not supported T_primary_id with multiple string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1
			end
			and rng = self#name2range name
			and off = exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)= rng2lr rng
					in 
					([offset2idx left right baseidx off],[])
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_primary_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1
			end
			and rng = self#name2range name
			and li = exp2int_simple expl
			and ri = exp2int_simple expr
			in
			let idxlst = lr2list li ri
			and (left,right)= rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					((List.map (fun x -> offset2idx left right baseidx x) idxlst),[])
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| T_primary_minmaxexp(T_mintypmax_expression_1(exp)) -> self#encode_exp exp
		| T_primary_concat(explst) -> begin
			let (resv,rescls) = List.split (List.map (self#encode_exp) explst)
			in
			((List.concat resv),(List.concat rescls))
		end
		| _ -> begin
			Printf.printf "fatal error : not supported encode_prim\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
	end
	(*return the list of exp bit and list of clause*)
	method encode_number num = begin
		match num with
		T_number_unsign(i) -> begin
			let strlst =(List.rev (int2bin i))
			in begin
				let rec proc_intlst slst = begin
					match slst with
					[] -> []
					| hd::tl -> begin
						match hd with
						"0" -> falsepred::(proc_intlst tl)
						| "1" -> truepred::(proc_intlst tl)
						| _ -> begin
							Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
							exit 1
						end
					end
				end 
				in
				((proc_intlst strlst),[])
			end
		end
		| T_number_base(len,base,str) -> begin
			if base =='b' || base =='B' then begin
				if String.length str == len then begin
					let numlst = Misc.string2charlist str 
					in begin
						let rec proc_numlst nl = begin
							match nl with
							[] -> []
							| hd::tl -> begin
								match hd with
								'0' -> 	falsepred::(proc_numlst tl)
								| '1' -> truepred::(proc_numlst tl)
								| _ -> begin
									Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
									exit 1
								end
							end
						end
						in
						((proc_numlst numlst),[])
					end
				end
				else begin
					Printf.printf "fatal error : encode_prim length is not matched\n";
					exit 1
				end
			end
			else begin
				Printf.printf "fatal error : not supported base other than b or B in encode_prim\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : T_number_float is not supported\n";
			exit 1
		end
	end
	
	(*return the list of exp bit and list of clause*)
	method encode_exp exp = begin
		match exp with
		T_primary(prim) -> self#encode_prim prim
		| T_primary_4arrayassign(_) -> begin
			Printf.printf "fatal error : not supported T_primary_4arrayassign\n";
			exit 1
		end
		| T_add1(prim) -> self#encode_prim prim
		| T_sub1(prim) -> begin
			Printf.printf "fatal error : not supported T_sub1\n";
			exit 1
		end
		| T_logicneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in begin
				match bitlst with
				[idx] -> begin
					let oldindex = self#alloc_index 1
					in 
					([oldindex],(self#encode_NEG_ASSIGN oldindex idx )@clst)
				end
				| _ -> begin
					Printf.printf "fatal error : invalid length in T_logicneg\n";
					exit 1
				end
			end
		end
		| T_bitneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in
			let rec proc_bitlst bl = begin
				match bl with
				[] -> ([],[])
				| hd::tl -> begin
					let oldindex = self#alloc_index 1
					and (oldblst,oldclst)=(proc_bitlst tl)
					in 
					((oldindex::oldblst),(self#encode_NEG_ASSIGN oldindex hd)@oldclst)
				end
			end
			in
			let (bl,cl)= proc_bitlst bitlst
			in
			(bl,cl@clst)
		end
		| T_reduce_and(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_AND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nand(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NAND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_or(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_OR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nor(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NOR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_xor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xor\n";
			exit 1
		end
		| T_reduce_xnor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xnor\n";
			exit 1
		end
		| T_add2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let (addblst,addclst)=(self#encode_ADD vec1 vec2)
					in
					(addblst,(clslst1 @ clslst2 @ addclst))
				end
				else begin
					Printf.printf "fatal error : T_add2 length should be of the same\n";
					exit 1
				end
			end
		end
		| T_sub2(_,_) -> begin
			Printf.printf "fatal error : not supported T_sub2\n";
			exit 1
		end
		| T_mul2(_,_) -> begin
			Printf.printf "fatal error : not supported T_mul2\n";
			exit 1
		end
		| T_div(_,_) -> begin
			Printf.printf "fatal error : not supported T_div\n";
			exit 1
		end
		| T_mod(_,_) -> begin
			Printf.printf "fatal error : not supported T_mod\n";
			exit 1
		end
		| T_logic_equ(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_equ_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex = self#alloc_index 1
							in 
							let (bl,cl)=(proc_equ_formular (List.tl plist))
							in
							((oldindex::bl), (self#encode_EQU_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)= proc_equ_formular pl
						and oldindex = self#alloc_index 1
						in 
						([oldindex], clslst1 @ clslst2 @ resclslst @ (self#encode_Red_AND oldindex reslst ) );
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_logic_ine(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_ine_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex = self#alloc_index 1
							in 
							let (bl,cl)=(proc_ine_formular (List.tl plist))
							in
							((oldindex::bl),(self#encode_INE_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)= proc_ine_formular pl
						in
						let oldindex = self#alloc_index 1
						in 
						([oldindex] , clslst1 @ clslst2 @ resclslst @ (self#encode_Red_OR oldindex reslst ))
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_case_equ(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_equ\n";
			exit 1
		end
		| T_case_ine(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_ine\n";
			exit 1
		end
		| T_logic_and2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_AND oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_logic_or2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_OR oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_lt(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_lt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_lt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_lt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_lt case001 %d" oldindex))
									and case01=([b1;-b2;oldindex],(sprintf "T_lt case01 %d" oldindex))
									and case10=([-b1;b2;-oldindex],(sprintf "T_lt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_lt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_lt case111 %d" oldindex))
									in 
									( oldindex , [case000;case001;case01;case10;case110;case111] @ oldclslst)
								end
							end
						end
					end
					in 
					let (b,cl)= proc_lt_formular pl
					in
					([b],cl@clslst1@clslst2)
				end
				else begin
					Printf.printf "fatal error : T_lt length must be equ\n";
					exit 1
				end
			end
		end
		| T_le(exp1,exp2) -> begin
			let newexp = T_logic_or2(T_lt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_gt(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_gt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_gt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_gt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_gt case001 %d" oldindex))
									and case01=([b1;-b2;-oldindex],(sprintf "T_gt case01 %d" oldindex))
									and case10=([-b1;b2;oldindex],(sprintf "T_gt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_gt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_gt case111 %d" oldindex))
									in 
									(oldindex, [case000;case001;case01;case10;case110;case111]@oldclslst )
								end
							end
						end
					end
					in 
					let (b,cl)= proc_gt_formular pl
					in
					([b],cl @ clslst1 @ clslst2 )
				end
				else begin
					Printf.printf "fatal error : T_gt length must be equ\n";
					exit 1
				end
			end
		end
		| T_ge(exp1,exp2) -> begin
			let newexp = T_logic_or2(T_gt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_bit_and2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_and2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_and2 tl
							in 
							let andres = self#encode_AND2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_and2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_and2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_or2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_or2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_or2 tl
							in 
							let andres = self#encode_OR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_or2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_or2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_xor2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_xor2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_xor2 tl
							in 
							let andres = self#encode_XOR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_xor2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_xor2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_equ(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_equ2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_equ2 tl
							in 
							let andres = self#encode_EQU_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_equ2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_equ length must be equ\n";
					exit 1
				end
			end
		end
		| T_leftshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_leftshift\n";
			exit 1
		end
		| T_rightshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_rightshift\n";
			exit 1
		end
		| T_selection(predexp,exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			and (predv,clslstpred)= self#encode_exp predexp
			in begin
				if ((List.length vec1) == (List.length vec2) && (List.length predv)==1) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_sel pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_sel tl
							in 
							let equres = self#encode_SEL_res oldindex b1 b2 (List.hd predv) 
							in 
							((oldindex::lastres),(equres @ cl))
						end
					end
					in 
					let (bl,cl)= proc_sel pl
					in
					(bl,cl @ clslst1 @ clslst2 @ clslstpred)
				end
				else begin
					Printf.printf "fatal error : T_selection length must be equ and predv must be 1\n";
					exit 1
				end
			end
		end
		| T_string(_) -> begin
			Printf.printf "fatal error : not supported T_string\n";
			exit 1
		end
		| T_expression_NOSPEC(_) -> begin
			Printf.printf "fatal error : not supported T_expression_NOSPEC\n";
			exit 1
		end
	end
	
	method encode_ADD vec1 vec2 = begin
		let oldindex = self#alloc_index (List.length vec1)
		and carryidx = self#alloc_index (List.length vec1)
		in begin
			(*from oldindex to oldindex+(List.length vec1)-1 are the result of add operation*)
			(*from oldindex+(List.length vec1) to oldindex+(List.length vec1)*2-1 are the carry of add operation*)
			(*proc_add will generate one more bit,which means the carry*)
			let rec proc_add v1 v2 residx cryidx = begin
				match v1 with
				[] -> begin
					if (List.length v2 == 0) && (residx == oldindex+(List.length vec1)) && (cryidx == oldindex+(List.length vec1)*2) then 
						([falsepred],[]) (*to enforce 0 cryidx*)
					else begin
						Printf.printf "fatal error : improper T_add2\n";
						Printf.printf "v2 len %d\n" (List.length v2);
						Printf.printf "v1 len %d\n" (List.length v1);
						Printf.printf "vec2 len %d\n" (List.length vec2);
						Printf.printf "vec1 len %d\n" (List.length vec1);
						Printf.printf "residx %d\n" residx;
						Printf.printf "cryidx %d\n" cryidx;
						Printf.printf "oldindex %d\n" oldindex;
						Printf.printf "carryidx %d\n" carryidx;
						exit 1
					end
				end
				| hd1::tl1 -> begin
					let hd2= List.hd v2
					and tl2= List.tl v2
					in begin
						let (reslst,resclslst) = proc_add tl1 tl2 (residx+1) (cryidx+1)
						in begin
							 let carry = List.hd reslst
							 in begin 
							 	(*we would like 
							 		hd2+hd1+carry ==(cryidx,residx)
							 	*)
							 	(cryidx::(residx::(List.tl reslst)),resclslst@(self#encode_ADD_1bit hd1 hd2 carry cryidx residx))
							 	
							 end
						end
					end
				end
			end
			in
			let (bl,cl)=(proc_add vec1 vec2 oldindex carryidx) (*we dont want the hgihest carry*)
			in
			((List.tl bl),cl)
		end
	end
	
	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin
		let cry000 = ([hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry001 = ([hd1;		hd2;		-1*carry;	-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry010 = ([hd1;		-1*hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry011 = ([hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry100 = ([-1*hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry101 = ([-1*hd1;		hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry110 = ([-1*hd1;		-1*hd2;		carry;		cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry111 = ([-1*hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and res000 = ([hd1;		hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res001 = ([hd1;		hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res010 = ([hd1;		-1*hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res011 = ([hd1;		-1*hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res100 = ([-1*hd1;		hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res101 = ([-1*hd1;		hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res110 = ([-1*hd1;		-1*hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res111 = ([-1*hd1;		-1*hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		in
		[cry000;cry001;cry010;cry011;cry100;cry101;cry110;cry111;res000;res001;res010;res011;res100;res101;res110;res111]
	end
	
	method encode_nba_inseq nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_inseq only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)= self#encode_exp exp
			and lvidx_lst = self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_inseq lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen = min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common = Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common = Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst = List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method addGuard clslist pred = begin
	   if (pred ==1) then clslist
	   else begin
		let proc_cls cls = appendcomment (sprintf "guarded by %d" pred) (((-1*pred)::(fst cls)),(snd cls)) 
		in
		List.map proc_cls clslist
	   end
	end
	
	
	(*the first is the destination*)
	method encode_ASSIGN idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_ASSIGN %d %d\n" idx1 idx2;*)
		let initlst =[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_EQU %d %d\n" idx1 idx2;*)
		let initlst =[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_EQU %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU_res r b1 b2 = begin
		(*Printf.printf  "encode_EQU_res %d %d %d\n" b1 b2 r;*)
		let initlst =[([b1;b2;r],"");([-b1;-b2;r],"");([b1;-b2;-r],"");([-b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_EQU_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_EQUV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let ov_pair = List.combine l1 l2
			in
			List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) ov_pair) 
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_EQUV_res l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len1=(List.length l1)
			in
			let new_base = self#alloc_index len1
			and red_and_res = self#alloc_index 1
			in
			let new_var_lst = lr2list new_base (new_base+len1-1)
			in
			let ov_pair = List.combine l1 l2
			in
			let ov_pair_res = List.combine ov_pair new_var_lst
			in
			let cls_equ = List.concat (List.map (fun x -> match x with ((b1,b2),res) -> (self#encode_EQU_res res b1 b2)) ov_pair_res) 
			and cls_reduce = self#encode_Red_AND red_and_res new_var_lst
			in (*the target and the cls list*)
			(red_and_res,(cls_equ@cls_reduce))
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INEV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len =(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx = self#alloc_index len
			in 
			let rec enc pl1 idx = begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)= enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)= enc pl residx
			and redoridx = self#alloc_index 1
			in
			([redoridx],"redoridx")::((self#encode_Red_OR redoridx idxlst )@clslst)
		end
		else begin
			Printf.printf "fatal error : encode_INEV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INEV_res l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len =(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx = self#alloc_index len
			in 
			let rec enc pl1 idx = begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)= enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)= enc pl residx
			and redoridx = self#alloc_index 1
			in
			(redoridx,((self#encode_Red_OR redoridx idxlst )@clslst))
		end
		else begin
			Printf.printf "fatal error : encode_INEV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INE_res r b1 b2  = begin
		(*Printf.printf  "encode_INE_res %d %d %d\n" r b1 b2 ;*)
		let initlst =[([b1;b2;-r],"");([-b1;-b2;-r],"");([b1;-b2;r],"");([-b1;b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_INE_res %s %s %s" (self#idx2name  r) (self#idx2name b1) (self#idx2name b2) ))  initlst
	end
	
	method encode_AND2_res r b1 b2  = begin
		(*Printf.printf  "encode_AND2_res %d %d %d\n" r b1 b2 ;*)
		let initlst =[([b1;-r],"");([b2;-r],"");([-b1;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_AND2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_OR2_res r b1 b2 = begin
		(*Printf.printf  "encode_OR2_res %d %d %d\n"  r b1 b2;*)
		let initlst =[([-b1;r],"");([-b2;r],"");([b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_OR2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_SEL_res r b1 b2 pred = begin
		(*Printf.printf  "encode_SEL_res %d %d %d %d\n" r b1 b2 pred;*)
		let initlst =[([-pred;b1;-r],"");([-pred;-b1;r],"");([pred;b2;-r],"");([pred;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_SEL_res %s %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) (self#idx2name pred) )) initlst
	end
	
	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 
	
	method encode_NEQ idx1 idx2 = begin
		(*Printf.printf  "encode_NEQ %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst =[([idx1;idx2],"");([-1*idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_NEQ %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	(*first is the target*)
	method encode_NEG_ASSIGN idx1 idx2 = begin
		(*Printf.printf  "encode_NEG_ASSIGN %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst =[([idx2;idx1],"");([-1*idx2;-1*idx1],"")]
		in
		List.map (setcomment (sprintf "encode_NEG_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_Red_AND li bitlst  = begin
		(*Printf.printf  "encode_Red_AND %d\n"   li;*)
		(*first the -1 -2 -3 ... li  *)
		let allcase =(((List.map (fun x -> -1*x) bitlst)@[li]),(sprintf "encode_Red_AND %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then i -li*)
		let proc_b b = ([b;(-1*li)],(sprintf "encode_Red_AND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)) )
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NAND li bitlst  = begin
		(*Printf.printf  "encode_Red_NAND %d\n"   li;*)
		(*first the -1 -2 -3 ... -li  *)
		let allcase =(((List.map (fun x -> -1*x) bitlst)@[(-1*li)]),(sprintf "encode_Red_NAND %d to %s" (List.length bitlst) (self#idx2name li) ))
		in
		(*then i li*)
		let proc_b b = ([b;(li)],(sprintf "encode_Red_NAND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_OR li bitlst  = begin
		(*Printf.printf  "encode_Red_OR %d\n"   li;*)
		(*first the 1 2 3 ... -li  *)
		let allcase =(((List.map (fun x -> x) bitlst)@[(-1*li)]),(sprintf "encode_Red_OR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i li*)
		let proc_b b = ([(-1*b);li],(sprintf "encode_Red_OR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NOR li bitlst  = begin
		(*Printf.printf  "encode_Red_NOR %d\n"   li;*)
		(*first the 1 2 3 ... li  *)
		let allcase =(((List.map (fun x -> x) bitlst)@[(li)]),(sprintf "encode_Red_NOR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i -li*)
		let proc_b b = ([(-1*b);(-1*li)],(sprintf "encode_Red_NOR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode2SAT_explictname = begin
		let encode_explictname key cont = begin
		  let duplst = List.filter (fun x -> match x with (nm,_)-> string_equ nm key) name_index_lst
		  in begin
		    if ((List.length duplst) == 0)   then begin
			let rng = self#name2range key
			and dff = self#isdff key
			in begin
				(*printf "adding %s\n" key;*)
				(*the index is for left side of range*)
				if dff then begin(*dff will has two index, one for current state, the other for next state*)
					name_index_lst <- (key,(last_index,last_index+(get_rng_width rng)))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)*2
				end
				else begin
					name_index_lst <- (key,(last_index,-1))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)
				end
			end
		    end
		    else if ((List.length duplst) == 1) && (string_equ key "assertion_shengyushen") && (match (cont#get_obj) with Tobj_net_declaration(_)->true | Tobj_output_declaration(_)-> true |_ -> false)== true then begin
			Printf.printf "warning : %s is defined multiple times with %d\n" key (List.length duplst);
		    end
		    else begin
			Printf.printf "warning : %s is defined multiple times with %d\n" key (List.length duplst);
		    end
		  end
		end
		in
		Hashtbl.iter encode_explictname circuit_hst
	end
	
	
	(*
		some misc functions
	*)
	method map_lv2index lv = begin (*return the list of index from left to right*)
		(*
			note that, for dff, lv must be a next state, so use the second index
					for non-dff one, just use the first one
		*)
		match lv with  
		T_lvalue_id([name]) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			in 
			rng_baseidx_2_idxlist rng baseidx
		end
		| T_lvalue_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			and off = exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)= rng2lr rng
					in 
					[offset2idx left right baseidx off]
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_lvalue_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			and li = exp2int_simple expl
			and ri = exp2int_simple expr
			in
			let idxlst = lr2list li ri
			and (left,right)= rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					List.map (fun x -> offset2idx left right baseidx x) idxlst
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| _ -> begin
			Printf.printf "fatal error : not supported lv\n";
			exit 1
		end
	end
	
	
	method isdff name = begin
		let co = self#findco name
		in begin
			match co#get_obj with
			Tobj_dff_declaration(_) -> true
			| _ -> false
		end
	end

	method name2range name = begin
			match (self#findco name)#get_obj with
			Tobj_input_declaration(rng) -> rng
			| Tobj_output_declaration(rng) -> rng
			| Tobj_net_declaration(rng) -> rng
			| Tobj_reg_declaration(rng) -> rng
			| Tobj_dff_declaration(rng) -> rng
			| _ -> begin
				Printf.printf "fatal error : name2range not support Tobj\n";
				exit 1
			end
	end
	
	method idx2name idx_unmapped = begin
		let idx = begin (*we must be careful that we may use idx2name before finish encoding the first instance*)
			if final_index_oneinst ==0 then idx_unmapped
			else idx_unmapped mod final_index_oneinst
		end
		in
		(*let ssy = List.filter (fun x -> match x with (nm,(idx1,idx2)) -> if (idx1== idx || idx2== idx) then true else false) name_index_lst
		in *)
		begin
			(*if (List.length ssy) == 1 then fst (List.hd ssy)
			else if  (List.length ssy) == 0 then*)
			begin
				(*it may be in range of some defined data*)
				let nm_idx1_li_ri_idx2name nm idx1 li ri idx = 
					let off =(construct_offset idx1 li ri idx)
					in begin
						if (off == -1) then nm
						else sprintf "%s[%d]" nm off
					end
				in
				let pred_inrange ni = begin
					match ni with
					(nm,(idx1,-1)) -> begin
						let (li,ri)= rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else ""
					end
					| (nm,(idx1,idx2)) -> begin
						let (li,ri)= rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else if (is_inrange (construct_range_onidx idx2 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx2 li ri idx)
						else ""
					end
					(*| _ -> ""*)
				end
				in
				let res = List.map pred_inrange name_index_lst 
				in
				let res1 = List.filter (fun x -> (String.length x) !=0) res
				in begin
					if (List.length res1)==1 then List.hd res1
					else "unknown"
				end
			end
			(*else begin
				Printf.printf "warning : idx2name multiple matched , # of match %d , idx = %d , final_index_oneinst =%d\n" (List.length ssy)  idx final_index_oneinst;
				List.iter (fun x -> match x with (nm,_) -> print_string nm) ssy;
				(*sometimes we will use temp vars to record the add carry bit and so on, they dont has defined name and mapping*)
				(*print_string "name_index_lst:\n";
				List.iter (fun x -> match x with (nm,(id1,id2)) -> Printf.printf "%s %d %d\n" nm id1 id2) name_index_lst;*)
				"unknown"
			end*)
		end
	end
	
	(*print_cnf*)
	method print_cnf clslst dumpout_cnf dly len prefix forward = begin
		check_cnf clslst;
		
		fprintf dumpout_cnf "p cnf %d %d\n" (get_largest_varindex_inclslst clslst) (List.length clslst);
		
		fprintf dumpout_cnf "c module_name  %s \n" name;
		
		List.iter (fun x -> fprintf dumpout_cnf "c module_port  %s \n" (get_str_from_strlst x)) portlist;
		
		(*leave a blank line for awk to exit from printing module definition *)
		fprintf dumpout_cnf "c module_def_end\n"  ;
		
		fprintf dumpout_cnf "c clkname %s\n" clkname;
		
		fprintf dumpout_cnf "c for_rev_cz final_index_oneinst %d\n" final_index_oneinst;
		
		fprintf dumpout_cnf "c for_rev_cz dly %d\n" dly;
		
		fprintf dumpout_cnf "c for_rev_cz len %d\n" len;
		
		fprintf dumpout_cnf "c for_rev_cz prefix %d\n" prefix;
		
		fprintf dumpout_cnf "c for_rev_cz forward %d\n" forward;
		
		(*print out the truepred list*)
		let proc_truepred cls = begin
			match cls with
			([pred],_) -> begin
				if pred > 0 then 
					fprintf dumpout_cnf "c pre_truepred %d\n" pred
			end
			| _ -> ()
		end
		in
		List.iter proc_truepred clslst
		;
		
		let left nm = match (rng2lr (self#name2range nm)) with (left,_)->left
		and right nm = match (rng2lr (self#name2range nm)) with (_,right)->right
		in begin
			List.iter (fun instr ->  fprintf dumpout_cnf "c for_rev_cz input %s %d %d\n"  instr  (left instr)  (right instr))  instrlist;
			List.iter (fun outstr -> fprintf dumpout_cnf "c for_rev_cz output %s %d %d\n" outstr (left outstr) (right outstr)) outstrlist;
		end
		;
		
		let proc_hst key co = begin
			match co#get_obj with
			Tobj_input_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c input_port %s\n" key 
					else
						fprintf dumpout_cnf "c input_port [%d:%d] %s\n" left right key 
				end
			end
			| Tobj_output_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c output_port %s\n" key 
					else
						fprintf dumpout_cnf "c output_port [%d:%d] %s\n" left right key 
				end
			end
			| _ -> ()
		end
		in
		Hashtbl.iter proc_hst circuit_hst
		;
		
		let print_name_index name_index = begin
			match name_index with
			(nm,(curidx,nxtidx)) -> begin
				fprintf dumpout_cnf "c one instance mapping %s %d %d " nm curidx nxtidx;
				match (rng2lr (self#name2range nm)) with
				(left,right) -> 
					fprintf dumpout_cnf "%d %d\n" left right
			end
		end
		in
		List.iter print_name_index name_index_lst
		;
		
		let print_clause cls = begin
			match cls with
			(litlst,cmt) -> begin
				fprintf dumpout_cnf "c %s\n" cmt;
				(*List.iter (fun lit -> if ( lit != -1 && lit != 2 ) then begin fprintf dumpout_cnf "%d " lit end) litlst ;*)
				List.iter (fun lit -> fprintf dumpout_cnf "%d " lit ) litlst ;
				fprintf dumpout_cnf "0\n"
			end
		end
		in
		List.iter print_clause clslst
	end

	method print_itpo arr_itpo = begin
		self#print_itpo_file stdout arr_itpo
	end

	method print_itpo_file fv arr_itpo = begin
			let size = Array.length arr_itpo
			in
			let rec interpObj2str interpObj = begin
				match interpObj with
				TiterpCircuit_true -> "1'b1"
				| TiterpCircuit_false -> "1'b0"
				| TiterpCircuit_refcls(clsidx) -> begin
					let itpo_nxt = arr_itpo.(clsidx)
					in interpObj2str itpo_nxt
				end
				| TiterpCircuit_refvar(varidx) -> begin
					if (varidx>0) then begin
						(*sprintf "%s(%d)" (self#idx2name varidx) varidx*)
						sprintf "%d" varidx
					end
					else if (varidx<0) then begin
						(*sprintf "!%s(%d)" (self#idx2name (-varidx)) varidx*)
						sprintf "%d" varidx
					end
					else assert false
				end
				| TiterpCircuit_and(interpObjlst) -> begin
					let objreslst = List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " & " objreslst);")"]
				end
				| TiterpCircuit_or(interpObjlst) -> begin
					let objreslst = List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " | " objreslst);")"]
				end
				| TiterpCircuit_not(interpObj) -> begin
					let objres = interpObj2str interpObj
					in
					sprintf "!%s" objres
				end
				| TiterpCircuit_printed(clsidx) -> assert false
				| _ -> assert false
			end
			and prt_trace_withInterp num iter_res  = begin
				match iter_res with
				TiterpCircuit_none -> ()
				| _ -> begin
					let str_of_itpo = interpObj2str  iter_res
					in
					fprintf fv "%s" str_of_itpo
				end
			end
			in begin
				prt_trace_withInterp (size-1) arr_itpo.(size-1)
			end
	end

	method print_itpo_verilog_file fv itpo1 idx vpos= begin
		fprintf fv "assign w_%d_%d = " idx vpos;
		let rec prt_itpo itpo = begin
			match itpo with
			TiterpCircuit_true -> "1'b1"
			| TiterpCircuit_false -> "1'b0"
			| TiterpCircuit_refcls(clsidx) -> begin
				assert(clsidx!=0);
				sprintf "w_%d_%d" idx clsidx;
			end
			| TiterpCircuit_refvar(varidx) -> begin
				if (varidx>0) then begin
					sprintf "cycle%d_%s" (varidx/final_index_oneinst) 
							(self#idx2name (varidx mod final_index_oneinst)) 
				end
				else if (varidx<0) then begin
					sprintf "!cycle%d_%s" ((-varidx)/final_index_oneinst) 
							(self#idx2name ((-varidx) mod final_index_oneinst))
				end
				else assert false
			end
			| TiterpCircuit_and(interpObjlst) -> begin
				let objreslst = List.map prt_itpo interpObjlst
				in
				String.concat " " ["(" ;(String.concat " & " objreslst);")"]
			end
			| TiterpCircuit_or(interpObjlst) -> begin
				let objreslst = List.map prt_itpo interpObjlst
				in
				String.concat " " ["(" ;(String.concat " | " objreslst);")"]
			end
			| TiterpCircuit_not(interpObj) -> begin
				let objres = prt_itpo interpObj
				in
				sprintf "!%s" objres
			end
			| TiterpCircuit_printed(clsidx) -> begin
				Printf.printf "\nFATAL :TiterpCircuit_printed\n";
				assert false
			end
			| _ -> begin
				assert (itpo==TiterpCircuit_none);
				assert false
			end
		end in
		let varstr=prt_itpo itpo1 in
		fprintf fv " %s ;\n" varstr ;
	end

	(*for one inst*)
	method set_lock_oneinst = begin
		lock_oneinst <- true
	end
	
	method set_unlock_oneinst = begin
		lock_oneinst <- false
	end
	
	method append_clause_list_oneinst newclslst = begin
		assert (lock_oneinst == false);
		clause_list <- newclslst @ clause_list;
	end
	
	method set_clause_list_oneinst newclslst = begin
		assert (lock_oneinst == false);
		clause_list <- newclslst;
	end
	
	method set_last_index_oneinst newidx = begin
		assert (lock_oneinst == false);
		final_index_oneinst <- (newidx+1);
	end
	
	
	(*for multiple*)
	method set_lock_multiple = begin
		check_clslst_maxidx clause_list_multiple last_index;
		lock_multiple <- true
	end
	
	method set_unlock_multiple = begin
		lock_multiple <- false
	end
	
	method append_clause_list_multiple newclslst = begin
		assert (lock_multiple == false);
		clause_list_multiple <- newclslst @ clause_list_multiple;
	end
	
	method set_clause_list_multiple newclslst = begin
		assert (lock_multiple == false);
		clause_list_multiple <- newclslst;
	end
	
	method set_last_index newidx = begin
		assert (lock_multiple == false);
		last_index <- newidx+1;
		assert ((get_largest_varindex_inclslst clause_list_multiple)<last_index);
	end
	
	(*allocate last_index to last_index+num-1 , and set last_index to last_index+num*)
	method alloc_index num = begin
		assert (lock_multiple == false);
		let oldindex = last_index 
		in begin
			last_index <- oldindex+num;
			oldindex
		end
	end
	

end
