(*correctly found the parameter, but
1 can not characterize
2 too slow
*)

open Printf
open Typedef
open Typedefcommon
open Circuit_obj
open Print_v
open Misc2
open Misc
open Statement
open Misc2
open Dependent
open Str
open Clauseman
open Interp
open Bddssy
open Aig
open Dumpsat
open Gftype
open Printf

exception UNSAT

		

class elabmod = 
object (self)

	(*these will be generated in init method*)
	val mutable name = ""
	val mutable portlist = []
	val mutable tempdirname = ""
	
	(*these will be generated in elaborate method*)
	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 
	val mutable clkname = "" 
	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)
	val mutable comb_always_list : (statement*(string list)) list = []
	val mutable cont_ass_list : assignment list = []

	(*these will be generatesd in encode_oneInstance2SAT_step1 method*)
	(*
		relation between varaibles name and its index
		the int pair in name_index_lst is for dff only, 
			the first one is current state, 
			the second one is for next state, which should be the first one plus rng width
		for other case
			only the first one is meaningful
			the second one must be -1
		
	*)
	val mutable name_index_lst : (string*(int*int)) list = []  
	
	val mutable lock_oneinst : bool = false
	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable final_index_oneinst = 0
	
	val truepred = 1
	val falsepred =2
	val assertion_shengyushen ="assertion_shengyushen"
	(*these will generated by multiple instance generation*)

	(*to prevent incidently change of clause_list_multiple and last_index*)
	val mutable lock_multiple : bool = false
	val mutable clause_list_multiple : ((int list)*string) list = []
	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	(*these will be generated by compsyn*)
	(*they will never be changed after assignment*)
	val mutable instrlist = []
	val mutable outstrlist = []
	val mutable non_proctocol_input_list = []
	
	(*they will never be changed after assignment*)
	val mutable bv_instrlist = []
	val mutable bv_outstrlist = []
	val mutable bv_non_proctocol_input_list = []
	
	(*used to store the clause list of f's relation
	we will use them to expand to fd test*)
	val mutable clause_list_multiple_f : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index_f = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	(*used to store the clause list of f's relation
	we will use them to expand to fd test*)
	val mutable clause_list_multiple_genia : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index_genia = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	val mutable ddM = CaddieBdd.init 0 64 256 512

	(*adding new mod list for parsing fec module*)
	val mutable mod_list : (string*module_instance) list = []





	(*change mod_list to array of type_flat connected by wire array*)
	val mutable type_flat_array : type_flat array = Array.make 1 ("","",[],[],[])
	val mutable hashInput  : (string,range) Hashtbl.t = Hashtbl.create 100
	val mutable hashOutput : (string,range) Hashtbl.t = Hashtbl.create 100
	val mutable assignHashL2R : (type_net,type_net) Hashtbl.t = Hashtbl.create 100
	val mutable assignHashR2L : (type_net,type_net) Hashtbl.t = Hashtbl.create 100
	val mutable last_pointer : int =0

	(*unfold type_flat*)
	val mutable type_flat_unfold_array : type_flat array =Array.make 1 ("","",[],[],[])
	val mutable assignHashL2R_unfold : (type_net,type_net) Hashtbl.t = Hashtbl.create 1000
(* 	val mutable assignHashR2L_unfold : (type_net,type_net) Hashtbl.t = Hashtbl.create 1000 *)
	val mutable hashInput_unfold  : (string,range) Hashtbl.t = Hashtbl.create 100
	val mutable hashOutput_unfold : (string,range) Hashtbl.t = Hashtbl.create 100
	val mutable hashWireUnfold : (string,range) Hashtbl.t=Hashtbl.create 100000
	val mutable hashTnetValue : (type_net,type_net) Hashtbl.t=Hashtbl.create 10000

	(*converting flat wire to gfdata*)
	val mutable last_hash_pointer : int =0 
	(*mapping from type_gfdata to index *)
	val gfdata_hash : (type_gfdata, int) Hashtbl.t = Hashtbl.create 100000 
	(*mapping from index to type_gfdata*)
	val mutable gfdata_array : type_gfdata array = Array.make 1 TYPE_GFDATA_NULL
	(*modules*)
	val mutable gfmod_array : type_gfmod array = Array.make 1 TYPE_GFMOD_NULL


	method print dumpout = begin
		fprintf dumpout "module %s (\n" name;
		list_iter_interleave (fun x -> fprintf dumpout "   %s " (get_str_from_strlst x)) (fun x -> fprintf dumpout " , \n") portlist;
		fprintf dumpout "\n);\n";
		
		(*print out all input*)
		let print_input key cont = begin
			match cont#get_obj with
			Tobj_input_declaration(rng) -> begin
				fprintf dumpout "   input ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_input circuit_hst
		;
		
		(*print out all output*)
		let print_output key cont = begin
			match cont#get_obj with
			Tobj_output_declaration(rng) -> begin
				fprintf dumpout "   output ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_output circuit_hst
		;
		
		(*print out all wire*)
		let print_wire key cont = begin
			match cont#get_obj with
			Tobj_net_declaration(rng) -> begin
				fprintf dumpout "   wire ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_wire circuit_hst
		;
		
		(*print out all reg*)
		let print_reg key cont = begin
			match cont#get_obj with
			Tobj_reg_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| Tobj_dff_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_reg circuit_hst
		;
		
		(*print out all seq*)
		let print_seq seq_always = begin
			match seq_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(posedge %s) begin\n" clkname;
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
		end
		in
		List.iter print_seq seq_always_list
		;
		
		(*print out all comb*)
		let print_comb comb_always = begin
			match comb_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(\n";
				
				let deplist = dep_statement stat
				in
				list_iter_interleave (fun x -> fprintf dumpout " %s " x) (fun x -> fprintf dumpout " or ") deplist
				;
				
				fprintf dumpout ") begin\n";
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
		end
		in
		List.iter print_comb comb_always_list
		;
		
		(*print out all cont assign*)
		let print_cont_ass cont_ass = begin
			match cont_ass with
			T_assignment(lv,exp) -> begin
				fprintf dumpout "assign  ";
				print_v_lvalue dumpout lv;
				fprintf dumpout " = ";
				print_v_expression dumpout exp;
				fprintf dumpout ";\n"
			end
			(*| _ -> ()*)
		end
		in
		List.iter print_cont_ass cont_ass_list
		;
		
		fprintf dumpout "endmodule\n"
	end

	method getname = name

	method addco str co = begin
		(*Printf.printf "adding %s\n" hn#getname ;*)
		Hashtbl.add circuit_hst str co
	end

	method rplco str co = begin
		(*Printf.printf "replacing %s\n" hn#getname ;*)
		Hashtbl.replace circuit_hst str co
	end

	method findco str = begin
		try 
			Hashtbl.find circuit_hst str
		with Not_found -> begin
			Printf.printf "fatal error : undefined hn %s are treated as wire\n" str;
			exit 1
			(*following code is for those large number of undefined net*)
			(*self#addco hn (new circuit_obj (Tobj_net_declaration(T_range_NOSPEC,T_expression_NOSPEC(1)))  hn);
			Hashtbl.find circuitobj_hst hn#getname *)
		end
	end

	method nameInportlist name1 = begin
		let check_portname pt = begin
			match pt with 
			[ptn] -> string_equ ptn name1
			|_ -> begin
				Printf.printf "fatal error : port name should not be a list\n";
				exit 1
			end
		end
		in 
		let portfound = List.filter check_portname  portlist
		in begin
			if (List.length portfound) != 1 then begin
				Printf.printf "fatal error : portfound is not unique\n";
				exit 1
			end
		end
	end
	
	method proc_T_input_declaration range namelst = begin
		let proc_one_input name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn = new hierachcal_name [name1]
			in
			let inCircuitObj = new circuit_obj (Tobj_input_declaration(range))  newhn
			in
			self#addco name1 inCircuitObj
		end
		in 
		List.iter proc_one_input namelst
	end
	
	method proc_T_output_declaration range namelst = begin
		let proc_one_output name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn = new hierachcal_name [name1]
			in
			let outCircuitObj = new circuit_obj (Tobj_output_declaration(range))  newhn
			in
			self#addco name1 outCircuitObj
		end
		in 
		List.iter proc_one_output namelst
	end
	
	method proc_T_net_declaration nettypename exprng namelst = begin
		if (string_equ nettypename "wire") != true then begin
			Printf.printf "fatal error : only supported wire\n";
			Printf.printf "%s\n" nettypename;
			exit 1
		end
		;
		let rng = match exprng with
		T_expandrange_range(rng1) -> rng1
		| T_expandrange_NOSPEC -> T_range_NOSPEC
		|_ -> begin
			Printf.printf "fatal error : only supported T_expandrange_range\n";
			exit 1
		end
		in begin
			let proc_one_net netn = begin
				(*add it to circuit object list*)
				let newhn = new hierachcal_name [netn]
				in
				let netCircuitObj = new circuit_obj (Tobj_net_declaration(rng))  newhn
				in
				self#addco netn netCircuitObj
			end
			in 
			List.iter proc_one_net namelst
		end
	end
	
	method proc_T_reg_declaration  rng regvarlst = begin
		let proc_one_reg regvar = begin
			(*add it to circuit object list*)
			match regvar with
			T_register_variables_ID(regname) -> begin
				let newhn = new hierachcal_name [regname]
				in
				let regCircuitObj = new circuit_obj (Tobj_reg_declaration(rng))  newhn
				in
				self#addco regname regCircuitObj
			end
			| T_register_variables_IDrange(regname,lexp,rexp) -> begin
				Printf.printf "fatal error : not supported T_register_variables_IDrange\n";
				exit 1
			end
		end
		in 
		List.iter proc_one_reg regvarlst
	end
	
	method proc_T_continuous_assign cont_ass = begin
		let asslst = begin
			match cont_ass with
			T_continuous_assign_assign(_,_,asslst1) -> asslst1
			| T_continuous_assign_net(nettypename,_,exprng,_,asslst1) -> begin
				(*i need to first put them into circuit object list*)
				begin
					let ass2name ass = begin
						match ass with 
						T_assignment(lv,_) -> begin
							match lv with 
							T_lvalue_id([nm]) -> nm
							| _ -> begin
								Printf.printf "fatal error : only supported T_lvalue_id 2\n";
								exit 1
							end
						end
					end
					in
					let namelst = List.map ass2name asslst1
					in
					self#proc_T_net_declaration nettypename exprng namelst
				end
				;
				asslst1
			end
		end
		in  cont_ass_list <- asslst @ cont_ass_list
		(*begin
			let proc_ass ass = begin
				match ass with
				T_assignment(lv,exp) -> begin
					match lv with
					T_lvalue_id([nm]) -> begin
						let hn = new hierachcal_name [nm]
						in
						let rngold = begin
							match ((self#findco nm)#get_obj) with
							Tobj_net_declaration(rngo,_) -> rngo
							| _ -> begin
								Printf.printf "fatal error : only should find Tobj_net_declaration \n";
								exit 1
							end
						end
						in
						let co = new circuit_obj (Tobj_net_declaration(rngold,exp)) hn
						in
						self#rplco nm co
					end
					| T_lvalue_arrbit
					| _ -> begin
						Printf.printf "fatal error : only supported T_lvalue_id 1\n";
						print_v_lvalue stdout lv;
						exit 1
					end
				end
			end
			in
			List.iter proc_ass asslst
		end*)
	end
	
	method proc_T_always_statement_seq stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				if (List.length evexplst) != 1 then begin
					Printf.printf "fatal error : only supported sync set and reset regs\n";
					exit 1
				end
				;
				(*set the clock*)
				let clkeve =(List.hd evexplst)
				in begin
					match clkeve with 
					T_event_expression_posedge(exp) -> begin
						match exp with
						T_primary(T_primary_id([clkn])) -> begin
							if (string_equ clkname "") then clkname <- clkn
							else if (string_equ clkname clkn) then clkname <- clkn
							else begin
								Printf.printf "fatal error : only supported one clock\n";
								exit 1
							end
						end
						| _ -> begin
							Printf.printf "fatal error : only supported id as clock name\n";
							exit 1
						end
					end
					| _ -> begin
						Printf.printf "fatal error : only supported T_event_expression_posedge\n";
						exit 1
					end
				end
				;
				(*extract the reg name list*)
				let regnamelist = statement2regnamelist stat_sub
				in begin
					(*add these reg's definition to list*)
					seq_always_list <- (stat_sub,regnamelist) :: seq_always_list
					;
					(*change them to dff*)
					let proc_reg regname = begin
						let hn = new hierachcal_name [regname]
						in
						let co = self#findco regname
						in begin
							match co#get_obj with
							Tobj_reg_declaration(rngr) -> begin
								self#rplco regname (new circuit_obj (Tobj_dff_declaration(rngr)) hn)
							end
							| Tobj_dff_declaration(_) -> begin
								Printf.printf "warning : why it is already dff?\n";
								Printf.printf "%s\n" regname;
							end
							| _ -> begin
								Printf.printf "fatal error : object in always statement should be declared as reg\n";
								Printf.printf "%s\n" regname;
								exit 1
							end
						end
					end
					in
					List.iter proc_reg regnamelist
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement_comb stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			let regnamelist = statement2regnamelist stat_sub
			in
			comb_always_list <- (stat_sub,regnamelist) :: comb_always_list
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				let isedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> true
					| T_event_expression_negedge(_) -> true
					| _ -> false
				end
				and notedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> false
					| T_event_expression_negedge(_) -> false
					| _ -> true
				end
				in
				if (List.for_all isedgeevent evexplst) then self#proc_T_always_statement_seq stat
				else if (List.for_all notedgeevent evexplst) then self#proc_T_always_statement_comb stat
				else begin
					Printf.printf "fatal error : edge and non edge event at the same time\n";
					exit 1
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_MI mi = begin
		match mi with
		T_parameter_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_declaration\n";
			exit 1
		end
		| T_input_declaration(range,namelst) -> 
			self#proc_T_input_declaration range namelst
		| T_output_declaration(range,namelst) -> 
			self#proc_T_output_declaration range namelst
		| T_inout_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_inout_declaration\n";
			exit 1
		end
		| T_net_declaration(netname,_,exprng,_,namelst) -> 
			self#proc_T_net_declaration netname exprng namelst
		| T_reg_declaration(rng,regvarlst) -> 
			self#proc_T_reg_declaration rng regvarlst
		| T_time_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_time_declaration\n";
			exit 1
		end
		| T_integer_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_integer_declaration\n";
			exit 1
		end
		| T_real_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_real_declaration\n";
			exit 1
		end
		| T_event_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_event_declaration\n";
			exit 1
		end
		| T_gate_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_gate_declaration\n";
			exit 1
		end
		| T_module_instantiation(name,_,_,milst) -> begin
			assert ((List.length milst)==1) ;
			mod_list <- (name,List.hd milst)::mod_list;
			()
		end
		| T_parameter_override(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_override\n";
			exit 1
		end
		| T_continuous_assign(cont_ass) ->  
			self#proc_T_continuous_assign cont_ass
		| T_specify_block(_) -> begin
			Printf.printf "fatal error : not supported T_specify_block\n";
			exit 1
		end
		| T_initial_statement(_) -> begin
			Printf.printf "fatal error : not supported T_initial_statement\n";
			exit 1
		end
		| T_always_statement(stat) -> 
			self#proc_T_always_statement stat
		| T_task(_,_,_) -> begin
			Printf.printf "fatal error : not supported T_task\n";
			exit 1
		end
		| T_function_avoid_amb(_,_,_,_) -> begin
			Printf.printf "fatal error : not supported T_function_avoid_amb\n";
			exit 1
		end
	end

	method init module2beElaborated tempdirname1 = begin
		match module2beElaborated with
		T_module_def(modName,portlist1,milist) -> begin
			name <- modName;
			portlist <- portlist1;
			tempdirname <- tempdirname1;
			(*processing mi list*)
			List.iter (self#proc_MI) milist
		end
		| _ -> begin
			Printf.printf "fatal error : only T_module_def\n";
			exit 1
		end
	end
	
	method name2idxlist name = begin
		let baseidx = begin
			let (x1,_)= List.assoc name name_index_lst
			in x1
		end
		and rng = self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method name2idxlist_nxt name = begin
		let baseidx = begin
			let (_,x1)= List.assoc name name_index_lst
			in x1
		end
		and rng = self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method is_assertion name_index = begin
		match name_index with 
		(nm,_) -> begin
			string_equ nm assertion_shengyushen
		end
	end

	method constrain_assertion li = begin (*li is from bound-1 to 0*)
		(*let maxidx = get_largest_varindex_inclslst clause_list_multiple in*)
		(*2014/11/16 Shen : we dont need to run in list mode as assertion_shengyushen have only one element*)
		(*let ov = List.concat (List.map self#name2idxlist [assertion_shengyushen]) in *)
		let ov = self#name2idxlist assertion_shengyushen in 
		let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov in
		List.map (fun x -> (*assert (x<= maxidx) ;*)([x],assertion_shengyushen) ) ov_0
	end

	method try_assertion start_i end_i = begin
		if(end_i<start_i) then []
		else begin
			let old_assclslst = self#constrain_assertion end_i
			and cur_assclslst = self#try_assertion start_i (end_i-1)
			in
			old_assclslst@cur_assclslst
		end
	end

	(*return the new result of equ*)
	method alloc_and_equ_res ov_pair_lst = begin
		match ov_pair_lst with 
		(a, b) -> begin
			let r = self#alloc_index 1
			in
			let equres = self#encode_EQU_res r a b
			in 
			(r,equres)
		end
	end
	
	(*from here on is the list of method of complementary synthesis*)

	method procDetermineUniqueInputs inlst = begin
		dbg_print "procDetermineUniqueInputs";
		let inlst2 = List.map (fun x -> (x,RES_UNK,0,0,0)) inlst in
		let arrlist2 = Array.of_list inlst2 (*the list of index and whether they can be uniquely determined*) in
		let procBitnonloop bnd idx x  = begin
			(*testing for nonloop uniqness*)
			match x with 
			(bitI,res,_,_,_) -> begin
				match res with 
				RES_UNK -> begin
					let p =bnd
					and l =bnd
					and r =bnd in
					let o0 = bitI + (p+l)*final_index_oneinst
					and ob = bitI + (p+l+1+r+p+l)*final_index_oneinst in
					let nonloopres = satAssumption [-o0;ob] in begin	
						if(nonloopres == UNSATISFIABLE) then begin
							(*uniquelly determined*)
							let name = self#idx2name bitI in 
							printf "uniq %s @ %d\n" name bitI;
							flush stdout;
							Array.set arrlist2 idx (bitI,RES_UNIQ,bnd,bnd,bnd);
						end
					end
				end
				| _ -> ()
			end
		end 
		and procBitloop bnd idx x  = begin
			(*testing for loop non-uniqness*)
			match x with 
			(bitI,res,_,_,_) -> begin
				match res with 
				RES_UNK -> begin
					let p =bnd
					and l =bnd
					and r =bnd in
					let o0 = bitI + (p+l)*final_index_oneinst
					and ob = bitI + (p+l+1+r+p+l)*final_index_oneinst in
					let nonloopres = satAssumption [-o0;ob] in begin	
						if(nonloopres == SATISFIABLE) then begin
							(*non-uniquelly determined*)
							(*find out all index with diff value*)
							let procdiffv id2 xx = begin
								match xx with
								(bitIxx,resxx,_,_,_) -> begin
									let o0xx = bitIxx + (p+l)*final_index_oneinst
									and obxx = bitIxx + (p+l+1+r+p+l)*final_index_oneinst in
									let (idx1xx,vo0xx)= get_assignment o0xx
									and (idx2xx,vobxx)= get_assignment obxx in begin
										assert (idx1xx == o0xx);
										assert (idx2xx == obxx);
										if(resxx == RES_UNK) then begin
											if(vo0xx!= vobxx) then begin
												let name = self#idx2name bitIxx in 
												printf "nouniq %s @ %d\n" name bitIxx;
												flush stdout;
												Array.set arrlist2 id2 (bitIxx,RES_NONU,0,0,0);
											end
										end
										else if(resxx == RES_UNIQ) then begin
											assert (vobxx == vo0xx);
										end
									end
								end
							end in
							Array.iteri (procdiffv) arrlist2;
						end
					end
				end
				| _ -> ()
			end
		end
		in 
		let bndd=ref 2
		in begin
			(*loop until we have all determined or not, and no unknown case*)
			while((self#arrayexists (fun x -> match x with (_,res,_,_,_) -> (res == RES_UNK)) arrlist2)) do
				(*or else we increase bound by 1 and test all RES_UNK*)
				bndd:=(!bndd)+1;
				printf "trying bound %d\n" (!bndd);
				flush stdout;

				(**********************)
				(*nonloop case*)
				(**********************)
				let target_nonloop = self#construct_nonloop (!bndd) (!bndd) (!bndd) [] [] in 
				let nonloop_clslst=(([target_nonloop],"target")::clause_list_multiple) in begin
					(*add the clasue for one time into the minisat clause database*)
					Dumpsat.procClauseandAdd nonloop_clslst;
					(*test for all bits for uniqness without loop*)
					Array.iteri (procBitnonloop (!bndd)) arrlist2;
				end;
				(**********************)
				(*loop case*)
				(**********************)

				if((self#arrayexists (fun x -> match x with (_,res,_,_,_) -> (res == RES_UNK)) arrlist2)) then begin
					let target_loop = self#construct_loop (!bndd) (!bndd) (!bndd)  target_nonloop in 
					let loop_clslst=(([target_loop],"target")::clause_list_multiple) in begin
						(*add the clasue for one time into the minisat clause database*)
						Dumpsat.procClauseandAdd loop_clslst;
						(*test for all bits for uniqness without loop*)
						Array.iteri (procBitloop (!bndd)) arrlist2;
					end;
				end
			done;
			(*map the result from array back to list*)
			let lstres=(Array.to_list arrlist2) in
			List.map (fun x -> match x with (bitii,res,p,l,r) -> assert ((p == l) && (l == r) && (res!= RES_UNK));((res == RES_UNIQ),bitii,p)) lstres
		end
	end (*of procDetermineUniqueInputs*)

	method tryPCSAT p l r assLst = begin
		(*dbg_print (sprintf "tryPCSAT p %d l %d r %d" p l r);*)
		(*this do not include the input constrain*)
		let target=self#construct_nonloop p l r assLst [] in begin
			self#set_unlock_multiple;
			self#append_clause_list_multiple  [([target],"target")]
		end
		;

		(*force the input of p+l and p+l+1+r+p+l to be diff*)
		self#set_unlock_multiple;
		let ov = bv_instrlist	in 
		let ov_0 = List.map (fun x -> x+ (p+l)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+l+1+r+p+l)*final_index_oneinst) ov in
		self#append_clause_list_multiple  (self#encode_INEV (ov_0) (ov_b)) 
		;
		(*dbg_print "  after generating clauses";*)

		check_clslst_maxidx clause_list_multiple last_index;
		let res=dump_sat_withclear clause_list_multiple in begin
			(*dbg_print "exiting tryPCSAT";*)
			if(res == UNSATISFIABLE) then false
			else if(res == SATISFIABLE) then true
			else assert false
		end
	end

	method minimizeL p l r assLst = begin
		assert (p>=0);
		assert (r>=0);
		if (l>=(-r+1)) then begin
			let res=self#tryPCSAT p (l-1) r assLst in begin
				if(res) then l
				else self#minimizeL p (l-1) r assLst 
			end
		end
		else if(l==0) then 0
		else assert false
	end

	method minimizeR p l r assLst = begin
		assert (p>=0);
		assert (l>=0);
		if (r>=1) then begin
			let res=self#tryPCSAT p l (r-1) assLst in begin
				if(res) then r
				else self#minimizeR p l (r-1) assLst 
			end
		end
		else if(r==0) then 0
		else assert false
	end

	method minimizeLR p l r assLst = begin
		(*this is the simplest implementation*)
		(*(p,l,r)*)
		(*this one really minimize it*)
		let newr=self#minimizeR p l r assLst in
		let newl=self#minimizeL p l newr assLst in begin
			(newl,newr)
		end
	end

	method getAllInputList = begin
		(*find out all input ports*)
		let ext_input key cont last_res = begin
			match cont#get_obj with
			Tobj_input_declaration(_) -> begin
				key::last_res
			end
			| _ -> last_res
		end
		in
		Hashtbl.fold ext_input circuit_hst []
	end

	method getNonProtocolInputList allinputs  = begin
		(*non protocol inputs*)
		let is_non_protocol x = begin
			match x with
			key -> not (List.mem key instrlist)
		end
		in
		List.filter is_non_protocol allinputs
	end

	method dumpCNF cnfname_1inst= begin
		(*
			dump to sat *_1inst.cnf, for verification purpose,
			I will write another program to map the *_1inst.cnf back to verilog,
			such that it can be verified by formality
		*)
		(*Printf.printf "start to do 1 \n" ;*)
		begin
			print_endline "";
			print_endline  cnfname_1inst;
		
			let dumpout_cnf = open_out cnfname_1inst
			in
			self#print_cnf clause_list dumpout_cnf 0 1 0 0 
			;
			close_out dumpout_cnf
		end
	end

	method printInOutList non_proctocol_input_list instrlist outstrlist = begin
		printf "\n+++++ start of non protocol input list +++\n";
		List.iter (printf " %s ") non_proctocol_input_list ;

		printf "\n+++++ start of protocol input list +++\n";
		List.iter (printf " %s ")  instrlist;

		printf "\n+++++ start of protocol output list +++\n";
		List.iter (printf " %s ")  outstrlist;
		printf "\n";
		flush stdout;
	end
	
(*
	method getZ1 colist = begin
		let zlist=self#getZ colist in begin
			match zlist with
			[z] -> z
			| _ -> assert false
		end
	end

	method getA1 colist = begin
		let zlist=self#getA colist in begin
			match zlist with
			[z] -> z
			| _ -> assert false
		end
	end

	method getB1 colist = begin
		let zlist=self#getB colist in begin
			match zlist with
			[z] -> z
			| _ -> assert false
		end
	end

*)
	method isInput str = begin
		Hashtbl.mem hashInput str
	end

	method isOutput str = begin
		Hashtbl.mem hashOutput str
	end

  method str2ion str = begin
	  if(self#isInput str) then 
			(TYPE_CONNECTION_IN,TYPE_NET_ID(str))
    else if (self#isOutput str) then 
			(TYPE_CONNECTION_OUT,TYPE_NET_ID(str))
    else 
			(TYPE_CONNECTION_NET,TYPE_NET_ID(str))
  end

  method stridx2ion str idx = begin
    if(self#isInput str) then 
			(TYPE_CONNECTION_IN,TYPE_NET_ARRAYBIT(str,idx))
    else if (self#isOutput str) then 
			(TYPE_CONNECTION_OUT,TYPE_NET_ARRAYBIT(str,idx))
    else 
			(TYPE_CONNECTION_NET,TYPE_NET_ARRAYBIT(str,idx))
  end

	method extExp exp = begin
		match exp with
		T_named_port_connection(_,exp1) -> begin
      match exp1 with
      T_primary(T_primary_concat(explst)) -> begin 
				let proc_exp x = begin 
					match x with 
					T_primary(T_primary_id([str])) -> 
						self#str2ion str 
					| T_primary(T_primary_arrbit([str],idx)) -> 
						self#stridx2ion str (Expression.exp2int_simple idx)
					|  T_primary(T_primary_num(T_number_base(1,'b',"0"))) -> 
						(TYPE_CONNECTION_NET,TYPE_NET_CONST(0))
					|  T_primary(T_primary_num(T_number_base(1,'b',"1"))) -> 
						(TYPE_CONNECTION_NET,TYPE_NET_CONST(1))
					| _ -> assert false
        end in
  			List.map proc_exp explst;
      end
			| T_primary(T_primary_num(T_number_base(1,'b',"0"))) -> 
				[(TYPE_CONNECTION_NET,TYPE_NET_CONST(0))]
			| T_primary(T_primary_num(T_number_base(1,'b',"1"))) -> 
				[(TYPE_CONNECTION_NET,TYPE_NET_CONST(1))]
      | T_primary(T_primary_id([str])) -> 
				[self#str2ion str]
      | T_primary(T_primary_arrbit([str],idx)) -> 
				[self#stridx2ion str (Expression.exp2int_simple idx)]
			| T_expression_NOSPEC(_) -> begin
				(*non connected*)
				[TYPE_CONNECTION_NET,TYPE_NET_NULL]
			end
			| T_primary(T_primary_arrrange([str],leftexp,rigthexp)) -> begin
				let newion= begin
					if(self#isInput str) then TYPE_CONNECTION_IN
					else if(self#isOutput str) then 
						TYPE_CONNECTION_OUT
					else TYPE_CONNECTION_NET
				end
				and leftbound=Expression.exp2int_simple leftexp
				and rightbound=Expression.exp2int_simple rigthexp
				in
				let lrlst=lr2list leftbound rightbound 
				in 
				List.map (fun x -> (newion,TYPE_NET_ARRAYBIT(str,x))) lrlst
			end
      | _ -> begin
				print_v_expression stdout exp1;
				printf "\n";
				flush stdout;
				assert false
			end
		end
		| _ -> assert false
	end

  method getX x colist = begin
		let isX x1 = begin
			match x1 with
			T_named_port_connection(xx,zexp) -> xx=x
			|_ -> false
		end in
		begin
			match colist with
			T_list_of_module_connections_named(clist) -> begin
				let exp=begin
					try 
						List.find isX clist 
					with Not_found -> 
						T_named_port_connection(x,T_expression_NOSPEC(0))
				end
				in
				self#extExp exp
			end
			|_ -> assert false
		end
  end

	method getZ colist = begin
          self#getX "Z" colist
	end

	method getA colist = begin
          self#getX "A" colist
	end

	method getB colist = begin
          self#getX "B" colist
	end

	method procHandleInOut str co = begin
		let cot=co#get_obj 
		in 
		begin
			match cot with
			Tobj_input_declaration(rng) -> 
				Hashtbl.add hashInput str rng
			| Tobj_output_declaration(rng) ->
				Hashtbl.add hashOutput str rng
			| _ -> ()
		end
	end

	method construct_boolonly_netlist = begin
		printf "construct_boolonly_netlist start\n";
		flush stdout;

		(*construct the input and output hash*)
		Hashtbl.iter (self#procHandleInOut) circuit_hst;

		(*then handle modules*)
		type_flat_array <- Array.make (List.length mod_list) ("","",[],[],[]);
		last_pointer <- 0;
		let proc_mod_inner m = begin
			match m with
			(defname,T_module_instance(instname,colist)) -> begin
				let zconlist = self#getZ colist
				and aconlist = self#getA colist
				and bconlist = self#getB colist
				in
				(defname,instname,zconlist,aconlist,bconlist) 
			end
		end 
		in
		let proc_mod m = begin
			let newm=proc_mod_inner m 
			in
			let newmod=begin
				(*all modules instance with Z not connected 
				will become ("","",[],[],[])*)
				match newm with
				(_,_,[(_,TYPE_NET_NULL)],_,_) ->
					("","",[],[],[])
				| (modname,instname,ztcl,atcl,btcl) -> begin
					if(modname="IV" || modname="tower2flat" || modname = "flat2tower") then 
						(modname,instname,ztcl,atcl,[])
					else
						newm
				end
			end
			in 
			begin
				Array.set type_flat_array last_pointer newmod;
				last_pointer <- last_pointer +1 ;
			end
		end
		in
		List.iter proc_mod mod_list;
		assert (last_pointer==(List.length mod_list));
	end


	method print_type_ion tion = begin
				match tion with
				TYPE_CONNECTION_NET -> 
					Printf.printf " TYPE_CONNECTION_NET "
				| TYPE_CONNECTION_IN -> 
					Printf.printf " TYPE_CONNECTION_IN "
				| TYPE_CONNECTION_OUT -> 
					Printf.printf " TYPE_CONNECTION_OUT "
	end

	method print_type_net tnet = begin
				match tnet with
				TYPE_NET_ID(str) ->  begin
					assert (str<>"");
					printf " %s " str
				end
				| TYPE_NET_CONST(i) -> 
					printf " %d "  i
				| TYPE_NET_ARRAYBIT(str,idx) -> 
					printf " %s[%d] " str idx
				| TYPE_NET_NULL -> ()
	end

	method print_type_connection tc = begin
		match tc with
		(tion,tnet) -> begin
			self#print_type_ion tion;
			self#print_type_net tnet;
		end
	end

	method print_type_connection_list tclst = begin
		List.iter (self#print_type_connection) tclst
	end

	method print_gfdata gfdata = begin
		match gfdata with
		TYPE_GFDATA_GF1024(tclst) -> begin
			Printf.printf "TYPE_GFDATA_GF1024 ";
			self#print_type_connection_list tclst;
			printf "\n";
		end
		| TYPE_GFDATA_GF3232(tclst) -> begin
			Printf.printf "TYPE_GFDATA_GF3232 ";
			self#print_type_connection_list tclst;
			printf "\n";
		end
		| TYPE_GFDATA_BOOL(tc) -> begin
			Printf.printf "TYPE_GFDATA_BOOL ";
			self#print_type_connection tc;
			printf "\n";
		end
		| TYPE_GFDATA_NULL -> assert false
	end

	method is2OpGF modname = begin
		match modname with
		"gfadd_mod" -> true
		| "gfmult_flat_mod" -> true
		| "gfmult_mod" -> true
		| "gfdiv_mod" -> true
		| _ -> false
	end

	method is1OpGF modname = begin
		match modname with
		"tower2flat" -> true
		| "flat2tower" -> true
		| _ -> false
	end

(*
	method construct_gf_netlist = begin
		(*then find out all gfdata type instance 
		and construct gfdata_list*)
		let isLstIn tclst = begin
			(Hashtbl.mem gfdata_hash (TYPE_GFDATA_GF1024(tclst))) || (Hashtbl.mem gfdata_hash (TYPE_GFDATA_GF3232(tclst)))
		end 
		in
		let isTcIn tc = begin
			Hashtbl.mem gfdata_hash (TYPE_GFDATA_BOOL(tc))
		end 
		in
		let addLstIn tclst = begin
			Hashtbl.add gfdata_hash tclst last_hash_pointer;
			last_hash_pointer <- last_hash_pointer +1;
		end
		in
		let addTcIn tc = begin
			Hashtbl.add gfdata_hash tc last_hash_pointer;
			last_hash_pointer <- last_hash_pointer +1;
		end
		in
		let proc_type_flat tf = begin
			match tf with 
			(modname,_,ztclst,atclst,btclst) -> begin
				if (self#is2OpGF modname) then begin
					if(isLstIn ztclst)=false then begin
						addLstIn (TYPE_GFDATA_GF1024(ztclst));
					end;
					if(isLstIn atclst)=false then begin
						addLstIn (TYPE_GFDATA_GF1024(atclst));
					end;
					if(isLstIn btclst)=false then begin
						addLstIn (TYPE_GFDATA_GF1024(btclst));
					end;
				end
				else if(self#is1OpGF modname) then begin
					assert (isEmptyList btclst);
					if(isLstIn ztclst)=false then begin
						addLstIn (TYPE_GFDATA_GF1024(ztclst));
					end;
					if(isLstIn atclst)=false then begin
						addLstIn (TYPE_GFDATA_GF1024(atclst));
					end;
				end
				else if(self#is2OpBool modname) then begin
					assert (isSingularList ztclst);
					assert (isSingularList atclst);
					assert (isSingularList btclst);
					let ztc=List.hd ztclst
					and atc=List.hd atclst
					and btc=List.hd btclst
					in 
					if(isTcIn ztc)=false then begin
						addTcIn (TYPE_GFDATA_BOOL(ztc));
					end;
					if(isTcIn atc)=false then begin
						addTcIn (TYPE_GFDATA_BOOL(atc));
					end;
					if(isTcIn btc)=false then begin
						addTcIn (TYPE_GFDATA_BOOL(btc));
					end;
				end
				else if(self#is1OpBool modname) then begin
					assert (isSingularList ztclst);
					assert (isSingularList atclst);
					assert (isEmptyList btclst);
					let ztc=List.hd ztclst
					and atc=List.hd atclst
					in 
					if(isTcIn ztc)=false then begin
						addTcIn (TYPE_GFDATA_BOOL(ztc));
					end;
					if(isTcIn atc)=false then begin
						addTcIn (TYPE_GFDATA_BOOL(atc));
					end;
				end
				else assert false
			end
		end 
		in begin
			printf "start building gfdata_list with type_flat_array size %d\n" (Array.length type_flat_array);
			flush stdout;
			
			(*building gfdata_hash*)
	 		Array.iter (proc_type_flat) type_flat_array; 

			let hash_length=Hashtbl.length gfdata_hash 
			in begin
				assert (hash_length=last_hash_pointer);
				gfdata_array <- Array.make last_hash_pointer TYPE_GFDATA_NULL;
				printf "length of gfdata_hash %d\n" hash_length;
				(*move the data from gfdata_hash to gfdata_array*)
				let proc_gfdata_hash gfd idx = begin
					assert (idx >=0 && idx <hash_length);
					assert (gfdata_array.(idx)=TYPE_GFDATA_NULL);
					Array.set gfdata_array idx gfd;
				end in
				Hashtbl.iter proc_gfdata_hash gfdata_hash;
			end
		end;

		(*building gfmod_array*)
		let proc_flat_array tf = begin
			match tf with
			TYPE_FLAT_2OPGF(t2gf,modname,ztclst,atclst,btclst) -> begin
				let zidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_GF1024(ztclst))
				and aidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_GF1024(atclst))
				and bidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_GF1024(btclst))
				in 
				TYPE_GFMOD_2OPGF(t2gf,modname,zidx,aidx,bidx)
			end
			| TYPE_FLAT_1OPGF(t1gf,modname,ztclst,atclst) -> begin
				let zidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_GF1024(ztclst))
				and aidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_GF1024(atclst))
				in 
				TYPE_GFMOD_1OPGF(t1gf,modname,zidx,aidx)
			end
			| TYPE_FLAT_2OPBOOL(t2b,modname,ztc,atc,btc) -> begin
				let zidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_BOOL(ztc))
				and aidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_BOOL(atc))
				and bidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_BOOL(btc))
				in
				TYPE_GFMOD_2OPBOOL(t2b,modname,zidx,aidx,bidx)
			end
			| TYPE_FLAT_IV(modname,ztc,atc) -> begin
				let zidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_BOOL(ztc))
				and aidx=Hashtbl.find gfdata_hash (TYPE_GFDATA_BOOL(atc))
				in
				TYPE_GFMOD_IV(modname,zidx,aidx)
			end
			| _ -> assert false
		end in begin
			gfmod_array <- Array.map proc_flat_array type_flat_array;
		end
		(*expanding the noreg_toponly.v*)
	end
*)

	method isQstr str = begin
		string_match (regexp "^.*_Q$") str 0
	end

	method isQ tnet = begin
		match tnet with
		TYPE_NET_ID(str) -> self#isQstr str
		| _ -> false
	end

	method isDstr str = begin
		string_match (regexp "^.*_D$") str 0
	end
	
	method isD tnet = begin
		match tnet with
		TYPE_NET_ID(str) -> self#isDstr str
		| _ -> false
	end

	method mapname str idx = begin
		printf "mapname %s to %s_inst_%d\n" str str idx;
		sprintf "%s_inst_%d" str idx
	end

	method mapnet idx tnet = begin
		match tnet with
		TYPE_NET_ID(str) -> begin
			let newstr=self#mapname str idx 
			in
			TYPE_NET_ID(newstr)
		end
		| TYPE_NET_CONST(_) -> tnet
		| TYPE_NET_ARRAYBIT(str,id) -> begin
			let newstr=self#mapname str idx 
			in
			TYPE_NET_ARRAYBIT(newstr,id)
		end
		| TYPE_NET_NULL -> tnet
	end

	method map2prevInstanceDnet idx tnet = begin
		match tnet with
		TYPE_NET_ID(str) -> begin
			assert (idx >=1);
			let nonQstr=global_replace (regexp "_Q$") "_D" str 
			in
			TYPE_NET_ID(self#mapname nonQstr (idx-1))
		end
		| TYPE_NET_ARRAYBIT(str,idx) -> begin
			printf "map2prevInstanceDnet arr bit %s[%d]\n" str idx;
			assert false
		end
		| TYPE_NET_CONST(_) ->  tnet
		| _ -> assert false
	end

	method mapinstance idx tc = begin
		match tc with
		(tion,tnet) -> begin
			match tion with
			TYPE_CONNECTION_NET -> begin
				let newtnet=self#mapnet idx tnet
				in
				(tion,newtnet)
			end
			| TYPE_CONNECTION_IN -> begin
				if(self#isQ tnet) then begin
					(*all Q will be used as internal nets that
					connected to previous instance's D net*)
					if(idx=0) then begin
						(*for 0 instance some times I need to set init value*)
						let newtnet=self#mapnet idx tnet
						in
						(TYPE_CONNECTION_IN,newtnet)
					end
					else begin
						let newtnet=self#map2prevInstanceDnet idx tnet
						in
						(TYPE_CONNECTION_NET,newtnet)
					end
				end
				else begin
					let newtnet=self#mapnet idx tnet
					in
					(TYPE_CONNECTION_IN,newtnet)
				end
			end
			| TYPE_CONNECTION_OUT -> begin
				if(self#isD tnet) then begin
					let newtnet=self#mapnet idx tnet
					in
					(TYPE_CONNECTION_NET,newtnet)
				end
				else begin
					let newtnet=self#mapnet idx tnet
					in
					(tion,newtnet)
				end
			end
		end
	end

	method mapinstanceList idx tclst  = begin
		List.map (self#mapinstance idx) tclst
	end

	method proc_unfold_tf idx arrayPos tf = begin
		let newtf= begin
			match tf with
			(modname,instname,ztclst,atclst,btclst) -> begin
				printf "proc_unfold_tf %s %s %d\n" modname instname idx;
				let ztclst1=self#mapinstanceList idx ztclst
				and atclst1=self#mapinstanceList idx atclst
				and btclst1=self#mapinstanceList idx btclst
				and instname1=self#mapname instname idx 
				in 
				(modname,instname1,ztclst1,atclst1,btclst1)
			end
		end
		and oldLength=Array.length type_flat_array
		in
		Array.set type_flat_unfold_array (idx*oldLength+arrayPos) newtf
	end

	method proc_unfold_L2R idx lvnet rvnet = begin
		(*assignmetn on inst 0 is not need*)
		if (idx <> 0 ) then begin
			let newlvnet=self#mapnet idx lvnet
			and newrvnet=self#map2prevInstanceDnet idx rvnet
			in begin
				Hashtbl.add assignHashL2R_unfold newlvnet newrvnet;
(* 				Hashtbl.add assignHashR2L_unfold newrvnet newlvnet; *)
			end
		end
	end

	method procUnfoldInputs idx str rng = begin
		if(self#isQstr str) then begin
			(*_Q is previous register dont use it as input *)
			(*only the 0-th instance is used as init value*)
			if(idx=0) then begin
				let newstr=self#mapname str idx
				in
				Hashtbl.add hashInput_unfold newstr rng
			end
		end
		else begin
			assert ((self#isDstr str)=false);
			let newstr=self#mapname str idx
			in
			Hashtbl.add hashInput_unfold newstr rng
		end
	end

	method procUnfoldOutputs idx str rng = begin
		if(self#isDstr str) then begin
			(*_D is current register,
			use it as wire*)
			let newstr=self#mapname str idx
			in
			Hashtbl.add hashWireUnfold newstr rng
		end
		else begin
			assert ((self#isQstr str)=false);
			let newstr=self#mapname str idx
			in
			Hashtbl.add hashOutput_unfold newstr rng
		end
	end

	method unfold_boolonly_netlist unfoldNumber = begin
		printf "unfold_boolonly_netlist start\n";

		let newlength=(Array.length type_flat_array)*unfoldNumber
		in
		type_flat_unfold_array <- Array.make newlength ("","",[],[],[]);

		for i=0 to (unfoldNumber-1) do
			Array.iteri (self#proc_unfold_tf i ) type_flat_array;
		done;

		for i=0 to (unfoldNumber-1) do
			Hashtbl.iter (self#proc_unfold_L2R i ) assignHashL2R;
		done;

		for i=0 to (unfoldNumber-1) do
			Hashtbl.iter (self#procUnfoldInputs i) hashInput;
		done;

		for i=0 to (unfoldNumber-1) do
			Hashtbl.iter (self#procUnfoldOutputs i) hashOutput;
		done;

		for i=0 to (unfoldNumber-1) do
			Hashtbl.iter (self#procUnfoldWires i) circuit_hst;
		done;

	end

	method procUnfoldWires idx key cont = begin
		match cont#get_obj with
		Tobj_net_declaration(rng) -> begin
			let newkey=self#mapname key idx
			in
			Hashtbl.add hashWireUnfold newkey rng
		end
		| _ -> ()
	end

	method handleAssignment = begin
		let procCheckAssignment conAss = begin
			match conAss with
			T_assignment(lv,exp) -> begin
				let lv_tnet= begin
					match lv with
					T_lvalue_id([str]) -> begin
						assert (self#isOutput str);
						TYPE_NET_ID(str)
					end
					| T_lvalue_arrbit([str],idxexp) -> begin
						if ( (self#isOutput str )=false) then begin
							printf "%s[%d]\n" str (Expression.exp2int_simple idxexp);
							flush stdout;
							assert false;
						end;
						let idx=Expression.exp2int_simple idxexp
						in
						TYPE_NET_ARRAYBIT(str,idx)
					end
					|_ -> assert false
				end
				and rv_tnet=begin
					match exp with
					T_primary(T_primary_id([str])) -> begin
						assert(self#isInput str);
						assert(self#isQstr str);
						TYPE_NET_ID(str)
					end
					| T_primary(T_primary_arrbit([str],idxexp)) -> begin
						assert (self#isInput str);
						assert(self#isQstr str);
						let idx=Expression.exp2int_simple idxexp
						in
						TYPE_NET_ARRAYBIT(str,idx)
					end
					| T_primary(T_primary_num(T_number_base(1,'b',"0"))) -> 
						TYPE_NET_CONST(0)
					| T_primary(T_primary_num(T_number_base(1,'b',"1"))) -> 
						TYPE_NET_CONST(1)
					| _ -> assert false
				end
				in
				begin
					Hashtbl.add assignHashL2R lv_tnet rv_tnet;
					Hashtbl.add assignHashR2L rv_tnet lv_tnet;
				end
			end
		end
		in
		List.iter procCheckAssignment cont_ass_list;
		
		let procAB2In tc = begin
			match tc with 
			(TYPE_CONNECTION_OUT,tnet) -> begin
				try
					let rv= Hashtbl.find assignHashL2R tnet
					in
					(TYPE_CONNECTION_IN,rv)
				with Not_found -> begin
					printf "Warning :out not from assignment\n";
					self#print_type_net tnet;
					flush stdout;
					tc
				end
			end
			| _ -> tc
		end
		in
		let procOutputABtoInput idx tf = begin
			let newtf= begin
				match tf with
				(modname,instname,ztclst,atclst,btclst) -> begin
					let atclst1=List.map procAB2In atclst
					and btclst1=List.map procAB2In btclst
					in
					(modname,instname,ztclst,atclst1,btclst1)
				end
			end
			in
			Array.set type_flat_array idx newtf
		end
		in
		Array.iteri procOutputABtoInput type_flat_array;
	end

	method getTypeName2opgf typ = begin
		match typ with
		GFADD -> "gfadd_mod"
		| GFMULTFLAT -> "gfmult_flat_mod"
		| GFMULT -> "gfmult_mod"
		| GFDIV -> "gfdiv_mod"
	end

	method getTypeName1opgf typ = begin
		match typ with
		TOWER2FLAT -> "tower2flat"
		| FLAT2TOWER -> "flat2tower"
	end

	method getTypeName2opbool typ =begin
		match typ with
		EO -> "EO"
		| AN2 -> "AN2"
		| OR2 -> "OR2"
	end

	method is2OpBool modname = begin
		match modname with
		"EO"|"AN2"|"OR2" -> true
		| _ -> false
	end

	method is1OpBool modname = begin
		match modname with
		"IV" -> true
		| _ -> false
	end

	method is0Op modname = begin
		match modname with
		"" -> true
		| _ -> false
	end

	method writeFlattenNetlist = begin
		let flatNetlist=open_out  "flat.v"
		in begin
			fprintf flatNetlist "module %s(\n" name;
			Hashtbl.iter (self#procOutput flatNetlist) hashOutput ;
			Hashtbl.iter (self#procInput flatNetlist) hashInput ;
			fprintf flatNetlist "  input xx\n);\n";
			(*wires*)
			Hashtbl.iter (self#print_wire flatNetlist) circuit_hst;
			(*assignments*)
			Hashtbl.iter (self#procPrintAssign flatNetlist) assignHashL2R;
			(*module*)
			Array.iter (self#procPrintModule flatNetlist)  type_flat_array;
			fprintf flatNetlist "endmodule\n";
			close_out flatNetlist;
		end
	end

	method procInput flatNetlist str rng = begin
		match rng with
		T_range_NOSPEC ->
			fprintf flatNetlist "  input %s,\n" str
		| _ -> begin
			let (l,r)=rng2lr rng
			in
			fprintf flatNetlist "  input [%d:%d] %s,\n" l r str;
		end
	end

	method procOutput flatNetlist str rng = begin
		match rng with
		T_range_NOSPEC -> 
			fprintf flatNetlist "  output %s,\n" str;
		| _ -> begin
			let (l,r)=rng2lr rng
			in
			fprintf flatNetlist "  output [%d:%d] %s,\n" l r str;
		end
	end

	method print_wire flatNetlist key cont = begin
		match cont#get_obj with
		Tobj_net_declaration(rng) -> begin
			fprintf flatNetlist "   wire ";
			print_v_range flatNetlist rng;
			fprintf flatNetlist "   %s ; \n" key
		end
		| _ -> ()
	end

	method procPrintAssign flatNetlist lvnet rvnet = begin
		fprintf flatNetlist "  assign ";
		begin
			match lvnet with
			TYPE_NET_ID(str) -> 
				fprintf flatNetlist " %s = " str;
			| TYPE_NET_ARRAYBIT(str,idx) ->
				fprintf flatNetlist " %s[%d] = " str idx
			| _ -> assert false
		end
		;
		begin
			match rvnet with
			TYPE_NET_ID(str) ->
				fprintf flatNetlist " %s ;\n" str
			| TYPE_NET_ARRAYBIT(str,idx) ->
				fprintf flatNetlist " %s[%d] ;\n" str idx
			| TYPE_NET_CONST(i) -> 
				fprintf flatNetlist " %d ;\n" i
			| _ -> assert false
		end
	end

	method  procPrintModule flatNetlist tf = begin
		let printTC tc = begin
			match tc with
			(_,TYPE_NET_ID(str)) -> 
				fprintf flatNetlist "%s" str
			| (_,TYPE_NET_ARRAYBIT(str,idx)) ->
				fprintf flatNetlist "%s[%d]" str idx
			| (_,TYPE_NET_CONST(i)) -> begin	
				assert (i=1||i=0);
				fprintf flatNetlist "1'b%d" i
			end
			| _ -> assert false
		end
		in
		let rec printTCL tcl = begin
			match tcl with
			[hd] -> printTC hd
			| hd::tl -> begin
				printTC hd;
				fprintf flatNetlist ",";
				printTCL tl;
			end
			| _ -> assert false
		end
		in
		match tf with
		(modname,inm,ztcl,atcl,btcl) -> begin
			if((self#is2OpGF modname) || (self#is2OpBool modname)) then begin
				fprintf flatNetlist "  %s %s (\n" modname inm;

				fprintf flatNetlist ".Z({";
				printTCL ztcl;
				fprintf flatNetlist "}),\n";

				fprintf flatNetlist ".A({";
				printTCL atcl;
				fprintf flatNetlist "}),\n";

				fprintf flatNetlist ".B({";
				printTCL btcl;
				fprintf flatNetlist "})\n";

				fprintf flatNetlist ");\n";
			end
			else if((self#is1OpGF modname) || (self#is1OpBool modname)) then begin
				fprintf flatNetlist "%s %s (\n" modname inm;

				fprintf flatNetlist ".Z({";
				printTCL ztcl;
				fprintf flatNetlist "}),\n";

				fprintf flatNetlist ".A({";
				printTCL atcl;
				fprintf flatNetlist "})\n";

				fprintf flatNetlist ");\n";
			end
			else if(self#is0Op modname) then  ()
			else assert false
		end
	end

	method print_wire_unfold flatNetlist str rng = begin
		fprintf flatNetlist "   wire ";
		print_v_range flatNetlist rng;
		fprintf flatNetlist "   %s ; \n" str;
	end

	method writeUnfoldNetlist = begin
		let flatNetlist=open_out  "unfold.v"
		in begin
			fprintf flatNetlist "module %s_unfold(\n" name;
			Hashtbl.iter (self#procOutput flatNetlist) hashOutput_unfold ;
			Hashtbl.iter (self#procInput flatNetlist) hashInput_unfold ;
			fprintf flatNetlist "  input xx\n);\n";
			(*wires*)
			Hashtbl.iter (self#print_wire_unfold flatNetlist) hashWireUnfold;
			(*assignments*)
			Hashtbl.iter (self#procPrintAssign flatNetlist) assignHashL2R_unfold;
			(*module*)
			Array.iter (self#procPrintModule flatNetlist)  type_flat_unfold_array;
			fprintf flatNetlist "endmodule\n";
			close_out flatNetlist;
		end
	end
	
	
	method chkProperTF tf = begin
		match tf with
		("AN2",instname,[ztc],[atc],[btc]) -> ()
		| ("OR2",instname,[ztc],[atc],[btc]) ->()
		| ("EO" ,instname,[ztc],[atc],[btc]) -> ()
		| ("IV" ,instname,[ztc],[atc],[]) -> ()
		| ("gfmult_mod" ,instname,ztcl,atcl,btcl) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
			assert ((List.length btcl)=10);
		end
		| ("gfmult_flat_mod" ,instname,ztcl,atcl,btcl) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
			assert ((List.length btcl)=10);
		end
		| ("gfdiv_mod" ,instname,ztcl,atcl,btcl) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
			assert ((List.length btcl)=10);
		end
		| ("gfadd_mod" ,instname,ztcl,atcl,btcl) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
			assert ((List.length btcl)=10);
		end
		| ("tower2flat" ,instname,ztcl,atcl,[]) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
		end
		| ("flat2tower" ,instname,ztcl,atcl,[]) -> begin
			assert ((List.length ztcl)=10);
			assert ((List.length atcl)=10);
		end
		| ("","",[],[],[]) -> ()
		| (modname,instname,ztcl,atcl,btcl) -> begin
			printf "modname %s\n" modname;
			printf "instname %s\n" instname;
			printf "zlen %d\n" (List.length ztcl);
			printf "alen %d\n" (List.length atcl);
			printf "blen %d\n" (List.length btcl);
			if((snd (List.hd btcl))=TYPE_NET_NULL) then begin
				printf "btc is TYPE_NET_NULL\n";
			end;
			flush stdout;
			assert false
		end
	end

	method addHashTnetValue tn1 tn2 = begin
		let newtn2=self#getHashTnetValue tn2
		in
		Hashtbl.add hashTnetValue tn1 newtn2
	end

	method getHashTnetValue tn =begin
		match tn with
		TYPE_NET_CONST(_) -> tn
		| _ -> begin
			try 
				let newtn=Hashtbl.find hashTnetValue tn 
				in begin
(*
					printf "\n getnewtn from \n";
					self#print_type_net tn;
					printf "\n to \n";
					self#print_type_net newtn;
*)
					newtn
				end
			with Not_found -> begin
(*
				printf "\n fail on\n";
				self#print_type_net tn;
				printf "\n";
*)
				tn
			end
		end
	end

	method getNewTcl tcl =begin
		let maptc tc =begin
			match tc with
			(tion,tn) ->
				let newtn=self#getHashTnetValue tn
				in
				(tion,newtn)
		end
		in 
		List.map maptc tcl
	end

	method propagateConstance_Hash2Array = begin
		(*first propagate the value in hashTnetValue 
		to type_flat_unfold_array*)
		let procTFArray pos tf =begin
(* 			self#chkProperTF tf; *)
			match tf with
			(modname,inm,ztcl,atcl,btcl) -> begin
				let atcl1=self#getNewTcl atcl
				and btcl1=self#getNewTcl btcl
				in
				if((atcl1<>atcl) || (btcl1<>btcl)) then begin
					let newtf=(modname,inm,ztcl,atcl1,btcl1)
					in begin
						printf "\npush to %s %s\n" modname inm;
						if(atcl1<>atcl) then begin
							printf "\nold a ";
							List.iter (self#print_type_connection) atcl;
							printf "\nnew a ";
							List.iter (self#print_type_connection) atcl1;
						end;
						if(btcl1<>btcl) then begin
							printf "\nold b ";
							List.iter (self#print_type_connection) btcl;
							printf "\nnew b ";
							List.iter (self#print_type_connection) btcl1;
						end;
						Array.set type_flat_unfold_array pos newtf
					end
				end
			end
		end
		in
		Array.iteri procTFArray type_flat_unfold_array;
	
		let newhsh=Hashtbl.create 1000
		in
		let procAssign l r = begin
			let newr=self#getHashTnetValue r
			in
			if(newr<>r) then begin
				Hashtbl.add newhsh l newr
			end
		end
		in
		let procAdd l r = begin
			Hashtbl.replace assignHashL2R_unfold l r
		end
		in 
		begin
			Hashtbl.iter procAssign assignHashL2R_unfold;
			Hashtbl.iter procAdd newhsh;
		end

	end

	method propagateConstance  = begin
		let modified= ref true
		and tn2tnList=ref []
		in 
		begin
			let procTFArrayIn2Out pos tf = begin
				self#chkProperTF tf;
				match tf with
				("AN2",instname,[(ztion,ztn)],[(ation,atn)],[(btion,btn)]) -> begin
					if((atn=TYPE_NET_CONST(0)) || (btn=TYPE_NET_CONST(0))) then begin
						(*z is always 0*)
						printf "removing AN2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==0\n becaue of\n";
						self#print_type_connection (ation,atn);
						printf "\n";
						self#print_type_connection (btion,btn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,TYPE_NET_CONST(0))::(!tn2tnList);
						modified := true;
					end
					else if(atn=TYPE_NET_CONST(1)) then begin
						(*z is always b*)
						printf "removing AN2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==";
						self#print_type_connection (btion,btn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,btn)::(!tn2tnList);
						modified := true;
					end
					else if(btn=TYPE_NET_CONST(1)) then begin
						printf "removing AN2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==";
						self#print_type_connection (ation,atn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,atn)::(!tn2tnList);
						modified := true;
					end
				end
				| ("OR2",instname,[(ztion,ztn)],[(ation,atn)],[(btion,btn)]) -> begin
					if((atn=TYPE_NET_CONST(1)) || (btn=TYPE_NET_CONST(1))) then begin
						(*z is always 1*)
						printf "removing OR2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==0\n becaue of\n";
						self#print_type_connection (ation,atn);
						printf "\n";
						self#print_type_connection (btion,btn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,TYPE_NET_CONST(1))::(!tn2tnList);
						modified := true;
					end
					else if(atn=TYPE_NET_CONST(0)) then begin
						(*z is always b*)
						printf "removing OR2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==";
						self#print_type_connection (btion,btn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,btn)::(!tn2tnList);
						modified := true;
					end
					else if(btn=TYPE_NET_CONST(0)) then begin
						printf "removing OR2 %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==";
						self#print_type_connection (ation,atn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,atn)::(!tn2tnList);
						modified := true;
					end
				end
				| ("IV",instname,[(ztion,ztn)],[(ation,atn)],_) -> begin
					if(atn=TYPE_NET_CONST(1)) then begin
						(*z is always 0*)
						printf "removing IV %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==0\n";
						self#print_type_connection (ation,atn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,TYPE_NET_CONST(0))::(!tn2tnList);
						modified := true;
					end
					else if(atn=TYPE_NET_CONST(0)) then begin
						(*z is always 1*)
						printf "removing IV %s\n" instname;
						self#print_type_connection (ztion,ztn);
						printf "==1\n";
						self#print_type_connection (ation,atn);
						printf "\n";
						Array.set type_flat_unfold_array pos ("","",[],[],[]);
						tn2tnList := (ztn,TYPE_NET_CONST(1))::(!tn2tnList);
						modified := true;
					end
				end
				| _ -> ()
			end
			in begin
				while(!modified) do
					(*record whether there is modification 
					in procTFArrayIn2Out*)
					modified := false;
					(*propagate the values from hashTnetValue 
					to type_flat_unfold_array's inputs*)
					self#propagateConstance_Hash2Array;
					(*propagate the values from type_flat_unfold_array's
					input to outputi, and record them in tn2tnList*)
					Array.iteri procTFArrayIn2Out type_flat_unfold_array;
					(*convert tn2tnList to hashTnetValue*)
					let procTN2Hash x = begin
						match x with
						(tn1,tn2) ->
							self#addHashTnetValue tn1 tn2
					end
					in
					List.iter procTN2Hash (!tn2tnList);
					tn2tnList := [];
				done
			end
		end
	end
	
	method handleInputStepList stepList = begin
		let procStringInt idx x = begin
			match x with
			(str,arridx,i) -> begin
				assert (i=0 || i=1);
				let newstr=self#mapname str idx 
				in
				let tnet=begin
					if(arridx<0) then begin
						printf "adding %s = %d\n" newstr i;
						TYPE_NET_ID(newstr)
					end
					else begin
						printf "adding %s[%d] = %d\n" newstr arridx i;
						TYPE_NET_ARRAYBIT(newstr,arridx)
					end
				end
				in 
				Hashtbl.add hashTnetValue tnet (TYPE_NET_CONST(i))
			end
		end
		in
		let procStep i stp = begin
			List.iter (procStringInt i) stp;
		end
		in
		let rec procStepList i stpl= begin
			match stpl with
			[] ->()
			| hd::tl -> begin
				procStep i hd;
				procStepList (i+1) tl;
			end
		end
		in 
		procStepList 0 stepList
	end

	method checkUnfold = begin
		let drivingTNHash= Hashtbl.create 10000000
		in
		let procDriving tf = begin
			match tf with
			(_,_,ztcl,_,_) -> begin
				let procTC tc= begin
					match tc with
					(_,tn) -> 
						Hashtbl.add drivingTNHash tn true
				end
				in
				List.iter procTC ztcl
			end
		end
		in
		let procInput str rng = begin
			match rng with
			T_range_NOSPEC -> 
				Hashtbl.add drivingTNHash (TYPE_NET_ID(str)) true
			| _ -> ()
		end
		in
		let isUnfoldInput tn = begin
			match tn with
			TYPE_NET_ID(str) -> 
				Hashtbl.mem hashInput_unfold str;
			| TYPE_NET_ARRAYBIT(str,idx) ->
				Hashtbl.mem hashInput_unfold str;
			| _ -> false
		end
		in
		let procDriven tf = begin
			match tf with
			(modname,instname,_,atcl,btcl) -> begin
				let procTC tc = begin
					match tc with
					(_,tn) -> 
						if((Hashtbl.mem drivingTNHash tn)=false ) then
						begin
							if(tn<>TYPE_NET_NULL && tn<>(TYPE_NET_CONST(0)) && tn<>(TYPE_NET_CONST(1)) && (isUnfoldInput tn)=false) then begin
								printf "\n UNDRIVEN net of modname %s instname %s\n" modname instname;
								self#print_type_connection tc;
								flush stdout;
							end
						end
				end
				in begin
					List.iter procTC atcl;
					List.iter procTC btcl;
				end
			end
		end
		in 
		begin
			Array.iter procDriving type_flat_unfold_array;
			Hashtbl.iter procInput hashInput_unfold;
			Array.iter procDriven  type_flat_unfold_array;
		end
	end

	method compsyn stepList unfoldNumber = begin
		
		(*first construct the data structure with bool only*)
		self#construct_boolonly_netlist ;
(*
		printf "cheking 0\n";
		flush stdout;
		Array.iter (self#chkProperTF) type_flat_array;
*)

		(*make sure all assign are from *_Q input to real output
		and for each module's input, 
		if it is the destination of some assign, 
		then replace it with that *_Q input*)
		self#handleAssignment;

 		self#writeFlattenNetlist; 

		(* unfold it 		 *)
		self#unfold_boolonly_netlist unfoldNumber ;


		assert ( (List.length seq_always_list)=0);
		assert ( (List.length comb_always_list)=0);

		(*convert all input step list to wire value*)
(*
		printf "cheking 1\n";
		flush stdout;
		Array.iter (self#chkProperTF) type_flat_unfold_array;
		printf "cheking 2\n";
		flush stdout;
*)
		self#handleInputStepList stepList;
		self#propagateConstance ;

		
		self#writeUnfoldNetlist;
		self#checkUnfold;
	end

	method genDecoderFunction iv shift ov instCNF = begin
		let maxidxR=get_largest_varindex_inclslst instCNF in 
		let shiftedIV=List.map (fun x -> x+shift) iv in 
		let clslst_shift = begin
			List.iter (fun x -> assert(x<=maxidxR)) shiftedIV;
			List.iter (fun x -> assert(x<=maxidxR)) ov;
			shiftclslst instCNF ov maxidxR
		end 
		in 
		characterization_interp_AB_mass iv shift instCNF clslst_shift maxidxR ov
	end

	method bitnamelst2namerangelst bitlst = begin
		let spl x = begin
			let nm = self#idx2name x in 
			let spllst = split (regexp "\[\|\]") nm in begin 
				(*although this may leas to warning in compilation,
					but it is actually necessary to regexp*)
				match spllst with
				[] -> assert false;
				|[nmm] -> begin
					assert(nm = nmm);
					(nm,-1)
				end
				|[nmm;value] -> begin
					(nmm,(int_of_string value))
				end
				|_ -> assert false
			end
		end in
		let dividedNameRangelst = List.map spl bitlst in
		let rec genarray dnrlst res = begin
			match dnrlst with 
			[] -> res
			|dnr::dnrtl -> begin
				match dnr with
				(nm,-1) -> begin
					genarray dnrtl ((nm,[])::res)
				end
				|(nm,v) -> begin
					assert(v>=0);
					let (elst,nelst)= List.partition (fun x -> match x with (nm2,_) -> nm2= nm) res in begin
						match elst with
						[] -> begin
							genarray dnrtl ((nm,[v])::res)
						end
						|[(nm2,vl2)] -> begin
							assert (nm = nm2);
							genarray dnrtl ((nm,(v::vl2))::nelst)
						end
						|_ -> assert false
					end
				end
			end
		end in
		let nameidxlstlst = genarray dividedNameRangelst [] in
		List.map (fun x -> match x with (nm,[]) -> (nm,-1,-1) | (nm,vlst)-> let (l,r)= Intlist.list2lr vlst in (nm,l,r)) nameidxlstlst 
	end


	method getVisitedPosList  arr_itpo = begin
			let size = Array.length arr_itpo in
			let visitedPosArray = Array.make size false in
			let frontie=ref [] 
			in
			let rec interpObj2str interpObj = begin
				match interpObj with
				TiterpCircuit_true -> ()
				| TiterpCircuit_false -> ()
				| TiterpCircuit_refcls(clsidx) -> begin
					assert(clsidx<size);
					if((Array.get visitedPosArray clsidx)==false) then begin
						Array.set visitedPosArray clsidx true;
						frontie := clsidx :: (!frontie) ;
					end
				end
				| TiterpCircuit_refvar(varidx) -> ()
				| TiterpCircuit_and(interpObjlst) -> begin
					List.iter (interpObj2str ) interpObjlst
				end
				| TiterpCircuit_or(interpObjlst) -> begin
					List.iter (interpObj2str ) interpObjlst
				end
				| TiterpCircuit_not(interpObj) -> begin
					interpObj2str interpObj
				end
				| TiterpCircuit_printed(clsidx) -> assert false
				| _ -> assert false
			end
			in begin
				(*insert size-1 into the frontie*)
				Array.set visitedPosArray (size -1) true;
				frontie := [size-1] ;

				while ((isEmptyList (!frontie)) ==false) do
					let curF=List.hd (!frontie) in begin
						frontie := List.tl (!frontie);
						(*pop out the first element of frontie*)
						interpObj2str (Array.get arr_itpo curF);
					end
				done;

				let arrayIX= (Array.mapi (fun i x  ->  (i,x)) visitedPosArray) in
				let listIX=Array.to_list arrayIX in
				List.map fst (List.filter snd listIX )
			end
	end


	method generateDecoderVerilog prefix left right idx2decfunList = begin
		let decoderVerilog = open_out "resulting_dual_cnf.v" 
		and bvo = self#bitnamelst2namerangelst bv_outstrlist 
		and bvi = self#bitnamelst2namerangelst bv_instrlist 
		in begin
			fprintf decoderVerilog  "module resulting_dual(\n";

			(*generating input specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
			end in
			List.iter prtbit bvo;

			(*generating output specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "  %s,\n" nm
				end
			end in
			List.iter prtbit bvi;

			fprintf decoderVerilog  "  clk);\n";


			(*generating input specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "input  %s;\n" nm;
					fprintf decoderVerilog "wire   cycle%d_%s ;\n" (prefix+left+right) nm;
					fprintf decoderVerilog "assign   cycle%d_%s =%s;\n" (prefix+left+right) nm nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "input [%d:%d]  %s;\n" l r nm;
					fprintf decoderVerilog "wire  [%d:%d]  cycle%d_%s ;\n" l r (prefix+left+right) nm ;
					fprintf decoderVerilog "assign  cycle%d_%s =%s;\n"  (prefix+left+right) nm nm
				end
			end in
			List.iter prtbit bvo;

			(*generating output specification*)
			let prtbit x = begin
				match x with 
				(nm,-1,r) -> begin
					assert (r =(-1));
					fprintf decoderVerilog "output  %s;\n" nm
				end
				| (nm,l,r) -> begin
					assert(l!=(-1));
					assert(r!=(-1));
					fprintf decoderVerilog "output [%d:%d]  %s;\n" l r nm
				end
			end in
			List.iter prtbit bvi;

			fprintf decoderVerilog  "input  clk;\n";

			(*generaing the pipelined registers*)
			if(prefix<=(prefix+left+right-1)) then begin
  			let lrlst = lr2list prefix (prefix+left+right-1) in begin
  				let prtbit frm x = begin
  					match x with 
  					(nm,-1,r) -> begin
  						assert (r =(-1));
  						fprintf decoderVerilog "reg  cycle%d_%s;\n" frm nm
  					end
  					| (nm,l,r) -> begin
  						assert(l!=(-1));
  						assert(r!=(-1));
  						fprintf decoderVerilog "reg [%d:%d]  cycle%d_%s;\n" l r frm nm
  					end
  				end in
  				List.iter (fun frm -> (List.iter (prtbit frm) bvo) ) lrlst
  			end
  			;
  			let lrlst = lr2list prefix (prefix+left+right-1) in begin
  				let prtbit frm x = begin
  					match x with
  					(nm,_,_) -> begin
  						fprintf decoderVerilog "always @(posedge clk) begin\n";
  						fprintf decoderVerilog "  cycle%d_%s <= cycle%d_%s;\n" frm nm (frm+1) nm;
  						fprintf decoderVerilog "end\n\n";
  					end
  				end in
  				List.iter (fun frm -> (List.iter (prtbit frm) bvo) ) lrlst
  			end
  			;
			end
			;
			let findVisited  idx2decfun = begin
				(*find out the visited pos in decfun*)
				match idx2decfun with
				(idx,decfun) -> begin
					let visitedPosList=self#getVisitedPosList decfun in
					(idx,decfun, visitedPosList)
				end
			end
			in
			let idx2decfun2VisitedList=List.map findVisited idx2decfunList in
			let prtWire idx2decfun = begin
				match idx2decfun with
				(idx,decfun,visitedPos) -> 
					List.iter (fun x -> fprintf decoderVerilog "wire w_%d_%d ;\n" idx x) visitedPos
			end in
			let prtFunction idx2decfun = begin
				match idx2decfun with
				(idx,decfun,visitedPos) -> begin
					fprintf decoderVerilog "assign %s = w_%d_%d ;\n" (self#idx2name idx) idx ((Array.length decfun)-1);
					List.iter (fun i -> self#print_itpo_verilog_file decoderVerilog (Array.get decfun i) idx i) visitedPos
				end
			end 
			in begin
				List.iter prtWire idx2decfun2VisitedList;
				List.iter prtFunction idx2decfun2VisitedList;
			end;

			fprintf decoderVerilog  "endmodule\n\n";

			close_out decoderVerilog;
		end
	end

	method arrayexists pred arr = begin
		let procpred a b = begin
			if(a == true) then true
			else if(pred b) then true
			else false
		end in
		Array.fold_left procpred false arr 
	end


	method inferPredicateUniq listUniqBitI listNonuniqBitI maxN = begin
		assert (maxN>=2);
		let b = ref (maxN-1)
		and res = ref RES_UNK
		and infered_assertion_array_lst_old_nonloop = ref []
		and infered_assertion_array_lst_old_loop = ref []
		and p = ref 0
		and l = ref 0
		and r = ref 0
		and xxx = ref (RES_UNK,0,0,0,[],[])
		in begin
			while ( (!res) != RES_UNIQ ) do
				b := (!b)+1 ;
				(*dbg_print "pre self#inferSATFormula_plr";*)
				xxx := self#inferSATFormula_plr 
									(!b) 
									(!b) 
									(!b) 
									(!infered_assertion_array_lst_old_nonloop) 
									(!infered_assertion_array_lst_old_loop) 
									listUniqBitI 
									listNonuniqBitI ;
				(*dbg_print "after self#inferSATFormula_plr";*)
				match (!xxx) with
				(res1,p1,l1,r1,infered_assertion_array_lst_old1_nonloop,infered_assertion_array_lst_old1_loop) -> begin
					res := res1 ;
					p := p1 ;
					l := l1 ;
					r := r1 ;
					infered_assertion_array_lst_old_nonloop := infered_assertion_array_lst_old1_nonloop ;
					infered_assertion_array_lst_old_loop    := infered_assertion_array_lst_old1_loop ;
				end
				;
				(*2014/11/16 Shen just for debug no need to show it here*)
				(*if((!res)!= RES_UNIQ) then begin
					assert ((List.length (!infered_assertion_array_lst_old_nonloop))!=0) ;
					let infass = begin
						if ((List.length (!infered_assertion_array_lst_old_loop))!=0) then begin
							if ((List.length (!infered_assertion_array_lst_old_nonloop))!=0) then begin
								let posass = simplify_withBDD (or_assertion (!infered_assertion_array_lst_old_nonloop)) ddM
								in
								let negass = simplify_withBDD (invert_assertion (or_assertion (!infered_assertion_array_lst_old_loop))) ddM
								in
								simplify_withBDD (and_assertion [posass;negass]) ddM
							end
							else begin
								assert false;
							end
						end
						else begin
							if ((List.length (!infered_assertion_array_lst_old_nonloop))!=0) then begin
								(*or_assertion (!infered_assertion_array_lst_old_nonloop)*)
								assert false;
							end
							else begin
								assert false;
							end
						end
					end
					in begin
						printf "the current remained configuration set : \n";
						printf "++++++++++++++++++++++++++\n";
						self#print_itpo infass;
						printf "\n++++++++++++++++++++++++++\n";
					end 
				end
				;*)
			done
			;
			(*dbg_print "end of loop"
			;*)
			((!res),(!p),(!l),(!r),(!infered_assertion_array_lst_old_nonloop),(!infered_assertion_array_lst_old_loop))
		end
	end


	
	method inferSATFormula_plr (p:int) (r:int) (l:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI = begin
		(*sent two empty list to inferSATFormula_plr_nonloop such that it can discover a whole new set to replace the current one*)
		let (result_p,infered_assertion_array_lst_new_nonloop)= self#inferSATFormula_plr_nonloop p l r infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI 
		in begin
			assert(lock_multiple == true);
			if (result_p == UNSATISFIABLE) then begin
				(*we only need to check here that 
				the assertion still have a valuation for parameters
				because the unsatisfiable assertions will also lead to the UNSAT of findLR_checkO*)
				check_clslst_maxidx clause_list_multiple last_index;

				(*2014/11/16 Shen dont simply it here to speedup*)
				(*if((List.length infered_assertion_array_lst_old_loop)>0) then begin
					let loopsimass =	simplify_withBDD (or_assertion infered_assertion_array_lst_old_loop) ddM in begin
						printf "loopsimass\n";
						self#print_itpo loopsimass;
						printf "\n";
					end;
				end;

				if((List.length infered_assertion_array_lst_new_nonloop)>0) then begin
					let nonloopsimass =	simplify_withBDD (or_assertion infered_assertion_array_lst_new_nonloop) ddM in begin
						printf "nonloopsimass\n";
						self#print_itpo nonloopsimass;
						printf "\n";
					end;
				end;*)

				check_inverted_assertion_satisfiable infered_assertion_array_lst_old_loop last_index ;
				(RES_UNIQ,p,l,r,infered_assertion_array_lst_new_nonloop,infered_assertion_array_lst_old_loop) (* output uniquely determine input*)
			end
			else begin
				let (result_p_loop,infered_assertion_array_lst_new_loop)= self#inferSATFormula_plr_loop p l r infered_assertion_array_lst_new_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI(*in this case I dont need to encode common again*)
				in begin
					assert (result_p_loop == UNSATISFIABLE) ;
					(RES_UNK,p,l,r,infered_assertion_array_lst_new_nonloop,(infered_assertion_array_lst_new_loop@infered_assertion_array_lst_old_loop))
				end
			end
		end
	end

	method inferSATFormula_plr_nonloop 
					(p:int) 
					(l:int) 
					(r:int) 
					infered_assertion_array_lst_old_nonloop 
					infered_assertion_array_lst_old_loop 
					listUniqBitI 
					listNonuniqBitI 
	= begin
		Printf.printf "  inferSATFormula_plr_nonloop : p %d l %d r %d nonloop %d loop %d\n" 
			p 
			l 
			r 
			(List.length infered_assertion_array_lst_old_nonloop) 
			(List.length infered_assertion_array_lst_old_loop);
		flush stdout;
		let target = self#construct_nonloop_bitIs 
										p 
										l 
										r  
										infered_assertion_array_lst_old_nonloop 
										infered_assertion_array_lst_old_loop 
										listUniqBitI 
										listNonuniqBitI (*TODO: dont forget to shift the variables*)
		in begin
			let res = dump_sat_withclear (([target],"target")::clause_list_multiple)
			in begin
				if(res == UNSATISFIABLE) then 
					(res,infered_assertion_array_lst_old_nonloop) (*it is ok already*)
				else begin
					let listUniqBitI_shifted = List.map (fun x -> x+(p+l)*final_index_oneinst) listUniqBitI in
					let (res1,itplst)= allsat_interp 
																clause_list_multiple 
																target 
																listUniqBitI_shifted 
																(self#construct_varlst2assumption p l r listUniqBitI) 
																ddM 
					in
					let itplst_shiftback = List.map (fun x -> shiftAssertion x (-((p+l)*final_index_oneinst))) itplst  in begin
						assert (res1== UNSATISFIABLE);
						List.iter (fun x -> check_itpo_var_membership x listUniqBitI ) itplst_shiftback;
						(SATISFIABLE,itplst_shiftback)
					end
				end
			end
		end
	end

	method construct_loop (p:int) (l:int) (r:int) target = begin
		(*this one assume all > 0*)
		assert(p>=0);
		assert(l>=0);
		assert(r>=0);
			self#set_unlock_multiple ;
			let target_loop_p = self#double_loop p l r 0 p
			and target_loop_l = self#double_loop p l r p (p+l)
			and target_loop_r = self#double_loop p l r (p+l+1) (p+l+1+r-1)
			in
			let target_all = self#alloc_index 1
			in
			let cls_red_and_all = self#encode_Red_AND target_all [target;target_loop_p;target_loop_l;target_loop_r]
			in begin
				assert (target_loop_p!= target_loop_l);
				assert (target_loop_p!= target_loop_r);
				assert (target_loop_l!= target_loop_r);
				self#append_clause_list_multiple cls_red_and_all ;
				self#set_lock_multiple ;
				target_all
			end
	end

	method construct_nonloop_bitIs (p:int) (l:int) (r:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI  = begin
		(*this one assume all > 0*)
		assert(p>=0);
		assert(l>=0);
		assert(r>=0);
		let res = self#construct_nonloop (p:int) (l:int) (r:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop in begin

		assert (Intlist.isLst1inLst2 listUniqBitI bv_instrlist);
		assert ((Intlist.isIntersect listUniqBitI listNonuniqBitI)== false);
		(*force the uniq input of p+l and p+l+1+r+p+l to be the same *)
		let ov = listUniqBitI
		in 
		let ov_0 = List.map (fun x -> x+ (p+l)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+l+1+r+p+l)*final_index_oneinst) ov
		in begin
			self#set_unlock_multiple;
			self#append_clause_list_multiple  (self#encode_EQUV (ov_0) (ov_b)) 
		end
		;
		check_clslst_maxidx clause_list_multiple last_index;

		(*force the nonuniq input of p+l and p+l+1+r+p+l to be diff*)
		(*checking that listNonuniqBitI is in bv_input*)
		assert (Intlist.isLst1inLst2 listNonuniqBitI bv_instrlist);
		let ov = listNonuniqBitI
		in 
		let ov_0 = List.map (fun x -> x+ (p+l)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+l+1+r+p+l)*final_index_oneinst) ov
		in
		self#append_clause_list_multiple  (self#encode_INEV (ov_0) (ov_b)) 
		;
		self#set_lock_multiple;
		check_clslst_maxidx clause_list_multiple last_index;

		res
		end
	end

	method construct_nonloop_1copy (p:int) (l:int) (r:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop = begin
		(*this one allow l<0 but must > -r+1*)
		Printf.printf "construct_nonloop_1copy p %d l %d r %d\n" p l r;
		flush stdout;
		assert(p>=0);
		assert(l >= -r);
		assert(r>=0);
		self#set_unlock_multiple;
		
		self#set_clause_list_multiple [];
		self#set_last_index final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		l instance for left expansion
		1 instance for current input 
		r instance for right expansion
		*2 for another expansion
		*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 (p + (max l 0) + 1 + r ))
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*constrain the assertion wire*)
		if (List.length (List.filter (self#is_assertion) name_index_lst)) > 0 then
			self#append_clause_list_multiple (self#try_assertion 0 (p+(max l 0 )+1+r-1))
		else begin
			printf "             warning : not found assertion_shengyushen\n";
			flush stdout;
		end
		;
		
		(*connect the first p+1+r instance*)
		let clslst =(self#connect_multiple_instance_step3 0 (p+(max l 0 )+r)) in begin
			self#append_clause_list_multiple  clslst ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)
		
		(*TODO : shift the assertion to proper cycle*)
		let ass_nonloop = List.map 
			(fun x -> shiftAssertion x ((p+(max l 0 ))*final_index_oneinst)) 
			infered_assertion_array_lst_old_nonloop 
		and ass_loop   = List.map 
			(fun x -> shiftAssertion x ((p+(max l 0))*final_index_oneinst)) 
			infered_assertion_array_lst_old_loop   
		in begin
			(*force the infered_assertion_array_lst_old to be invalid*)
			if((List.length ass_nonloop)!=0) then begin
				(*let orass_sim = List.map (fun x -> simplify_withBDD x ddM) ass_nonloop*)
				(*2014/11/16 Shen dont simply it here to speedup*)
				let orass_sim =  ass_nonloop
				in
				self#force_assertion (or_assertion orass_sim);
			end
			;
			List.iter (fun x -> self#force_assertion (invert_assertion x)) ass_loop;
		end
	end

	method construct_nonloop 
						(p:int) 
						(l:int) 
						(r:int) 
						infered_assertion_array_lst_old_nonloop 
						infered_assertion_array_lst_old_loop 
	= begin
		(*this one allow l<0 but must > -r+1*)
		assert(p>=0);
		(*Printf.printf "l %d r %d\n" l r; 
		flush stdout;*)
		assert(l >= -r);
		assert(r>=0);
		self#set_unlock_multiple;
		
		self#set_clause_list_multiple [];
		self#set_last_index final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		l instance for left expansion
		1 instance for current input 
		r instance for right expansion
		*2 for another expansion
		*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 ((p+(max l 0)+1+r)*2))
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*constrain the assertion wire*)
		if (List.length (List.filter (self#is_assertion) name_index_lst)) > 0 then
			self#append_clause_list_multiple (self#try_assertion 0 ((p+(max l 0 )+1+r)*2-1))
		else  begin
			printf "              warning : not found assertion_shengyushen\n";
			flush stdout;
		end
		;
		
		(*connect the first p+1+r instance*)
		let clslst =(self#connect_multiple_instance_step3 0 (p+(max l 0)+r)) in begin
			self#append_clause_list_multiple  clslst ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)
		
		(*connect the secnod p+1+r instance*)
		let clslst2=(self#connect_multiple_instance_step3 (p+(max l 0)+1+r) ((p+(max l 0)+1+r)*2-1)) in begin
			self#append_clause_list_multiple  clslst2 ;
		end;
		(*check_clslst_maxidx clause_list_multiple last_index;*)
		

		
		(*TODO : shift the assertion to proper cycle*)
		let ass_nonloop = List.map (fun x -> shiftAssertion x ((p+(max l 0))*final_index_oneinst)) infered_assertion_array_lst_old_nonloop 
		and ass_loop   = List.map (fun x -> shiftAssertion x ((p+(max l 0))*final_index_oneinst)) infered_assertion_array_lst_old_loop   in begin
			(*force the infered_assertion_array_lst_old to be invalid*)
			if((List.length ass_nonloop)!=0) then begin
				(*let orass_sim = List.map (fun x -> simplify_withBDD x ddM) ass_nonloop*)
				(*2014/11/16 Shen dont simply it here to speedup*)
				let orass_sim = ass_nonloop
				in
				self#force_assertion (or_assertion orass_sim);
			end
			;
			List.iter (fun x -> self#force_assertion (invert_assertion x)) ass_loop;
		end
		;
		(*force the output of p to p+l+1+r-1 to be the same*)
		(*here l can be negative, while above l must be larger than 0*)
		let ov = bv_outstrlist
		and outputframe_idx = lr2list (p-(min l 0)) (p+(max l 0)+1+r-1)
		in
		let ov_b_1 = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) ov) ) outputframe_idx)
		in
		let ov_b_2 = List.map (fun x -> x+(p+(max l 0)+1+r)*final_index_oneinst) ov_b_1
		in
		let (target,oclslist)= self#encode_EQUV_res ov_b_1 ov_b_2 
		in begin
			self#append_clause_list_multiple oclslist ;
			self#set_lock_multiple;
			target
		end
	end

	method inferSATFormula_plr_loop (p:int) (l:int) (r:int) infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI = begin
		Printf.printf "  inferSATFormula_plr_loop : p %d l %d r %d ass len %d\n" p l r (List.length infered_assertion_array_lst_old_loop);
		if(p<2 || l<2 || r<2) then (UNSATISFIABLE,infered_assertion_array_lst_old_loop)
		else begin
			let target = self#construct_nonloop_bitIs p l r  infered_assertion_array_lst_old_nonloop infered_assertion_array_lst_old_loop listUniqBitI listNonuniqBitI
			in 
			let target_all = self#construct_instance_loop p l r target
			in begin
				check_clslst_maxidx clause_list_multiple last_index;
				let listUniqBitI_shifted = List.map (fun x -> x+(p+l)*final_index_oneinst) listUniqBitI in
				let (res1,itplst)= allsat_interp clause_list_multiple target_all listUniqBitI_shifted (self#construct_varlst2assumption p l r listUniqBitI) ddM in
				let itplst_shiftback = List.map (fun x -> shiftAssertion x (-((p+l)*final_index_oneinst))) itplst  in  begin
					List.iter (fun x -> check_itpo_var_membership x listUniqBitI ) itplst_shiftback;
					(res1,itplst_shiftback)
				end
			end
		end
	end

	method construct_instance_loop (p:int) (l:int) (r:int) target_all_old = begin
		self#set_unlock_multiple ;
		
		let target_common = target_all_old 
		and target_loop_p = self#double_loop p l r 0 p
		and target_loop_l = self#double_loop p l r p (p+l)
		and target_loop_r = self#double_loop p l r (p+l+1) (p+l+1+r-1)
		in
		let target_all = self#alloc_index 1
		in
		let cls_red_and_all = self#encode_Red_AND target_all [target_common;target_loop_p;target_loop_l;target_loop_r]
		in begin
			assert (target_common!= target_loop_p);
			assert (target_common!= target_loop_l);
			assert (target_common!= target_loop_r);
			assert (target_loop_p!= target_loop_l);
			assert (target_loop_p!= target_loop_r);
			assert (target_loop_l!= target_loop_r);
			self#append_clause_list_multiple cls_red_and_all ;
			self#set_lock_multiple ;
			target_all
		end
	end
	
	method double_loop (p:int) (l:int) (r:int) starti endi = begin
		let dff_idxpairlst = List.filter (isdff_name_index) name_index_lst
		in
		let dff_curlst = List.map (fun x -> match x with (_,(y,_)) -> y) dff_idxpairlst
		in begin
			let lilst = lr2list starti (endi-1)
			in
			let proc_liequ li = begin
				let ov_li  = List.map (fun x -> x+ li*final_index_oneinst) dff_curlst
				and rilst = lr2list (li+1) endi
				in
				let proc_riequ ri = begin
					let ov_ri  = List.map (fun x -> x+ ri*final_index_oneinst) dff_curlst
					in
					let ov_pair_lst = List.combine ov_li ov_ri
					in
					let (res_lst,cls_lstlst) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst)
					in
					let ov_pair_lst_shift = List.map (fun x -> match x with (v1,v2) -> (v1+(p+l+1+r)*final_index_oneinst,v2+(p+l+1+r)*final_index_oneinst)) ov_pair_lst
					in
					let (res_lst_shift,cls_lstlst_shift) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst_shift)
					and rii = self#alloc_index 1
					in begin
						self#append_clause_list_multiple ((List.concat cls_lstlst) @ (List.concat cls_lstlst_shift) @ (self#encode_Red_AND rii (res_lst @ res_lst_shift))) ;
						check_clslst_maxidx clause_list_multiple last_index;
						rii
					end
				end
				in
				List.map (proc_riequ) rilst
			end
			in 
			let li_equ_var_lst = List.concat (List.map (proc_liequ) lilst)
			and riii = self#alloc_index 1
			in begin
				self#append_clause_list_multiple (self#encode_Red_OR riii li_equ_var_lst);
				check_clslst_maxidx clause_list_multiple last_index;
				riii
			end
		end
	end

	method construct_varlst2assumption (p:int) (l:int) (r:int) listUniqBitI = begin
		(*find the initial state index*)
		let dff_idxpair = List.filter (isdff_name_index) name_index_lst in
		let dff_name_list = List.map (fun x -> match x with (nm,_) -> nm) dff_idxpair in
		let initial_state_index_list = List.concat (List.map (self#name2idxlist) dff_name_list) in
		let shift2=(p+l+1+r)*final_index_oneinst in
		let initial_state_index_list2= List.map (fun x -> x+shift2) initial_state_index_list in (*find all input index*)
		let ov = bv_instrlist@bv_non_proctocol_input_list
		and cycle_list = lr2list 0 (((p+l+1+r)*2)-1) in
		let cycle_list_filtered = List.filter (fun x -> (x!=(p+l) && x!=(p+l+1+r+p+l))) cycle_list in
		let input_cycle_i i = begin
			List.map (fun x -> x + i*final_index_oneinst) ov
		end in (*expand them to every cycles*)
		let ov_all = List.concat ( List.map input_cycle_i  cycle_list_filtered) in
		let nonuniq =(Intlist.sublst bv_instrlist listUniqBitI)@bv_non_proctocol_input_list in
		let nonuniq_pl = List.map (fun x -> x+(p+l)*final_index_oneinst        ) nonuniq
		and nonuniq_pl2= List.map (fun x -> x+(p+l+1+r+p+l)*final_index_oneinst) nonuniq in begin
			(*printf "nonuniq is \n";
			List.iter (fun x -> printf "%s(%d)\n" (self#idx2name x) x) nonuniq;
			printf "\n";*)
			initial_state_index_list @ initial_state_index_list2 @ ov_all @ nonuniq_pl @ nonuniq_pl2
		end
	end

	method force_assertion arr_itpo1= begin
		let (topidx,last_index_new,clslst_2beappend)= encode_assertion arr_itpo1 last_index
		in begin(*this is the function enabler*)
			assert (topidx<= last_index_new);
			(*printf "force_assertion last_index %d last_index_new %d\n" last_index last_index_new;*)
			self#set_last_index last_index_new;
			self#append_clause_list_multiple (([topidx],"f i")::clslst_2beappend);
			check_clslst_maxidx clause_list_multiple last_index;
			()
		end
	end

	(*src_i<dst_i*)
	method connect_dffpair src_i dst_i dffpair = begin
	   if (src_i>= dst_i) then begin
		Printf.printf "connect_dffpair src_i %d must smaller than dst_i %d\n" src_i dst_i;
		exit 1
	   end
	   else begin
		match dffpair with
		(nm,(current_idx,next_index)) -> begin
			(*make sure it is actually dff*)
			(*if self#isdff nm then begin*)
				let current_off = dst_i*final_index_oneinst
				and next_off   = src_i*final_index_oneinst
				in
				let new_current_idx = current_off+current_idx
				and new_next_index = next_off+next_index
				in 
				let (rli,rlr)= rng2lr (self#name2range nm)
				in
				let (rli_real_cur,rlr_real_cur)= rng2lr (construct_range_onidx new_current_idx rli rlr)
				and (rli_real_nxt,rlr_real_nxt)= rng2lr (construct_range_onidx new_next_index rli rlr)
				in begin
					if (rli_real_cur == new_current_idx) && (new_current_idx-new_next_index == final_index_oneinst*(dst_i-src_i)-(abs(rlr-rli)+1)) && (rli_real_cur-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1== rli_real_nxt) then begin
						(*encode every bit in this range*)
						let rec connect_1bitdff idxi idxr = begin
							if idxi>idxr then []
							else begin
								let oldcl = connect_1bitdff (idxi+1) idxr
								and newmapped = (self#encode_EQU idxi (idxi-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1))
								in
								let newmapped_commented = List.map (setcomment (sprintf "connecting dff %s from instance %d to %d" nm src_i dst_i)) newmapped 
								in
								newmapped_commented @ oldcl
							end
						end
						in
						connect_1bitdff rli_real_cur rlr_real_cur
					end
					else begin
						Printf.printf "fatal error : improper connect_dffpair\n";
						Printf.printf "rli_real_cur %d\n" rli_real_cur;
						Printf.printf "rlr_real_cur %d\n" rlr_real_cur;
						Printf.printf "new_current_idx %d\n" new_current_idx;
						Printf.printf "new_next_index %d\n" new_next_index;
						Printf.printf "rlr %d\n" rlr;
						Printf.printf "rli %d\n" rli;
						Printf.printf "final_index_oneinst %d\n" final_index_oneinst;
						Printf.printf "rli_real_nxt %d\n" rli_real_nxt;
						Printf.printf "rlr_real_nxt %d\n" rlr_real_nxt;
						exit 1
					end
				end
			(*end
			else begin
				Printf.printf "fatal error : it should be dff\n";
				exit 1
			end*)
		end
	   end
	end


	(*to connect next state of one instance to current state of last instance*)
	method connect_multiple_instance_step3 start_bound end_bound = begin
		let dff_idxpair = List.filter (isdff_name_index) name_index_lst
		in 
		let connect_inst i = begin
			assert (i < end_bound);
			let connect_current_instance = List.map (self#connect_dffpair i (i+1)) dff_idxpair in
			List.concat connect_current_instance
		end
		in begin
			assert(end_bound>start_bound);
			let lstConnect = lr2list start_bound (end_bound-1) in 
			let clslstList = List.map connect_inst lstConnect in
			List.concat clslstList
		end
	end


	method encode_instance ii = begin
		let off = ii*final_index_oneinst
		in 
		let cls_off offf cls = begin
			let lit_off offff lit = begin
				if lit > 0 then lit+offff
				else lit -offff
			end
			in
			(List.map (lit_off offf) (fst cls)),(snd cls)
			(* avoiding adding comment to save time *)
			(*appendcomment (cat_string "instance " (string_of_int ii)) ((List.map (lit_off offf) (fst cls)),(snd cls)) *)
		end
		in
		List.map (cls_off off) clause_list
	end

	(*generate multiple instance, which bound is the number*)
	method gen_multiple_instance_step2 num = begin
		let lrlst = lr2list 0 (num-1)
		in
		let clslst_lst = List.map (self#encode_instance) lrlst
		in
		((List.concat clslst_lst),(final_index_oneinst*num))
	end

	(* encoding the transition relation*)
	method encode_oneInstance2SAT_step1  = begin
		(*index for explictly named vars, such as input output wire reg dff*)
		self#encode2SAT_explictname;
		(*this is the true encode*)

		(*Printf.printf "start to do 1 encode2SAT_explictname \n" ;*)


		(*encode the seq_always_list*)
		let seq_clslst = self#encode2SAT_seq_always_list truepred
		and comb_clslst = self#encode2SAT_comb_always_list truepred
		and cont_clslst = self#encode2SAT_contass_list
		in
		seq_clslst@comb_clslst@cont_clslst
	end
	
	method encode2SAT_contass_list = begin
		(*Printf.printf "start to do 1 encode2SAT_contass_list \n" ;*)
		List.concat (List.map (self#encode_ass) cont_ass_list)
	end
	
	method encode_ass ass = begin
		match ass with
		T_assignment(lv,exp) -> begin
			let truepred =1
			in 
			self#encode_nba_incomb (T_non_blocking_assignment_direct(lv,exp)) truepred
		end
	end
	
	method encode2SAT_comb_always_list envpred = begin
		(*Printf.printf "start to do 1 encode2SAT_comb_always_list \n" ;*)
		let encode_comb_always comb_always = begin
			match comb_always with
			(stat,_) -> self#encode_statement_incomb envpred stat   
		end
		in
		List.concat (List.map encode_comb_always comb_always_list)
	end
	
	method encode_statement_incomb envpred stat = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_incomb dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_incomb nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predclslst)= self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex ,(self#encode_Red_AND oldindex [envpred;expidx] ))
				end
				in
				newpred_clslst @ (self#encode_statement_incomb newpred stat_sub  ) @ predclslst
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predclslst)= self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in 
				let thenpredclslist = self#encode_Red_AND thenpred [envpred;expidx1] 
				and elsepredclslist = self#encode_Red_AND elsepred [envpred;expidx2] 
				in 
				predclslst @ thenpredclslist @ elsepredclslist @ (self#encode_statement_incomb thenpred stat1) @ (self#encode_statement_incomb elsepred stat2 )
			end
		end
		| T_case_statement(exp,cilst) -> begin
			let rec case2ifelse cl = begin
				match cl with
				[] -> begin
					Printf.printf "fatal error : you should not reach [] in case statement\n";
					exit 1
				end
				| [T_case_item_normal(explst,st1);T_case_item_default(stlast)] -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,stlast)
				end
				| (T_case_item_normal(explst,st1))::tl -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,(case2ifelse tl))
				end
				| _ -> begin
					Printf.printf "fatal error : you should not reach here in case statement\n";
					exit 1
				end
			end
			in
			self#encode_statement_incomb envpred (case2ifelse cilst)
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_incomb envpred) statlst  )
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	
	method encode2SAT_seq_always_list envpred = begin
		(*Printf.printf "start to do 1 encode2SAT_seq_always_list \n" ;*)
		let encode_seq_always seq_always = begin
			match seq_always with
			(stat,_) -> self#encode_statement_inseq envpred stat   
		end
		in
		List.concat (List.map encode_seq_always seq_always_list)
	end
	
	method encode_nba_incomb nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_incomb only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)= self#encode_exp exp
			and lvidx_lst = self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_incomb lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen = min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common = Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common = Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst = List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method encode_statement_inseq envpred stat  = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_inseq nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predcl)= self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex,(self#encode_Red_AND oldindex [envpred;expidx]))
				end
				in 
				predcl @ newpred_clslst @ (self#encode_statement_inseq newpred stat_sub)
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predcl)= self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in begin
					let thenpredclslist = self#encode_Red_AND thenpred [envpred;expidx1] 
					and elsepredclslist = self#encode_Red_AND elsepred [envpred;expidx2] 
					in 
					predcl @ (thenpredclslist @ elsepredclslist) @ (self#encode_statement_inseq thenpred stat1) @ (self#encode_statement_inseq elsepred stat2 )
				end
			end
		end
		| T_case_statement(exp,cilst) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_case_statement\n";
			exit 1
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_inseq envpred) statlst)
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	(*return positive , negative index and clause list*)
	method encode_pred exp = begin
		let (idxlst,cl)= self#encode_exp exp
		in 
		let idx = begin
			match idxlst with
			[pred] -> pred
			| _ -> begin
				Printf.printf "fatal error : invalid length of encode_pred\n";
				exit 1
			end
		end
		in 
		(*negative relationship*)
		let oldindex = self#alloc_index 1
		in
		(idx,oldindex,(self#encode_NEQ idx oldindex)@cl)
	end
	(*return the list of exp bit and list of clause*)
	method encode_prim prim = begin
		match prim with
		T_primary_num(num) -> self#encode_number num 
		| T_primary_id([name]) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1  (*even for a dff, prim will always use current state*)
			end
			and rng = self#name2range name
			in 
			((rng_baseidx_2_idxlist rng baseidx),[])
		end
		| T_primary_id([]) -> begin
			Printf.printf "fatal error : not supported T_primary_id with zero string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_id(idlst) -> begin
			Printf.printf "fatal error : not supported T_primary_id with multiple string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1
			end
			and rng = self#name2range name
			and off = Expression.exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)= rng2lr rng
					in 
					([offset2idx left right baseidx off],[])
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_primary_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,_)= List.assoc name name_index_lst
				in  x1
			end
			and rng = self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst = lr2list li ri
			and (left,right)= rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					((List.map (fun x -> offset2idx left right baseidx x) idxlst),[])
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| T_primary_minmaxexp(T_mintypmax_expression_1(exp)) -> self#encode_exp exp
		| T_primary_concat(explst) -> begin
			let (resv,rescls) = List.split (List.map (self#encode_exp) explst)
			in
			((List.concat resv),(List.concat rescls))
		end
		| _ -> begin
			Printf.printf "fatal error : not supported encode_prim\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
	end
	(*return the list of exp bit and list of clause*)
	method encode_number num = begin
		match num with
		T_number_unsign(i) -> begin
			let strlst =(List.rev (Misc2.int2bin i))
			in begin
				let rec proc_intlst slst = begin
					match slst with
					[] -> []
					| hd::tl -> begin
						match hd with
						"0" -> falsepred::(proc_intlst tl)
						| "1" -> truepred::(proc_intlst tl)
						| _ -> begin
							Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
							exit 1
						end
					end
				end 
				in
				((proc_intlst strlst),[])
			end
		end
		| T_number_base(len,base,str) -> begin
			if base =='b' || base =='B' then begin
				if String.length str == len then begin
					let numlst = Misc.string2charlist str 
					in begin
						let rec proc_numlst nl = begin
							match nl with
							[] -> []
							| hd::tl -> begin
								match hd with
								'0' -> 	falsepred::(proc_numlst tl)
								| '1' -> truepred::(proc_numlst tl)
								| _ -> begin
									Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
									exit 1
								end
							end
						end
						in
						((proc_numlst numlst),[])
					end
				end
				else begin
					Printf.printf "fatal error : encode_prim length is not matched\n";
					exit 1
				end
			end
			else begin
				Printf.printf "fatal error : not supported base other than b or B in encode_prim\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : T_number_float is not supported\n";
			exit 1
		end
	end
	
	(*return the list of exp bit and list of clause*)
	method encode_exp exp = begin
		match exp with
		T_primary(prim) -> self#encode_prim prim
		| T_primary_4arrayassign(_) -> begin
			Printf.printf "fatal error : not supported T_primary_4arrayassign\n";
			exit 1
		end
		| T_add1(prim) -> self#encode_prim prim
		| T_sub1(prim) -> begin
			Printf.printf "fatal error : not supported T_sub1\n";
			exit 1
		end
		| T_logicneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in begin
				match bitlst with
				[idx] -> begin
					let oldindex = self#alloc_index 1
					in 
					([oldindex],(self#encode_NEG_ASSIGN oldindex idx )@clst)
				end
				| _ -> begin
					Printf.printf "fatal error : invalid length in T_logicneg\n";
					exit 1
				end
			end
		end
		| T_bitneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in
			let rec proc_bitlst bl = begin
				match bl with
				[] -> ([],[])
				| hd::tl -> begin
					let oldindex = self#alloc_index 1
					and (oldblst,oldclst)=(proc_bitlst tl)
					in 
					((oldindex::oldblst),(self#encode_NEG_ASSIGN oldindex hd)@oldclst)
				end
			end
			in
			let (bl,cl)= proc_bitlst bitlst
			in
			(bl,cl@clst)
		end
		| T_reduce_and(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_AND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nand(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NAND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_or(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_OR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nor(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NOR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_xor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xor\n";
			exit 1
		end
		| T_reduce_xnor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xnor\n";
			exit 1
		end
		| T_add2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let (addblst,addclst)=(self#encode_ADD vec1 vec2)
					in
					(addblst,(clslst1 @ clslst2 @ addclst))
				end
				else begin
					Printf.printf "fatal error : T_add2 length should be of the same\n";
					exit 1
				end
			end
		end
		| T_sub2(_,_) -> begin
			Printf.printf "fatal error : not supported T_sub2\n";
			exit 1
		end
		| T_mul2(_,_) -> begin
			Printf.printf "fatal error : not supported T_mul2\n";
			exit 1
		end
		| T_div(_,_) -> begin
			Printf.printf "fatal error : not supported T_div\n";
			exit 1
		end
		| T_mod(_,_) -> begin
			Printf.printf "fatal error : not supported T_mod\n";
			exit 1
		end
		| T_logic_equ(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_equ_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex = self#alloc_index 1
							in 
							let (bl,cl)=(proc_equ_formular (List.tl plist))
							in
							((oldindex::bl), (self#encode_EQU_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)= proc_equ_formular pl
						and oldindex = self#alloc_index 1
						in 
						([oldindex], clslst1 @ clslst2 @ resclslst @ (self#encode_Red_AND oldindex reslst ) );
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_logic_ine(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_ine_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex = self#alloc_index 1
							in 
							let (bl,cl)=(proc_ine_formular (List.tl plist))
							in
							((oldindex::bl),(self#encode_INE_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)= proc_ine_formular pl
						in
						let oldindex = self#alloc_index 1
						in 
						([oldindex] , clslst1 @ clslst2 @ resclslst @ (self#encode_Red_OR oldindex reslst ))
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_case_equ(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_equ\n";
			exit 1
		end
		| T_case_ine(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_ine\n";
			exit 1
		end
		| T_logic_and2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_AND oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_logic_or2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_OR oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_lt(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_lt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_lt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_lt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_lt case001 %d" oldindex))
									and case01=([b1;-b2;oldindex],(sprintf "T_lt case01 %d" oldindex))
									and case10=([-b1;b2;-oldindex],(sprintf "T_lt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_lt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_lt case111 %d" oldindex))
									in 
									( oldindex , [case000;case001;case01;case10;case110;case111] @ oldclslst)
								end
							end
						end
					end
					in 
					let (b,cl)= proc_lt_formular pl
					in
					([b],cl@clslst1@clslst2)
				end
				else begin
					Printf.printf "fatal error : T_lt length must be equ\n";
					exit 1
				end
			end
		end
		| T_le(exp1,exp2) -> begin
			let newexp = T_logic_or2(T_lt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_gt(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_gt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_gt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_gt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_gt case001 %d" oldindex))
									and case01=([b1;-b2;-oldindex],(sprintf "T_gt case01 %d" oldindex))
									and case10=([-b1;b2;oldindex],(sprintf "T_gt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_gt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_gt case111 %d" oldindex))
									in 
									(oldindex, [case000;case001;case01;case10;case110;case111]@oldclslst )
								end
							end
						end
					end
					in 
					let (b,cl)= proc_gt_formular pl
					in
					([b],cl @ clslst1 @ clslst2 )
				end
				else begin
					Printf.printf "fatal error : T_gt length must be equ\n";
					exit 1
				end
			end
		end
		| T_ge(exp1,exp2) -> begin
			let newexp = T_logic_or2(T_gt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_bit_and2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_and2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_and2 tl
							in 
							let andres = self#encode_AND2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_and2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_and2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_or2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_or2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_or2 tl
							in 
							let andres = self#encode_OR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_or2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_or2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_xor2(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_xor2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_xor2 tl
							in 
							let andres = self#encode_XOR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_xor2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_xor2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_equ(exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_equ2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_equ2 tl
							in 
							let andres = self#encode_EQU_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)= proc_equ2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_equ length must be equ\n";
					exit 1
				end
			end
		end
		| T_leftshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_leftshift\n";
			exit 1
		end
		| T_rightshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_rightshift\n";
			exit 1
		end
		| T_selection(predexp,exp1,exp2) -> begin
			let (vec1,clslst1)= self#encode_exp exp1
			and (vec2,clslst2)= self#encode_exp exp2
			and (predv,clslstpred)= self#encode_exp predexp
			in begin
				if ((List.length vec1) == (List.length vec2) && (List.length predv)==1) then begin
					let pl = List.combine vec1 vec2
					in
					let rec proc_sel pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_sel tl
							in 
							let equres = self#encode_SEL_res oldindex b1 b2 (List.hd predv) 
							in 
							((oldindex::lastres),(equres @ cl))
						end
					end
					in 
					let (bl,cl)= proc_sel pl
					in
					(bl,cl @ clslst1 @ clslst2 @ clslstpred)
				end
				else begin
					Printf.printf "fatal error : T_selection length must be equ and predv must be 1\n";
					exit 1
				end
			end
		end
		| T_string(_) -> begin
			Printf.printf "fatal error : not supported T_string\n";
			exit 1
		end
		| T_expression_NOSPEC(_) -> begin
			Printf.printf "fatal error : not supported T_expression_NOSPEC\n";
			exit 1
		end
	end
	
	method encode_ADD vec1 vec2 = begin
		let oldindex = self#alloc_index (List.length vec1)
		and carryidx = self#alloc_index (List.length vec1)
		in begin
			(*from oldindex to oldindex+(List.length vec1)-1 are the result of add operation*)
			(*from oldindex+(List.length vec1) to oldindex+(List.length vec1)*2-1 are the carry of add operation*)
			(*proc_add will generate one more bit,which means the carry*)
			let rec proc_add v1 v2 residx cryidx = begin
				match v1 with
				[] -> begin
					if (List.length v2 == 0) && (residx == oldindex+(List.length vec1)) && (cryidx == oldindex+(List.length vec1)*2) then 
						([falsepred],[]) (*to enforce 0 cryidx*)
					else begin
						Printf.printf "fatal error : improper T_add2\n";
						Printf.printf "v2 len %d\n" (List.length v2);
						Printf.printf "v1 len %d\n" (List.length v1);
						Printf.printf "vec2 len %d\n" (List.length vec2);
						Printf.printf "vec1 len %d\n" (List.length vec1);
						Printf.printf "residx %d\n" residx;
						Printf.printf "cryidx %d\n" cryidx;
						Printf.printf "oldindex %d\n" oldindex;
						Printf.printf "carryidx %d\n" carryidx;
						exit 1
					end
				end
				| hd1::tl1 -> begin
					let hd2= List.hd v2
					and tl2= List.tl v2
					in begin
						let (reslst,resclslst) = proc_add tl1 tl2 (residx+1) (cryidx+1)
						in begin
							 let carry = List.hd reslst
							 in begin 
							 	(*we would like 
							 		hd2+hd1+carry ==(cryidx,residx)
							 	*)
							 	(cryidx::(residx::(List.tl reslst)),resclslst@(self#encode_ADD_1bit hd1 hd2 carry cryidx residx))
							 	
							 end
						end
					end
				end
			end
			in
			let (bl,cl)=(proc_add vec1 vec2 oldindex carryidx) (*we dont want the hgihest carry*)
			in
			((List.tl bl),cl)
		end
	end
	
	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin
		let cry000 = ([hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry001 = ([hd1;		hd2;		-1*carry;	-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry010 = ([hd1;		-1*hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry011 = ([hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry100 = ([-1*hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry101 = ([-1*hd1;		hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry110 = ([-1*hd1;		-1*hd2;		carry;		cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry111 = ([-1*hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and res000 = ([hd1;		hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res001 = ([hd1;		hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res010 = ([hd1;		-1*hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res011 = ([hd1;		-1*hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res100 = ([-1*hd1;		hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res101 = ([-1*hd1;		hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res110 = ([-1*hd1;		-1*hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res111 = ([-1*hd1;		-1*hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		in
		[cry000;cry001;cry010;cry011;cry100;cry101;cry110;cry111;res000;res001;res010;res011;res100;res101;res110;res111]
	end
	
	method encode_nba_inseq nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_inseq only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)= self#encode_exp exp
			and lvidx_lst = self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_inseq lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen = min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common = Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common = Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst = List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method addGuard clslist pred = begin
	   if (pred ==1) then clslist
	   else begin
		let proc_cls cls = appendcomment (sprintf "guarded by %d" pred) (((-1*pred)::(fst cls)),(snd cls)) 
		in
		List.map proc_cls clslist
	   end
	end
	
	
	(*the first is the destination*)
	method encode_ASSIGN idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_ASSIGN %d %d\n" idx1 idx2;*)
		let initlst =[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_EQU %d %d\n" idx1 idx2;*)
		let initlst =[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_EQU %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU_res r b1 b2 = begin
		(*Printf.printf  "encode_EQU_res %d %d %d\n" b1 b2 r;*)
		let initlst =[([b1;b2;r],"");([-b1;-b2;r],"");([b1;-b2;-r],"");([-b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_EQU_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_EQUV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let ov_pair = List.combine l1 l2
			in
			List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) ov_pair) 
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_EQUV_res l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len1=(List.length l1)
			in
			let new_base = self#alloc_index len1
			and red_and_res = self#alloc_index 1
			in
			let new_var_lst = lr2list new_base (new_base+len1-1)
			in
			let ov_pair = List.combine l1 l2
			in
			let ov_pair_res = List.combine ov_pair new_var_lst
			in
			let cls_equ = List.concat (List.map (fun x -> match x with ((b1,b2),res) -> (self#encode_EQU_res res b1 b2)) ov_pair_res) 
			and cls_reduce = self#encode_Red_AND red_and_res new_var_lst
			in (*the target and the cls list*)
			(red_and_res,(cls_equ@cls_reduce))
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INEV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len =(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx = self#alloc_index len
			in 
			let rec enc pl1 idx = begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)= enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)= enc pl residx
			and redoridx = self#alloc_index 1
			in
			([redoridx],"redoridx")::((self#encode_Red_OR redoridx idxlst )@clslst)
		end
		else begin
			Printf.printf "fatal error : encode_INEV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INEV_res l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len =(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx = self#alloc_index len
			in 
			let rec enc pl1 idx = begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)= enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)= enc pl residx
			and redoridx = self#alloc_index 1
			in
			(redoridx,((self#encode_Red_OR redoridx idxlst )@clslst))
		end
		else begin
			Printf.printf "fatal error : encode_INEV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INE_res r b1 b2  = begin
		(*Printf.printf  "encode_INE_res %d %d %d\n" r b1 b2 ;*)
		let initlst =[([b1;b2;-r],"");([-b1;-b2;-r],"");([b1;-b2;r],"");([-b1;b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_INE_res %s %s %s" (self#idx2name  r) (self#idx2name b1) (self#idx2name b2) ))  initlst
	end
	
	method encode_AND2_res r b1 b2  = begin
		(*Printf.printf  "encode_AND2_res %d %d %d\n" r b1 b2 ;*)
		let initlst =[([b1;-r],"");([b2;-r],"");([-b1;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_AND2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_OR2_res r b1 b2 = begin
		(*Printf.printf  "encode_OR2_res %d %d %d\n"  r b1 b2;*)
		let initlst =[([-b1;r],"");([-b2;r],"");([b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_OR2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_SEL_res r b1 b2 pred = begin
		(*Printf.printf  "encode_SEL_res %d %d %d %d\n" r b1 b2 pred;*)
		let initlst =[([-pred;b1;-r],"");([-pred;-b1;r],"");([pred;b2;-r],"");([pred;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_SEL_res %s %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) (self#idx2name pred) )) initlst
	end
	
	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 
	
	method encode_NEQ idx1 idx2 = begin
		(*Printf.printf  "encode_NEQ %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst =[([idx1;idx2],"");([-1*idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_NEQ %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	(*first is the target*)
	method encode_NEG_ASSIGN idx1 idx2 = begin
		(*Printf.printf  "encode_NEG_ASSIGN %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst =[([idx2;idx1],"");([-1*idx2;-1*idx1],"")]
		in
		List.map (setcomment (sprintf "encode_NEG_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_Red_AND li bitlst  = begin
		(*Printf.printf  "encode_Red_AND %d\n"   li;*)
		(*first the -1 -2 -3 ... li  *)
		let allcase =(((List.map (fun x -> -1*x) bitlst)@[li]),(sprintf "encode_Red_AND %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then i -li*)
		let proc_b b = ([b;(-1*li)],(sprintf "encode_Red_AND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)) )
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NAND li bitlst  = begin
		(*Printf.printf  "encode_Red_NAND %d\n"   li;*)
		(*first the -1 -2 -3 ... -li  *)
		let allcase =(((List.map (fun x -> -1*x) bitlst)@[(-1*li)]),(sprintf "encode_Red_NAND %d to %s" (List.length bitlst) (self#idx2name li) ))
		in
		(*then i li*)
		let proc_b b = ([b;(li)],(sprintf "encode_Red_NAND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_OR li bitlst  = begin
		(*Printf.printf  "encode_Red_OR %d\n"   li;*)
		(*first the 1 2 3 ... -li  *)
		let allcase =(((List.map (fun x -> x) bitlst)@[(-1*li)]),(sprintf "encode_Red_OR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i li*)
		let proc_b b = ([(-1*b);li],(sprintf "encode_Red_OR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NOR li bitlst  = begin
		(*Printf.printf  "encode_Red_NOR %d\n"   li;*)
		(*first the 1 2 3 ... li  *)
		let allcase =(((List.map (fun x -> x) bitlst)@[(li)]),(sprintf "encode_Red_NOR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i -li*)
		let proc_b b = ([(-1*b);(-1*li)],(sprintf "encode_Red_NOR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode2SAT_explictname = begin
		let encode_explictname key cont = begin
		  let duplst = List.filter (fun x -> match x with (nm,_)-> string_equ nm key) name_index_lst
		  in begin
		    if ((List.length duplst) == 0)   then begin
			let rng = self#name2range key
			and dff = self#isdff key
			in begin
				(*the index is for left side of range*)
				if dff then begin(*dff will has two index, one for current state, the other for next state*)
					name_index_lst <- (key,(last_index,last_index+(get_rng_width rng)))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)*2
				end
				else begin
					name_index_lst <- (key,(last_index,-1))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)
				end
			end
		    end
		    else if ((List.length duplst) == 1) && (string_equ key "assertion_shengyushen") && (match (cont#get_obj) with Tobj_net_declaration(_)->true | Tobj_output_declaration(_)-> true |_ -> false)== true then begin
			Printf.printf "warning : %s is defined multiple times with %d\n" key (List.length duplst);
		    end
		    else begin
			Printf.printf "warning : %s is defined multiple times with %d\n" key (List.length duplst);
		    end
		  end
		end
		in
		Hashtbl.iter encode_explictname circuit_hst
	end
	
	
	(*
		some misc functions
	*)
	method map_lv2index lv = begin (*return the list of index from left to right*)
		(*
			note that, for dff, lv must be a next state, so use the second index
					for non-dff one, just use the first one
		*)
		match lv with  
		T_lvalue_id([name]) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			in 
			rng_baseidx_2_idxlist rng baseidx
		end
		| T_lvalue_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			and off = Expression.exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)= rng2lr rng
					in 
					[offset2idx left right baseidx off]
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_lvalue_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,x2)= List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng = self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst = lr2list li ri
			and (left,right)= rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					List.map (fun x -> offset2idx left right baseidx x) idxlst
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| _ -> begin
			Printf.printf "fatal error : not supported lv\n";
			exit 1
		end
	end
	
	
	method isdff name = begin
		let co = self#findco name
		in begin
			match co#get_obj with
			Tobj_dff_declaration(_) -> true
			| _ -> false
		end
	end

	method name2range name = begin
			match (self#findco name)#get_obj with
			Tobj_input_declaration(rng) -> rng
			| Tobj_output_declaration(rng) -> rng
			| Tobj_net_declaration(rng) -> rng
			| Tobj_reg_declaration(rng) -> rng
			| Tobj_dff_declaration(rng) -> rng
			| _ -> begin
				Printf.printf "fatal error : name2range not support Tobj\n";
				exit 1
			end
	end
	
	method idx2name idx_unmapped = begin
		let idx = begin (*we must be careful that we may use idx2name before finish encoding the first instance*)
			if final_index_oneinst ==0 then idx_unmapped
			else if last_index_f<= final_index_oneinst then idx_unmapped mod final_index_oneinst
			else (idx_unmapped mod last_index_f) mod final_index_oneinst
		end
		in
		(*let ssy = List.filter (fun x -> match x with (nm,(idx1,idx2)) -> if (idx1== idx || idx2== idx) then true else false) name_index_lst
		in *)
		begin
			(*if (List.length ssy) == 1 then fst (List.hd ssy)
			else if  (List.length ssy) == 0 then*)
			begin
				(*it may be in range of some defined data*)
				let nm_idx1_li_ri_idx2name nm idx1 li ri idx = 
					let off =(construct_offset idx1 li ri idx)
					in begin
						if (off == -1) then nm
						else sprintf "%s[%d]" nm off
					end
				in
				let pred_inrange ni = begin
					match ni with
					(nm,(idx1,-1)) -> begin
						let (li,ri)= rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else ""
					end
					| (nm,(idx1,idx2)) -> begin
						let (li,ri)= rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else if (is_inrange (construct_range_onidx idx2 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx2 li ri idx)
						else ""
					end
					(*| _ -> ""*)
				end
				in
				let res = List.map pred_inrange name_index_lst 
				in
				let res1 = List.filter (fun x -> (String.length x) !=0) res
				in begin
					if (List.length res1)==1 then List.hd res1
					else "unknown"
				end
			end
			(*else begin
				Printf.printf "warning : idx2name multiple matched , # of match %d , idx = %d , final_index_oneinst =%d\n" (List.length ssy)  idx final_index_oneinst;
				List.iter (fun x -> match x with (nm,_) -> print_string nm) ssy;
				(*sometimes we will use temp vars to record the add carry bit and so on, they dont has defined name and mapping*)
				(*print_string "name_index_lst:\n";
				List.iter (fun x -> match x with (nm,(id1,id2)) -> Printf.printf "%s %d %d\n" nm id1 id2) name_index_lst;*)
				"unknown"
			end*)
		end
	end
	
	(*print_cnf*)
	method print_cnf clslst dumpout_cnf dly len prefix forward = begin
		check_cnf clslst;
		
		fprintf dumpout_cnf "p cnf %d %d\n" (get_largest_varindex_inclslst clslst) (List.length clslst);
		
		fprintf dumpout_cnf "c module_name  %s \n" name;
		
		List.iter (fun x -> fprintf dumpout_cnf "c module_port  %s \n" (get_str_from_strlst x)) portlist;
		
		(*leave a blank line for awk to exit from printing module definition *)
		fprintf dumpout_cnf "c module_def_end\n"  ;
		
		fprintf dumpout_cnf "c clkname %s\n" clkname;
		
		fprintf dumpout_cnf "c for_rev_cz final_index_oneinst %d\n" final_index_oneinst;
		
		fprintf dumpout_cnf "c for_rev_cz dly %d\n" dly;
		
		fprintf dumpout_cnf "c for_rev_cz len %d\n" len;
		
		fprintf dumpout_cnf "c for_rev_cz prefix %d\n" prefix;
		
		fprintf dumpout_cnf "c for_rev_cz forward %d\n" forward;
		
		(*print out the truepred list*)
		let proc_truepred cls = begin
			match cls with
			([pred],_) -> begin
				if pred > 0 then 
					fprintf dumpout_cnf "c pre_truepred %d\n" pred
			end
			| _ -> ()
		end
		in
		List.iter proc_truepred clslst
		;
		
		let left nm = match (rng2lr (self#name2range nm)) with (left,_)->left
		and right nm = match (rng2lr (self#name2range nm)) with (_,right)->right
		in begin
			List.iter (fun instr ->  fprintf dumpout_cnf "c for_rev_cz input %s %d %d\n"  instr  (left instr)  (right instr))  instrlist;
			List.iter (fun outstr -> fprintf dumpout_cnf "c for_rev_cz output %s %d %d\n" outstr (left outstr) (right outstr)) outstrlist;
		end
		;
		
		let proc_hst key co = begin
			match co#get_obj with
			Tobj_input_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c input_port %s\n" key 
					else
						fprintf dumpout_cnf "c input_port [%d:%d] %s\n" left right key 
				end
			end
			| Tobj_output_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c output_port %s\n" key 
					else
						fprintf dumpout_cnf "c output_port [%d:%d] %s\n" left right key 
				end
			end
			| _ -> ()
		end
		in
		Hashtbl.iter proc_hst circuit_hst
		;
		
		let print_name_index name_index = begin
			match name_index with
			(nm,(curidx,nxtidx)) -> begin
				fprintf dumpout_cnf "c one instance mapping %s %d %d " nm curidx nxtidx;
				match (rng2lr (self#name2range nm)) with
				(left,right) -> 
					fprintf dumpout_cnf "%d %d\n" left right
			end
		end
		in
		List.iter print_name_index name_index_lst
		;
		
		let print_clause cls = begin
			match cls with
			(litlst,cmt) -> begin
				fprintf dumpout_cnf "c %s\n" cmt;
				(*List.iter (fun lit -> if ( lit != -1 && lit != 2 ) then begin fprintf dumpout_cnf "%d " lit end) litlst ;*)
				List.iter (fun lit -> fprintf dumpout_cnf "%d " lit ) litlst ;
				fprintf dumpout_cnf "0\n"
			end
		end
		in
		List.iter print_clause clslst
	end

	method print_itpo arr_itpo = begin
		self#print_itpo_file stdout arr_itpo
	end

	method print_itpo_file fv arr_itpo = begin
			let size = Array.length arr_itpo
			in
			let rec interpObj2str interpObj = begin
				match interpObj with
				TiterpCircuit_true -> "1'b1"
				| TiterpCircuit_false -> "1'b0"
				| TiterpCircuit_refcls(clsidx) -> begin
					let itpo_nxt = arr_itpo.(clsidx)
					in interpObj2str itpo_nxt
				end
				| TiterpCircuit_refvar(varidx) -> begin
					if (varidx>0) then begin
						sprintf "%s(%d)" (self#idx2name varidx) varidx
					end
					else if (varidx<0) then begin
						sprintf "!%s(%d)" (self#idx2name (-varidx)) varidx
					end
					else assert false
				end
				| TiterpCircuit_and(interpObjlst) -> begin
					let objreslst = List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " & " objreslst);")"]
				end
				| TiterpCircuit_or(interpObjlst) -> begin
					let objreslst = List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " | " objreslst);")"]
				end
				| TiterpCircuit_not(interpObj) -> begin
					let objres = interpObj2str interpObj
					in
					sprintf "!%s" objres
				end
				| TiterpCircuit_printed(clsidx) -> assert false
				| _ -> assert false
			end
			and prt_trace_withInterp num iter_res  = begin
				match iter_res with
				TiterpCircuit_none -> ()
				| _ -> begin
					let str_of_itpo = interpObj2str  iter_res
					in
					fprintf fv "%s" str_of_itpo
				end
			end
			in begin
				prt_trace_withInterp (size-1) arr_itpo.(size-1)
			end
	end

	method print_itpo_verilog_file fv itpo1 idx vpos= begin
		fprintf fv "assign w_%d_%d = " idx vpos;
		let rec prt_itpo itpo = begin
			match itpo with
			TiterpCircuit_true -> "1'b1"
			| TiterpCircuit_false -> "1'b0"
			| TiterpCircuit_refcls(clsidx) -> begin
				assert(clsidx!=0);
				sprintf "w_%d_%d" idx clsidx;
			end
			| TiterpCircuit_refvar(varidx) -> begin
				if (varidx>0) then begin
					sprintf "cycle%d_%s" (varidx/final_index_oneinst) 
							(self#idx2name (varidx mod final_index_oneinst)) 
				end
				else if (varidx<0) then begin
					sprintf "!cycle%d_%s" ((-varidx)/final_index_oneinst) 
							(self#idx2name ((-varidx) mod final_index_oneinst))
				end
				else assert false
			end
			| TiterpCircuit_and(interpObjlst) -> begin
				let objreslst = List.map prt_itpo interpObjlst
				in
				String.concat " " ["(" ;(String.concat " & " objreslst);")"]
			end
			| TiterpCircuit_or(interpObjlst) -> begin
				let objreslst = List.map prt_itpo interpObjlst
				in
				String.concat " " ["(" ;(String.concat " | " objreslst);")"]
			end
			| TiterpCircuit_not(interpObj) -> begin
				let objres = prt_itpo interpObj
				in
				sprintf "!%s" objres
			end
			| TiterpCircuit_printed(clsidx) -> begin
				Printf.printf "\nFATAL :TiterpCircuit_printed\n";
				assert false
			end
			| _ -> begin
				assert (itpo==TiterpCircuit_none);
				assert false
			end
		end in
		let varstr=prt_itpo itpo1 in
		fprintf fv " %s ;\n" varstr ;
	end

	(*for one inst*)
	method set_lock_oneinst = begin
		lock_oneinst <- true
	end
	
	method set_unlock_oneinst = begin
		lock_oneinst <- false
	end
	
	method append_clause_list_oneinst newclslst = begin
		assert (lock_oneinst == false);
		clause_list <- newclslst @ clause_list;
	end
	
	method set_clause_list_oneinst newclslst = begin
		assert (lock_oneinst == false);
		clause_list <- newclslst;
	end
	
	method set_last_index_oneinst newidx = begin
		assert (lock_oneinst == false);
		final_index_oneinst <- (newidx+1);
	end
	
	
	(*for multiple*)
	method set_lock_multiple = begin
		check_clslst_maxidx clause_list_multiple last_index;
		lock_multiple <- true
	end
	
	method set_unlock_multiple = begin
		lock_multiple <- false
	end
	
	method append_clause_list_multiple newclslst = begin
		assert (lock_multiple == false);
		clause_list_multiple <- newclslst @ clause_list_multiple;
	end
	
	method set_clause_list_multiple newclslst = begin
		assert (lock_multiple == false);
		clause_list_multiple <- newclslst;
	end
	
	method set_last_index newidx = begin
		assert (lock_multiple == false);
		last_index <- newidx+1;
		assert ((get_largest_varindex_inclslst clause_list_multiple)<last_index);
	end
	
	(*allocate last_index to last_index+num-1 , and set last_index to last_index+num*)
	method alloc_index num = begin
		assert (lock_multiple == false);
		let oldindex = last_index 
		in begin
			last_index <- oldindex+num;
			oldindex
		end
	end
	

end
