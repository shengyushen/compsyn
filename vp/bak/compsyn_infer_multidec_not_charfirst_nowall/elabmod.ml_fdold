(*correctly found the parameter, but
1 can not characterize
2 too slow
*)

open Printf
open Typedef
open Typedefcommon
open Circuit_obj
open Print_v
open Misc2
open Misc
open Statement
open Misc2
open Dependent
open Str
open Clauseman
open Interp
open Bddssy
open Aig

exception UNSAT

		

class elabmod = 
object (self)

	(*these will be generated in init method*)
	val mutable name = ""
	val mutable portlist = []
	val mutable tempdirname = ""
	
	(*these will be generated in elaborate method*)
	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 
	val mutable clkname = "" 
	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)
	val mutable comb_always_list : (statement*(string list)) list = []
	val mutable cont_ass_list : assignment list = []

	(*these will be generatesd in encode_oneInstance2SAT_step1 method*)
	(*
		relation between varaibles name and its index
		the int pair in name_index_lst is for dff only, 
			the first one is current state, 
			the second one is for next state, which should be the first one plus rng width
		for other case
			only the first one is meaningful
			the second one must be -1
		
	*)
	val mutable name_index_lst : (string*(int*int)) list = []  
	
	val mutable lock_oneinst : bool = false
	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable final_index_oneinst = 0
	
	val truepred = 1
	val falsepred =2
	val assertion_shengyushen="assertion_shengyushen"
	(*these will generated by multiple instance generation*)

	(*to prevent incidently change of clause_list_multiple and last_index*)
	val mutable lock_multiple : bool = false
	val mutable clause_list_multiple : ((int list)*string) list = []
	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	val mutable clause_list_multiple_saved : ((int list)*string) list = []
	val mutable last_index_saved = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)
	
	(*these will be generated by compsyn*)
	(*they will never be changed after assignment*)
	val mutable instrlist = []
	val mutable outstrlist = []
	val mutable non_proctocol_input_list = []
	
	(*they will never be changed after assignment*)
	val mutable bv_instrlist = []
	val mutable bv_outstrlist = []
	val mutable bv_non_proctocol_input_list = []
	
	(*used to store the clause list of f's relation
	we will use them to expand to fd test*)
	val mutable clause_list_multiple_f : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index_f = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	(*used to store the clause list of f's relation
	we will use them to expand to fd test*)
	val mutable clause_list_multiple_genia : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index_genia = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	val mutable ddM = CaddieBdd.init 0 64 256 512


	method print dumpout = begin
		fprintf dumpout "module %s (\n" name;
		list_iter_interleave (fun x -> fprintf dumpout "   %s " (get_str_from_strlst x)) (fun x -> fprintf dumpout " , \n") portlist;
		fprintf dumpout "\n);\n";
		
		(*print out all input*)
		let print_input key cont = begin
			match cont#get_obj with
			Tobj_input_declaration(rng) -> begin
				fprintf dumpout "   input ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_input circuit_hst
		;
		
		(*print out all output*)
		let print_output key cont = begin
			match cont#get_obj with
			Tobj_output_declaration(rng) -> begin
				fprintf dumpout "   output ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_output circuit_hst
		;
		
		(*print out all wire*)
		let print_wire key cont = begin
			match cont#get_obj with
			Tobj_net_declaration(rng) -> begin
				fprintf dumpout "   wire ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_wire circuit_hst
		;
		
		(*print out all reg*)
		let print_reg key cont = begin
			match cont#get_obj with
			Tobj_reg_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| Tobj_dff_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_reg circuit_hst
		;
		
		(*print out all seq*)
		let print_seq seq_always = begin
			match seq_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(posedge %s) begin\n" clkname;
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_seq seq_always_list
		;
		
		(*print out all comb*)
		let print_comb comb_always = begin
			match comb_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(\n";
				
				let deplist= dep_statement stat
				in
				list_iter_interleave (fun x -> fprintf dumpout " %s " x) (fun x -> fprintf dumpout " or ") deplist
				;
				
				fprintf dumpout ") begin\n";
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_comb comb_always_list
		;
		
		(*print out all cont assign*)
		let print_cont_ass cont_ass = begin
			match cont_ass with
			T_assignment(lv,exp) -> begin
				fprintf dumpout "assign  ";
				print_v_lvalue dumpout lv;
				fprintf dumpout " = ";
				print_v_expression dumpout exp;
				fprintf dumpout ";\n"
			end
			| _ -> ()
		end
		in
		List.iter print_cont_ass cont_ass_list
		;
		
		
		fprintf dumpout "endmodule\n"
	end

	method getname = name

	method addco str co = begin
		(*Printf.printf "adding %s\n" hn#getname ;*)
		Hashtbl.add circuit_hst str co
	end

	method rplco str co = begin
		(*Printf.printf "replacing %s\n" hn#getname ;*)
		Hashtbl.replace circuit_hst str co
	end

	method findco str = begin
		try 
			Hashtbl.find circuit_hst str
		with Not_found -> begin
			Printf.printf "fatal error : undefined hn %s are treated as wire\n" str;
			exit 1
			(*following code is for those large number of undefined net*)
			(*self#addco hn (new circuit_obj (Tobj_net_declaration(T_range_NOSPEC,T_expression_NOSPEC(1)))  hn);
			Hashtbl.find circuitobj_hst hn#getname *)
		end
	end

	method nameInportlist name1 = begin
		let check_portname pt= begin
			match pt with 
			[ptn] -> string_equ ptn name1
			|_ -> begin
				Printf.printf "fatal error : port name should not be a list\n";
				exit 1
			end
		end
		in 
		let portfound = List.filter check_portname  portlist
		in begin
			if (List.length portfound) != 1 then begin
				Printf.printf "fatal error : portfound is not unique\n";
				exit 1
			end
		end
	end
	
	method proc_T_input_declaration range namelst = begin
		let proc_one_input name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let inCircuitObj = new circuit_obj (Tobj_input_declaration(range))  newhn
			in
			self#addco name1 inCircuitObj
		end
		in 
		List.iter proc_one_input namelst
	end
	
	method proc_T_output_declaration range namelst = begin
		let proc_one_output name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let outCircuitObj = new circuit_obj (Tobj_output_declaration(range))  newhn
			in
			self#addco name1 outCircuitObj
		end
		in 
		List.iter proc_one_output namelst
	end
	
	method proc_T_net_declaration nettypename exprng namelst = begin
		if (string_equ nettypename "wire") != true then begin
			Printf.printf "fatal error : only supported wire\n";
			Printf.printf "%s\n" nettypename;
			exit 1
		end
		;
		let rng = match exprng with
		T_expandrange_range(rng1) -> rng1
		| T_expandrange_NOSPEC -> T_range_NOSPEC
		|_ -> begin
			Printf.printf "fatal error : only supported T_expandrange_range\n";
			exit 1
		end
		in begin
			let proc_one_net netn = begin
				(*add it to circuit object list*)
				let newhn=new hierachcal_name [netn]
				in
				let netCircuitObj = new circuit_obj (Tobj_net_declaration(rng))  newhn
				in
				self#addco netn netCircuitObj
			end
			in 
			List.iter proc_one_net namelst
		end
	end
	
	method proc_T_reg_declaration  rng regvarlst = begin
		let proc_one_reg regvar = begin
			(*add it to circuit object list*)
			match regvar with
			T_register_variables_ID(regname) -> begin
				let newhn=new hierachcal_name [regname]
				in
				let regCircuitObj = new circuit_obj (Tobj_reg_declaration(rng))  newhn
				in
				self#addco regname regCircuitObj
			end
			| T_register_variables_IDrange(regname,lexp,rexp) -> begin
				Printf.printf "fatal error : not supported T_register_variables_IDrange\n";
				exit 1
			end
		end
		in 
		List.iter proc_one_reg regvarlst
	end
	
	method proc_T_continuous_assign cont_ass = begin
		let asslst = begin
			match cont_ass with
			T_continuous_assign_assign(_,_,asslst1) -> asslst1
			| T_continuous_assign_net(nettypename,_,exprng,_,asslst1) -> begin
				(*i need to first put them into circuit object list*)
				begin
					let ass2name ass = begin
						match ass with 
						T_assignment(lv,_) -> begin
							match lv with 
							T_lvalue_id([nm]) -> nm
							| _ -> begin
								Printf.printf "fatal error : only supported T_lvalue_id 2\n";
								exit 1
							end
						end
					end
					in
					let namelst = List.map ass2name asslst1
					in
					self#proc_T_net_declaration nettypename exprng namelst
				end
				;
				asslst1
			end
		end
		in  cont_ass_list <- asslst @ cont_ass_list
		(*begin
			let proc_ass ass = begin
				match ass with
				T_assignment(lv,exp) -> begin
					match lv with
					T_lvalue_id([nm]) -> begin
						let hn = new hierachcal_name [nm]
						in
						let rngold = begin
							match ((self#findco nm)#get_obj) with
							Tobj_net_declaration(rngo,_) -> rngo
							| _ -> begin
								Printf.printf "fatal error : only should find Tobj_net_declaration \n";
								exit 1
							end
						end
						in
						let co =new circuit_obj (Tobj_net_declaration(rngold,exp)) hn
						in
						self#rplco nm co
					end
					| T_lvalue_arrbit
					| _ -> begin
						Printf.printf "fatal error : only supported T_lvalue_id 1\n";
						print_v_lvalue stdout lv;
						exit 1
					end
				end
			end
			in
			List.iter proc_ass asslst
		end*)
	end
	
	method proc_T_always_statement_seq stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				if (List.length evexplst) != 1 then begin
					Printf.printf "fatal error : only supported sync set and reset regs\n";
					exit 1
				end
				;
				(*set the clock*)
				let clkeve=(List.hd evexplst)
				in begin
					match clkeve with 
					T_event_expression_posedge(exp) -> begin
						match exp with
						T_primary(T_primary_id([clkn])) -> begin
							if (string_equ clkname "") then clkname <- clkn
							else if (string_equ clkname clkn) then clkname <- clkn
							else begin
								Printf.printf "fatal error : only supported one clock\n";
								exit 1
							end
						end
						| _ -> begin
							Printf.printf "fatal error : only supported id as clock name\n";
							exit 1
						end
					end
					| _ -> begin
						Printf.printf "fatal error : only supported T_event_expression_posedge\n";
						exit 1
					end
				end
				;
				(*extract the reg name list*)
				let regnamelist = statement2regnamelist stat_sub
				in begin
					(*add these reg's definition to list*)
					seq_always_list <- (stat_sub,regnamelist) :: seq_always_list
					;
					(*change them to dff*)
					let proc_reg regname = begin
						let hn= new hierachcal_name [regname]
						in
						let co = self#findco regname
						in begin
							match co#get_obj with
							Tobj_reg_declaration(rngr) -> begin
								self#rplco regname (new circuit_obj (Tobj_dff_declaration(rngr)) hn)
							end
							| Tobj_dff_declaration(_) -> begin
								Printf.printf "warning : why it is already dff?\n";
								Printf.printf "%s\n" regname;
							end
							| _ -> begin
								Printf.printf "fatal error : object in always statement should be declared as reg\n";
								Printf.printf "%s\n" regname;
								exit 1
							end
						end
					end
					in
					List.iter proc_reg regnamelist
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement_comb stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			let regnamelist = statement2regnamelist stat_sub
			in
			comb_always_list <- (stat_sub,regnamelist) :: comb_always_list
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				let isedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> true
					| T_event_expression_negedge(_) -> true
					| _ -> false
				end
				and notedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> false
					| T_event_expression_negedge(_) -> false
					| _ -> true
				end
				in
				if (List.for_all isedgeevent evexplst) then self#proc_T_always_statement_seq stat
				else if (List.for_all notedgeevent evexplst) then self#proc_T_always_statement_comb stat
				else begin
					Printf.printf "fatal error : edge and non edge event at the same time\n";
					exit 1
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_MI mi= begin
		match mi with
		T_parameter_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_declaration\n";
			exit 1
		end
		| T_input_declaration(range,namelst) -> 
			self#proc_T_input_declaration range namelst
		| T_output_declaration(range,namelst) -> 
			self#proc_T_output_declaration range namelst
		| T_inout_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_inout_declaration\n";
			exit 1
		end
		| T_net_declaration(netname,_,exprng,_,namelst) -> 
			self#proc_T_net_declaration netname exprng namelst
		| T_reg_declaration(rng,regvarlst) -> 
			self#proc_T_reg_declaration rng regvarlst
		| T_time_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_time_declaration\n";
			exit 1
		end
		| T_integer_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_integer_declaration\n";
			exit 1
		end
		| T_real_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_real_declaration\n";
			exit 1
		end
		| T_event_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_event_declaration\n";
			exit 1
		end
		| T_gate_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_gate_declaration\n";
			exit 1
		end
		| T_module_instantiation(_) -> begin
			Printf.printf "fatal error : not supported T_module_instantiation\n";
			exit 1
		end
		| T_parameter_override(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_override\n";
			exit 1
		end
		| T_continuous_assign(cont_ass) ->  
			self#proc_T_continuous_assign cont_ass
		| T_specify_block(_) -> begin
			Printf.printf "fatal error : not supported T_specify_block\n";
			exit 1
		end
		| T_initial_statement(_) -> begin
			Printf.printf "fatal error : not supported T_initial_statement\n";
			exit 1
		end
		| T_always_statement(stat) -> 
			self#proc_T_always_statement stat
		| T_task(_,_,_) -> begin
			Printf.printf "fatal error : not supported T_task\n";
			exit 1
		end
		| T_function_avoid_amb(_,_,_,_) -> begin
			Printf.printf "fatal error : not supported T_function_avoid_amb\n";
			exit 1
		end
	end

	method init module2beElaborated tempdirname1 = begin
		match module2beElaborated with
		T_module_def(modName,portlist1,milist) -> begin
			name <- modName;
			portlist <- portlist1;
			tempdirname <- tempdirname1;
			(*processing mi list*)
			List.iter (self#proc_MI) milist
		end
		| _ -> begin
			Printf.printf "fatal error : only T_module_def\n";
			exit 1
		end
	end
	
	method proc_getvector_value name = begin
		let baseidx = begin
			let (x1,_)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in
		let (l,_) = rng2lr rng
		in 
		let bitlist=List.map (fun x -> baseidx+x-l) (rng2list rng)
		in
		let bit_value_list=List.map get_assignment bitlist
		in
		let rec gen_value lst old_value= begin
			match lst with
			hd::tl -> begin
				match hd with 
				(_,true) -> gen_value tl (old_value*2+1)
				| (_,false) ->  gen_value tl (old_value*2)
			end
			| [] -> old_value
		end
		in
		gen_value bit_value_list 0
	end

	method name2idxlist name = begin
		let baseidx = begin
			let (x1,_)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method name2idxlist_nxt name = begin
		let baseidx = begin
			let (_,x1)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in 
		rng_baseidx_2_idxlist rng baseidx	
	end

	method is_assertion name_index = begin
		match name_index with 
		(nm,_) -> begin
			string_equ nm assertion_shengyushen
		end
	end

	method constrain_assertion li = begin (*li is from bound-1 to 0*)
		let ov=List.concat (List.map self#name2idxlist [assertion_shengyushen])
		in 
		let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
		in
		List.map (fun x -> ([x],assertion_shengyushen) ) ov_0
	end

	method try_assertion start_i end_i = begin
		if(end_i<start_i) then []
		else begin
			let old_assclslst=self#constrain_assertion end_i
			and cur_assclslst=self#try_assertion start_i (end_i-1)
			in
			old_assclslst@cur_assclslst
		end
	end



	(*return the new result of equ*)
	method alloc_and_equ_res ov_pair_lst = begin
		match ov_pair_lst with 
		(a, b) -> begin
			let r = self#alloc_index 1
			in
			let equres=self#encode_EQU_res r a b
			in 
			(r,equres)
		end
	end
	
	(*from here on is the list of method of complementary synthesis*)

	method compsyn (*(bound_dl:int)*) (instrlist1:string list) (outstrlist1:string list) = begin
		self#set_lock_oneinst;

		instrlist <- instrlist1 ;
		outstrlist <- outstrlist1 ;
		
		let allinputs = begin
			(*find out all input ports*)
			let ext_input key cont last_res = begin
				match cont#get_obj with
				Tobj_input_declaration(_) -> begin
					key::last_res
				end
				| _ -> last_res
			end
			in
			Hashtbl.fold ext_input circuit_hst []
		end
		in
		let start_time = Unix.gettimeofday ()
		in
		let cnfname_1inst=String.concat "" [tempdirname ; "dumpout/inst1_" ; name ;".cnf"]
		and cnfname_dualsyn=String.concat "" [tempdirname ; "dumpout/dualsyn_" ; name ;".cnf"]
		in 
		begin

			non_proctocol_input_list <- begin
				(*non protocol inputs*)
				let is_non_protocol x = begin
					match x with
					key -> not (List.mem key instrlist)
				end
				in
				List.filter is_non_protocol allinputs
			end
			;
			
			printf "\n+++++ start of non protocol input list +++\n";
			List.iter (printf " %s ") non_proctocol_input_list ;

			(*Printf.printf "start to do with bound\n" ;*)
			let clslst_one_inst=(self#encode_oneInstance2SAT_step1)
			in begin
				self#set_unlock_oneinst;
				self#append_clause_list_oneinst clslst_one_inst ; (*encode one instance*)
				self#set_last_index_oneinst last_index;(*record the final largest index*)
			end
			;
			self#set_lock_oneinst;

			bv_instrlist <- List.concat (List.map self#name2idxlist instrlist) ;
			bv_outstrlist <- List.concat (List.map self#name2idxlist outstrlist) ;
			bv_non_proctocol_input_list <- List.concat (List.map self#name2idxlist non_proctocol_input_list) ;


			let end_time_step1 = Unix.gettimeofday ()
			in
			Printf.fprintf stdout "\n TIME : encode_oneInstance2SAT_step1  %f \n" (end_time_step1 -. start_time)
			;

			(*
				dump to sat *_1inst.cnf, for verification purpose,
				I will write another program to map the *_1inst.cnf back to verilog,
				such that it can be verified by formality
			*)
			(*Printf.printf "start to do 1 \n" ;*)
			begin
				print_endline "";
				print_endline  cnfname_1inst;
			
				let dumpout_cnf = open_out cnfname_1inst
				in
				self#print_cnf clause_list dumpout_cnf 0 1 0 0 
				;
				close_out dumpout_cnf
			end
			;
			(*Printf.printf "start to do 2 \n" ;*)
			self#set_lock_multiple;
			let start_time_check_comp = Unix.gettimeofday ()
			in
			let (pres,p_pre,l,r,infered_assertion_array_lst_new)=self#try_bound_wrap
			in begin
				let end_time_try_bound = Unix.gettimeofday ()
				in
				Printf.fprintf stdout "\n TIME : try_bound  %f \n" (end_time_try_bound -. start_time_check_comp)
				;
			  if(pres==RES_UNIQ) then begin
				(*Printf.printf "p_pre %d\n" p_pre;*)
				let d1=self#reduce_d p_pre l r infered_assertion_array_lst_new
				in
				let p1=self#reduce_p p_pre l d1 infered_assertion_array_lst_new
				in
				let l1=self#rmred (p1+l) 1 d1 infered_assertion_array_lst_new(*here l means the left exp, while l1 mean output length*)
				in begin
					assert(lock_oneinst==true);
					assert(lock_multiple==true);
					self#gen_characterizer_wrap_new (p1+l) l1 d1 infered_assertion_array_lst_new;
					assert(lock_oneinst==true);
					assert(lock_multiple==true);

					Printf.printf "rmred p1 %d l1 %d d1 %d ass len %d\n" p1 l1 d1 (List.length infered_assertion_array_lst_new);
					
					let end_time = Unix.gettimeofday ()
					in
					Printf.fprintf stdout "\n TIME : check_compsyn  %f ass len %d\n" (end_time -. start_time_check_comp) (List.length infered_assertion_array_lst_new)
					;
					
					(*simplify the infer assertion list*)
					let infered_assertion_array_lst_old_loop1=infered_assertion_array_lst_new
					in 
					let infass= begin
						if (List.length infered_assertion_array_lst_old_loop1)!=0 then 
							simplify_withBDD (invert_assertion (or_assertion infered_assertion_array_lst_old_loop1)) ddM
						else 
							Array.make 1 TiterpCircuit_true
					end
					in begin
						printf "the current remained assertion : ass len %d\n" (List.length infered_assertion_array_lst_old_loop1);
						printf "++++++++++++++++++++++++++\n";
						self#print_itpo infass;
						printf "\n++++++++++++++++++++++++++\n";
					end 
					;
					
					(UNSATISFIABLE,d1,1,p1+l,l1) (*l shound not be changed*)
				end
			  end
			  else begin
				assert false 
			  end
			end
		end
	end

	method try_bound_wrap = begin
		let b = ref 3
		and res = ref RES_UNK
		and infered_assertion_array_lst_old = ref []
		and p = ref 0
		and l = ref 0
		and r = ref 0
		and xxx = ref (RES_UNK,0,0,0,[])
		in begin
			while ( (!res) != RES_UNIQ ) do
				b := (!b)+1 ;
				xxx := self#check_p_r_l (!b) (!b) (!b) (!infered_assertion_array_lst_old);
				match (!xxx) with
				(res1,p1,l1,r1,infered_assertion_array_lst_old1) -> begin
					res := res1 ;
					p := p1 ;
					l := l1 ;
					r := r1 ;
					infered_assertion_array_lst_old := infered_assertion_array_lst_old1@(!infered_assertion_array_lst_old) ;
				end
			done
			;
			((!res),(!p),(!l),(!r),(!infered_assertion_array_lst_old))
		end
	end

	method check_p_r_l (p:int) (r:int) (l:int) infered_assertion_array_lst_old = begin
		let (result_p,target)=self#findLR_checkO p l r infered_assertion_array_lst_old
		in begin
			assert(lock_multiple==true);
			if (result_p==UNSATISFIABLE) then begin
				(*we only need to check here that 
				the assertion still have a valuation for parameters
				because the unsatisfiable assertions will also lead to the UNSAT of findLR_checkO*)
				check_assertion_satisfiable infered_assertion_array_lst_old ;
				(RES_UNIQ,p,l,r,infered_assertion_array_lst_old) (* output uniquely determine input*)
			end
			else begin
				let (result_p_loop,infered_assertion_array_lst_new)=self#findLR_checkO_loop_wrap p l r target infered_assertion_array_lst_old (*in this case I dont need to encode common again*)
				in begin
					assert (result_p_loop==UNSATISFIABLE) ;
					(RES_UNK,p,l,r,infered_assertion_array_lst_new)
				end
			end
		end
	end

	method findLR_checkO (p:int) (l:int) (r:int) infered_assertion_array_lst_old=begin
		Printf.printf "  findLR_checkO : p %d l %d r %d\n" p l r;
		flush stdout;
		let target = self#findLR_common p l r infered_assertion_array_lst_old
		in begin
			(*save the encoded instance*)
			clause_list_multiple_saved <- clause_list_multiple ;
			last_index_saved <- last_index ;
		end
		;

		(*dump to sat*)
		let res=dump_sat (([target],"target")::clause_list_multiple)
		in
		(res,target) (*target will be useb by following loop encode*)
	end


	method findLR_common (p:int) (l:int) (r:int) infered_assertion_array_lst_old =begin
		self#set_unlock_multiple;
		
		self#set_clause_list_multiple [];
		self#set_last_index final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		l instance for left expansion
		1 instance for current input 
		r instance for right expansion
		*2 for another expansion
		*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 ((p+l+1+r)*2))
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*constrain the assertion wire*)
		if (List.length (List.filter (self#is_assertion) name_index_lst)) > 0 then
			self#append_clause_list_multiple (self#try_assertion 0 ((p+l+1+r)*2-1))
		else 
			print_endline "warning : not found assertion_shengyushen"
		;
		
		(*connect the first p+1+r instance*)
		self#append_clause_list_multiple  (self#connect_multiple_instance_step3 0 (p+l+r)) ;
		
		(*connect the secnod p+1+r instance*)
		self#append_clause_list_multiple  (self#connect_multiple_instance_step3 (p+l+1+r) ((p+l+1+r)*2-1)) ;
		
		(*force the input of p+l and p+l+1+r+p+l to be diff*)
		let ov=bv_instrlist
		in 
		let ov_0 = List.map (fun x -> x+ (p+l)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+l+1+r+p+l)*final_index_oneinst) ov
		in
		self#append_clause_list_multiple  (self#encode_INEV (ov_0) (ov_b)) 
		;

		(*force the npi to be the same*)
		let npi_lst=bv_non_proctocol_input_list
		and npi_cycle_lst = lr2list 1 ((p+l+1+r)*2-1)
		in
		let proc_npi_cycle i = begin
			let npi_lst_i = List.map (fun x -> x+(i*final_index_oneinst)) npi_lst
			in
			self#append_clause_list_multiple (self#encode_EQUV (npi_lst) (npi_lst_i))
		end
		in
		List.iter proc_npi_cycle npi_cycle_lst
		;
		
		(*force the infered_assertion_array_lst_old to be invalid*)
		List.iter (fun x -> self#force_assertion (invert_assertion x)) infered_assertion_array_lst_old ;
		
		(*force the output of p to p+l+1+r-1 to be the same*)
		let ov=bv_outstrlist
		and outputframe_idx= lr2list (p) (p+l+1+r-1)
		in
		let ov_b_1 = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) ov) ) outputframe_idx)
		in
		let ov_b_2 = List.map (fun x -> x+(p+l+1+r)*final_index_oneinst) ov_b_1
		in
		let (target,oclslist)=self#encode_EQUV_res ov_b_1 ov_b_2 
		in begin
			self#append_clause_list_multiple oclslist ;
			self#set_lock_multiple;
			target
		end
		
	end

	method findLR_checkO_loop_wrap (p:int) (l:int) (r:int) target_all_old infered_assertion_array_lst_old=begin
		Printf.printf "  findLR_checkO_loop_wrap : p %d l %d r %d ass len %d\n" p l r (List.length infered_assertion_array_lst_old);
		if(p<2 || l<2 || r<2) then (UNSATISFIABLE,infered_assertion_array_lst_old)
		else begin
			(*in this case I dont need to encode common again*)
			let target_all = self#construct_instance_loop p l r target_all_old
			in begin
				self#set_unlock_multiple;
				List.iter (fun x -> self#force_assertion (invert_assertion x)) infered_assertion_array_lst_old;
				self#set_lock_multiple;
				allsat_interp clause_list_multiple target_all bv_non_proctocol_input_list (self#construct_varlst2assumption p l r) ddM
			end
		end
	end

	method construct_instance_loop (p:int) (l:int) (r:int) target_all_old =begin
		self#set_unlock_multiple ;
		(*in this case I dont need to encode common again
		I just copy back the previous encoded one*)
		self#set_clause_list_multiple  clause_list_multiple_saved ;
		self#set_last_index last_index_saved ;
		
		let target_common = target_all_old (*self#findLR_common p l r *)
		and target_loop_p = self#double_loop p l r 0 p
		and target_loop_l = self#double_loop p l r p (p+l)
		and target_loop_r = self#double_loop p l r (p+l+1) (p+l+1+r-1)
		in
		let target_all = self#alloc_index 1
		in
		let cls_red_and_all = self#encode_Red_AND target_all [target_common;target_loop_p;target_loop_l;target_loop_r]
		in begin
			assert (target_common!=target_loop_p);
			assert (target_common!=target_loop_l);
			assert (target_common!=target_loop_r);
			assert (target_loop_p!=target_loop_l);
			assert (target_loop_p!=target_loop_r);
			assert (target_loop_l!=target_loop_r);
			self#append_clause_list_multiple cls_red_and_all ;
			self#set_lock_multiple ;
			target_all
		end
	end
	
	method double_loop (p:int) (l:int) (r:int) starti endi= begin
		let dff_idxpairlst=List.filter (isdff_name_index) name_index_lst
		in
		let dff_curlst=List.map (fun x -> match x with (_,(y,_)) -> y) dff_idxpairlst
		in begin
			let lilst=lr2list starti (endi-1)
			in
			let proc_liequ li = begin
				let ov_li  = List.map (fun x -> x+ li*final_index_oneinst) dff_curlst
				and rilst=lr2list (li+1) endi
				in
				let proc_riequ ri = begin
					let ov_ri  = List.map (fun x -> x+ ri*final_index_oneinst) dff_curlst
					in
					let ov_pair_lst=List.combine ov_li ov_ri
					in
					let (res_lst,cls_lstlst) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst)
					in
					let ov_pair_lst_shift=List.map (fun x -> match x with (v1,v2) -> (v1+(p+l+1+r)*final_index_oneinst,v2+(p+l+1+r)*final_index_oneinst)) ov_pair_lst
					in
					let (res_lst_shift,cls_lstlst_shift) = List.split (List.map (self#alloc_and_equ_res) ov_pair_lst_shift)
					and rii = self#alloc_index 1
					in begin
						self#append_clause_list_multiple ((List.concat cls_lstlst) @ (List.concat cls_lstlst_shift) @ (self#encode_Red_AND rii (res_lst @ res_lst_shift))) ;
						rii
					end
				end
				in
				List.map (proc_riequ) rilst
			end
			in 
			let li_equ_var_lst=List.concat (List.map (proc_liequ) lilst)
			and riii=self#alloc_index 1
			in begin
				self#append_clause_list_multiple (self#encode_Red_OR riii li_equ_var_lst);
				riii
			end
		end
	end

	method construct_varlst2assumption (p:int) (l:int) (r:int) = begin
		(*find the initial state index*)
		let dff_idxpair=List.filter (isdff_name_index) name_index_lst
		in
		let dff_name_list=List.map (fun x -> match x with (nm,_) -> nm) dff_idxpair
		in
		let initial_state_index_list=List.concat (List.map (self#name2idxlist) dff_name_list)
		in
		let shift2=(p+l+1+r)*final_index_oneinst
		in
		let initial_state_index_list2=List.map (fun x -> x+shift2) initial_state_index_list
		in (*find the protocol input index*)
		let ov=bv_instrlist
		and cycle_list=lr2list 0 (((p+l+1+r)*2)-1)
		in
		let input_cycle_i i = begin
			List.map (fun x -> x + i*final_index_oneinst) ov
		end 
		in (*expand them to every cycles*)
		let ov_all = List.concat ( List.map input_cycle_i cycle_list )
		in
		initial_state_index_list @ initial_state_index_list2 @ ov_all
	end

	method force_assertion arr_itpo1= begin
		let (topidx,last_index_new,clslst_2beappend)=encode_assertion arr_itpo1 last_index
		in begin(*this is the function enabler*)
			assert (topidx<=last_index_new);
			self#set_last_index last_index_new;
			self#append_clause_list_multiple (([topidx],"f i")::clslst_2beappend);
			()
		end
	end
	
	method reduce_p (p:int) (l:int) (d:int) infered_assertion_array_lst_old=begin
		if(p==0) then p
		else begin
			let (res,_)=self#findLR_checkO (p-1) l d infered_assertion_array_lst_old
			in begin
				if(res==UNSATISFIABLE) then self#reduce_p (p-1) l d infered_assertion_array_lst_old
				else p
			end
		end
	end
	
	method reduce_d (p:int) (l:int) (d:int) infered_assertion_array_lst_old=begin
		if(d==0) then d 
		else begin
			let (res,_)=self#findLR_checkO p l (d-1) infered_assertion_array_lst_old
			in begin
				if(res==UNSATISFIABLE) then self#reduce_d p l (d-1) infered_assertion_array_lst_old
				else d
			end
		end
	end
	
	method rmred (p:int) (l:int) (d:int) infered_assertion_array_lst_old =begin
		let resO  =self#rmred_check p l d infered_assertion_array_lst_old
		in begin
			if (resO==UNSATISFIABLE) then l
			else self#rmred p (l+1) d infered_assertion_array_lst_old
		end
	end

	method rmred_check (p:int) (l:int) (d:int) infered_assertion_array_lst_old=begin
		self#set_unlock_multiple ;

		self#set_clause_list_multiple [];
		self#set_last_index  final_index_oneinst;
		
		(*generate multiple instance, which bound is defined
		p instance for prefix 
		1 instance for current input 
		d instance for right expansion
		*2 for another expansion
		*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 ((p+1+d)*2))
		in begin
			self#set_clause_list_multiple clause_list_multiple_aux;
			self#set_last_index last_index_aux;
			()
		end
		;

		(*constrain the assertion wire*)
		if (List.length (List.filter (self#is_assertion) name_index_lst)) > 0 then
			self#append_clause_list_multiple (self#try_assertion 0 ((p+1+d)*2-1))
		else 
			print_endline "warning : not found assertion_shengyushen"
		;
		
		(*connect the first p+d instance*)
		self#append_clause_list_multiple (self#connect_multiple_instance_step3 0 (p+d)) ;
		
		(*connect the secnod p+d instance*)
		self#append_clause_list_multiple (self#connect_multiple_instance_step3 (p+1+d) ((p+1+d)*2-1)) ;
		
		(*force the output to be the same*)
		let ov=bv_outstrlist
		and outputframe_idx= lr2list (p+1+d-1-l+1) (p+1+d-1)
		in
		let ov_b_1 = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) ov) ) outputframe_idx)
		in
		let ov_b_2 = List.map (fun x -> x+(p+1+d)*final_index_oneinst) ov_b_1
		in
		let oclslist=self#encode_EQUV ov_b_1 ov_b_2 
		in
		self#append_clause_list_multiple  oclslist
		;
		
		(*force the input of to be diff*)
		let ov=bv_instrlist
		in 
		let ov_0 = List.map (fun x -> x+ (p)*final_index_oneinst) ov
		and ov_b = List.map (fun x -> x+ (p+p+1+d)*final_index_oneinst) ov
		in
		self#append_clause_list_multiple (self#encode_INEV (ov_0) (ov_b)) 
		;

		(*force the npi to be the same*)
		let npi_lst=bv_non_proctocol_input_list
		and npi_cycle_lst = lr2list 1 ((p+1+d)*2-1)
		in
		let proc_npi_cycle i = begin
			let npi_lst_i = List.map (fun x -> x+(i*final_index_oneinst)) npi_lst
			in
			self#append_clause_list_multiple (self#encode_EQUV (npi_lst) (npi_lst_i)) 
		end
		in
		List.iter proc_npi_cycle npi_cycle_lst
		;

		(*force the infered_assertion_array_lst_old to be invalid*)
		List.iter (fun x -> self#force_assertion (invert_assertion x)) infered_assertion_array_lst_old ;

		self#set_lock_multiple ;
		(*dump to sat*)
		dump_sat clause_list_multiple
	end

	method gen_characterizer_wrap_new  (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old =begin
		(*construct the relation of f*)
		assert(lock_oneinst==true);
		assert(lock_multiple==true);
		self#gen_relation_pld p1 l1 d1 infered_assertion_array_lst_old;
		assert(lock_oneinst==true);
		assert(lock_multiple==true);
		
		let outputframe_idx= lr2list (p1+1+d1-1-l1+1) (p1+1+d1-1)
		in
		let bv_O = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) bv_outstrlist) ) outputframe_idx)
		and bv_I = List.map (fun x -> x+ p1*final_index_oneinst) bv_instrlist
		and bv_C = bv_non_proctocol_input_list
		in
		let lst_idx_f = List.map (characterization_interp clause_list_multiple [] (bv_O@bv_C) ) bv_I
		in
		let lst_idx_idx_f = List.combine bv_I lst_idx_f
		in 
		let lst_idx_f_new = lst_idx_idx_f
		in
		let clause_list_multiple_old=clause_list_multiple (*save it to shift its bv_I to higher variables*)
		in begin
			self#set_unlock_multiple ;
			
			(*cover the original relation*)
			self#set_clause_list_multiple [];
			(*dont cover the last_index because some variables are already used in assertions*)
			(*self#set_last_index 3;*)
			
			let proc_idx_f idx_f = begin
				match idx_f with
				(idx,f) -> begin
					assert(idx!=0);
					let (topidx,last_index_new,clslst_2beappend)=encode_assertion f last_index
					in begin
						self#set_last_index last_index_new;
						self#append_clause_list_multiple clslst_2beappend;
						self#append_clause_list_multiple (self#encode_EQU idx topidx)
					end
				end
			end
			in
			List.iter proc_idx_f lst_idx_f_new
			;
			
			(*constrain the orignal clause_list_multiple by moving its bv_I to higher variables*)
			let maxidx_f=get_largest_varindex_inclslst clause_list_multiple
			in
			let clause_list_multiple_shiftedR=shiftclslst_shiftsomevar clause_list_multiple_old bv_I maxidx_f
			in begin
				(*self#append_clause_list_multiple clause_list_multiple_shiftedR;*)
				self#set_last_index (get_largest_varindex_inclslst (clause_list_multiple@clause_list_multiple_shiftedR));

				(*we need to constrain the bv_C*)
				List.iter (fun x -> self#force_assertion (invert_assertion x)) infered_assertion_array_lst_old ;
			
				self#set_lock_multiple ;
			
				clause_list_multiple_f <- clause_list_multiple ;
				last_index_f <- last_index ;
			
				assert(lock_oneinst==true);
				assert(lock_multiple==true);
				self#gen_characterizer_wrap  p1 l1 d1 infered_assertion_array_lst_old clause_list_multiple_old
			end
		end
	end

	method gen_characterizer_wrap  (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old clause_list_multiple_R=begin
		assert(lock_oneinst==true);
		assert(lock_multiple==true);
		(* this is functional depedency test *)
		let c_litlst_new = ref []
		and clist = ref []
		and fd_res = ref (UNSATISFIABLE,[])
		and fd_res_SAT = ref UNSATISFIABLE
		and bv_C = ref []
		in
		begin
			(*1. while loop until FD OK*)
			fd_res := self#fd_test_I p1 l1 d1 infered_assertion_array_lst_old (!clist) clause_list_multiple_R;
			assert(lock_oneinst==true);
			assert(lock_multiple==true);
			fd_res_SAT := fst (!fd_res) ; 
			bv_C := snd (!fd_res) ; 
			while ((!fd_res_SAT)!=UNSATISFIABLE) do
				assert ((!fd_res_SAT)==SATISFIABLE);
				let shiftnum_standalone_f = (List.length (!clist))*last_index_f
				in
				let c_litlst_new1 = List.map get_assignment_lit (!bv_C) 
				in
				let proc_mapback i =begin
					if(i>0) then begin
						assert (i>shiftnum_standalone_f) ;
						i-shiftnum_standalone_f
					end
					else begin
						assert (i<(-shiftnum_standalone_f)) ;
						i+shiftnum_standalone_f
					end
				end
				in
				c_litlst_new := List.map proc_mapback c_litlst_new1 
				;
				
				(*printf "c_litlst_new ";
				let proc_print_idxname varidx = begin
					if (varidx>0) then begin
						self#idx2name varidx
					end
					else if (varidx<0) then begin
						sprintf "!%s " (self#idx2name (-varidx))
					end
					else assert false
				end
				in
				List.iter (fun x -> printf " %s" (proc_print_idxname x)) (!c_litlst_new)
				;
				printf "\n";
				
				printf "bv_C ";
				List.iter (fun x -> printf " %d" x) (!bv_C)
				;
				printf "\n";*)
				
				assert(lock_oneinst==true);
				assert(lock_multiple==true);
				clist := (!c_litlst_new) :: (!clist) ;
				fd_res := self#fd_test_I p1 l1 d1 infered_assertion_array_lst_old (!clist) clause_list_multiple_R;
				fd_res_SAT := fst (!fd_res) ; 
				bv_C := snd (!fd_res) ; 
			done
			;
			assert ((!fd_res_SAT)==UNSATISFIABLE);

			printf "all OK with clist length %d\n" (List.length (!clist)) ;

			(*clist := self#uniquify (!clist) ;

			printf "reduced clist length %d\n" (List.length (!clist)) ;*)
			
			let prt_idx idddx= begin
				if(idddx>0) then 
					printf " %s" (self#idx2name idddx)
				else 
					printf " !%s" (self#idx2name (-idddx))
			end
			in
			List.iter (fun x -> begin List.iter prt_idx x ; printf "\n" end) (!clist) ;
			
			assert(lock_oneinst==true);
			assert(lock_multiple==true);
			(*generate the h function*)
			let ialst=self#gen_IA_I p1 l1 d1 infered_assertion_array_lst_old (!clist)
			in
			let iac_list=List.combine ialst (!clist)
			in(*remove 1'b0 h functions and their c*)
			(*let iac_list_new = List.filter (fun x -> match x with (ia,_) -> if((ia.((Array.length ia)-1))==TiterpCircuit_false ) then false else true ) iac_list*)
			let iac_list_new = iac_list
			in
			let iarange=lr2list 0 ((List.length iac_list_new)-1)
			in
			let idxialst=List.combine iarange iac_list_new
			in
			let  proc_prt_idxia idxia= begin
				match idxia with
				(idx,(ia,_)) -> begin
					printf "\n-----------the %d-th h function-------------\n" idx;
					self#print_itpo ia;
					printf "\n-----------end of the %d-th h function-------------\n" idx
					
				end
			end
			in begin
				List.iter (proc_prt_idxia) idxialst;
				clist := List.map (fun x -> match x with (_,(_,cc)) -> cc) idxialst;
			end
			;
			assert(lock_oneinst==true);
			assert(lock_multiple==true);
			(*generate these functions iteratively*)
			let rng_clist= lr2list 0 ((List.length (!clist))-1)
			in
			let rng_clist_cmd=List.combine rng_clist (!clist)
			in begin
				List.iter (self#fd_test_gen_char p1 l1 d1 infered_assertion_array_lst_old ) rng_clist_cmd 
			end
			;
			()
		end
	end
	
	
	method fd_test_gen_char (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old cb = begin
		assert(lock_oneinst==true);
		assert(lock_multiple==true);
		match cb with
		(i,c) -> begin
			let new_arr_itpo= Array.make 2 TiterpCircuit_none
			in begin
				(*gen_characterizer will call gen_relation_pld to falsify assertion
				so we must generate it in negate form*)
				Array.set new_arr_itpo 1 (TiterpCircuit_or(List.map (fun x -> TiterpCircuit_refvar(-x)) c));
				(*Array.set new_arr_itpo 1 (TiterpCircuit_and(List.map (fun x -> TiterpCircuit_refvar(x)) c));*)
				
				self#gen_characterizer  p1 l1 d1 [new_arr_itpo] i
			end
		end
	end
	
	method gen_IA_I (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old clist = begin
		self#set_unlock_multiple ;
		(*restore the clause_list_multiple to init*)
		self#set_clause_list_multiple [];
		self#set_last_index last_index_f;
		
		(*construct a list of relation for clist by shifting
		but their output seq should not be shifted*)
		let ov=bv_outstrlist
		and outputframe_idx= lr2list (p1+1+d1-1-l1+1) (p1+1+d1-1)
		in
		let ov_b_1 = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) ov) ) outputframe_idx)
		in begin
			self#encode_clist_R 0 clist ov_b_1;
			
				(*printf "last_index %d ought to be %d\n" last_index ((List.length clist)*last_index_f);
				flush stdout;*)
			
			(*encode the relation of standalone f*)
			let shiftnum_standalone_f = (List.length clist)*last_index_f
			in begin
				self#append_clause_list_multiple (shiftclslst clause_list_multiple_f ov_b_1 shiftnum_standalone_f) ;
				self#set_last_index (((List.length clist)+1)*last_index_f);
				()
			end
			;
			
			(*enforce the clist*)
			self#encode_clist_C 0 clist;
			
			self#set_lock_multiple ;
			
			let shiftnum_standalone_f = (List.length clist)*last_index_f
			in
			let bv_C = List.map (fun x -> x+ shiftnum_standalone_f) bv_non_proctocol_input_list
			in
			let iv_p= List.map (fun x -> x+ p1*final_index_oneinst) bv_instrlist
			and notshift_rng_lst= lr2list 0 ((List.length clist)-1)
			in
			let proc_iv_p ip = begin
				let dont_shift_iv_n1_n = bv_C @ (List.map (fun r -> ip + r*last_index_f) notshift_rng_lst)
				and target_R = ip+(List.length clist)*last_index_f
				in
				let new_assertion_preBDD=characterization_interp clause_list_multiple [] dont_shift_iv_n1_n target_R
				in
				simplify_withBDD new_assertion_preBDD ddM
			end
			in
			let asslst=List.map (proc_iv_p) iv_p
			in
			let  proc_c r = begin
				let proc_c_ass ass = begin
					let proc_comp_c_ass i = begin
						List.map (fun ip-> ip+(i*last_index_f)) iv_p
					end
					in
					let tobeclearlist=List.filter (fun x -> if (x==r) then false else true) notshift_rng_lst
					in begin
						let allidxlst=List.concat (List.map (proc_comp_c_ass) tobeclearlist)
						in
						let assumptionlist1=List.map (fun x -> -x) allidxlst
						and assumptionlist2=List.map (fun x -> x+(r*last_index_f)) iv_p
						in
						simplify_withBDD_withassumption ass (assumptionlist2 @ assumptionlist1) ddM
					end
				end
				in
				let r_asslst=List.map (proc_c_ass) asslst
				in 
				let (newitpoarr,newrandlst)=construct_ITPLST r_asslst
				in 
				let finalrand=Array.make 1 TiterpCircuit_none
				in begin
					Array.set finalrand 0 (TiterpCircuit_and(List.map (fun x -> TiterpCircuit_refcls(x)) newrandlst));
					let randitpoarr=Array.append newitpoarr finalrand
					in
					simplify_withBDD randitpoarr ddM
				end
			end
			in
			List.map (proc_c) notshift_rng_lst
		end
		
	end
	

	method fd_test_I (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old clist clause_list_multiple_R= begin
		printf "fd_test \n";
		flush stdout;
		(*we already encode the characterized function with c*)
		
		self#set_unlock_multiple ;
		
		(*restore the clause_list_multiple to init*)
		self#set_clause_list_multiple [];
		self#set_last_index last_index_f;
		
		(*construct a list of relation for clist by shifting
		but their output seq should not be shifted*)
		let ov=bv_outstrlist
		and outputframe_idx= lr2list (p1+1+d1-1-l1+1) (p1+1+d1-1)
		in
		let ov_b_1 = List.concat (List.map (fun frmidx -> (List.map (fun x -> x+ frmidx*final_index_oneinst) ov) ) outputframe_idx)
		in begin
			self#encode_clist_R 0 clist ov_b_1;
			
			(*encode the relation of standalone f*)
			let shiftnum_standalone_f = (List.length clist)*last_index_f
			in begin
				self#append_clause_list_multiple (shiftclslst clause_list_multiple_R ov_b_1 shiftnum_standalone_f);
				self#set_last_index (((List.length clist)+1)*last_index_f);
				()
			end
		end
		;
		
		(*enforce the clist*)
		self#encode_clist_C 0 clist;
		
		let shiftnum_standalone_f = (List.length clist)*last_index_f
		in
		let bv_C = List.map (fun x -> x+ shiftnum_standalone_f) bv_non_proctocol_input_list
		and bv_I_p = List.map (fun x -> x+ p1*final_index_oneinst) bv_instrlist
		and bv_I_rangelist = if((List.length clist)==0) then [] else lr2list 0 ((List.length clist)-1)
		in
		let proc_bvI_diff x = begin
			let bv_I_p_rng_x = List.map (fun y -> y+x*last_index_f) bv_I_p
			and bv_I_p_final = List.map (fun y -> y+(List.length clist)*last_index_f) bv_I_p
			in
			self#encode_INEV bv_I_p_rng_x bv_I_p_final
		end
		in begin
			(*constrain that R_i's input diff that of R*)
			let neq_clslst=List.concat (List.map (proc_bvI_diff) bv_I_rangelist)
			in
			self#append_clause_list_multiple neq_clslst
			;
			
			self#set_lock_multiple ;
			
			(*now we need to test its SAT*)
			let satres=dump_sat clause_list_multiple
			in
			(satres,bv_C)
		end
		
	end



	
	method encode_clist_C i clist = begin
		match clist with 
		[] -> ()
		| c::ctl -> begin
			self#encode_C i c ;
			self#encode_clist_C (i+1) ctl 
		end
	end

	method encode_C i c = begin
		let shift_lit l =begin
			if (l>0) then l+(i*last_index_f)
			else l-(i*last_index_f)
		end
		in
		let c_i = List.map shift_lit c
		and new_arr_itpo= Array.make 2 TiterpCircuit_none
		in begin
			Array.set new_arr_itpo 1 (TiterpCircuit_and(List.map (fun x -> TiterpCircuit_refvar(x)) c_i));
			self#force_assertion new_arr_itpo
		end
	end
	
	method encode_clist_R i clist dontshift_lst = begin
		match clist with 
		[] -> ()
		| c::ctl -> begin
			self#encode_R i c dontshift_lst;
			self#encode_clist_R (i+1) ctl dontshift_lst
		end
	end
	
	method encode_R i c dontshift_lst = begin
		self#append_clause_list_multiple (shiftclslst clause_list_multiple_f dontshift_lst (i*last_index_f))  ;
		self#set_last_index ((i+1)*last_index_f);
	end
	
	(*p means the prefix , l1 means the length of output, d1 means the delay*)
	method gen_relation_pld  (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old =begin
		self#set_unlock_multiple ;

		let bd=p1+1+d1
		and d=d1
		and p=p1
		and f=l1
		and l=1
		in
		let nl_const_cnfname=   String.concat "" [tempdirname ; "dumpout/nl_const_"    ; name ;"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f);".cnf"]
		in begin
			(*to dump out an instance from 0 to bd-1*)
			(*nl_const cnf construction*)
			let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 bd)
			in begin
				self#set_clause_list_multiple clause_list_multiple_aux;
				self#set_last_index last_index_aux;
				()
			end
			;
			self#append_clause_list_multiple (self#connect_multiple_instance_step3 0 (bd-1));

			let assertion_shengyushen="assertion_shengyushen"
			in
			let constrain_assertion li = begin (*li is from bound-1 to 0*)
				let ov=List.concat (List.map self#name2idxlist [assertion_shengyushen])
				in 
				let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
				in
				List.map (fun x -> ([x],"assertion_shengyushen") ) ov_0
			end
			in
			let rec try_assertion li = begin
				if(li<0) then []
				else begin
					let old_assclslst=constrain_assertion li
					and cur_assclslst=try_assertion (li-1)
					in
					old_assclslst@cur_assclslst
				end
			end
			in begin
				if List.length (List.filter (fun x -> match x with (nm,_) -> string_equ nm assertion_shengyushen ) name_index_lst) > 0 then
					self#append_clause_list_multiple (try_assertion (bd-1))
				else 
					print_endline "warning : not found assertion_shengyushen"
			end
			;
			
			(*force the npi to be the same*)
			let npi_lst=bv_non_proctocol_input_list
			and npi_cycle_lst = lr2list 1 (bd-1)
			in
			let proc_npi_cycle i = begin
				let npi_lst_i = List.map (fun x -> x+(i*final_index_oneinst)) npi_lst
				in
				self#append_clause_list_multiple (self#encode_EQUV (npi_lst) (npi_lst_i))
			end
			in
			List.iter proc_npi_cycle npi_cycle_lst
			;
		
			(*force the infered_assertion_array_lst_old to be invalid*)
			List.iter (fun x -> self#force_assertion (invert_assertion x)) infered_assertion_array_lst_old ;
			
			self#set_lock_multiple ;
		end
	end
	
	(*p means the prefix , l1 means the length of output, d1 means the delay*)
	method gen_characterizer  (p1:int) (l1:int) (d1:int) infered_assertion_array_lst_old dec_counter =begin
		assert(lock_oneinst==true);
		assert(lock_multiple==true);
		self#gen_relation_pld p1 l1 d1 infered_assertion_array_lst_old;
	
		let bd=p1+1+d1
		and d=d1
		and p=p1
		and f=l1
		and l=1
		in
		let nl_const_cnfname=   String.concat "" [tempdirname ; "dumpout/nl_const_"    ; name ;"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f);"_dec_counter";string_of_int(dec_counter);".cnf"]
		in begin
					let nl_const_cnf = open_out nl_const_cnfname
					in
					self#print_cnf clause_list_multiple nl_const_cnf d l p f
					;
					close_out nl_const_cnf
					;
					
					let continue_scr_name = "continue.scr"
					in
					let exist_or_not = Sys.file_exists continue_scr_name
					in
					let continue_scr = begin
						if (exist_or_not) then
							open_out_gen [Open_wronly; Open_append; Open_text] 0o666 continue_scr_name
						else begin
							open_out_gen [Open_wronly; Open_append; Open_text; Open_creat] 0o666 continue_scr_name
						end
					end
					in
					begin
						(*replace above anchor based appraoches with directly generated dependent file, from output to input*)
						let dependent_fl = open_out "dependent"
						in
						let iv=List.concat (List.map self#name2idxlist instrlist)
						and ov=List.concat (List.map self#name2idxlist outstrlist)
						in
						let iv_shift=List.map (fun x -> x+final_index_oneinst*p) iv
							and ov_all=begin
							let rec ov_all_rec s e = begin
								if(s<e) then (List.map (fun x -> x+final_index_oneinst*s) ov) @ (ov_all_rec (s+1) e)
								else []
							end
							in
							ov_all_rec (p+d-f) (p+d+l)
						end
						in
						let print_inshift_elem i = begin
							fprintf dependent_fl "%d ======== " i;
							List.iter (fun x -> fprintf dependent_fl " %d " x) ov_all;
							fprintf dependent_fl "\n";
						end
						in
						List.iter print_inshift_elem iv_shift
						;
						close_out dependent_fl
						;
						if (exist_or_not==false) then begin
							let rm_cmd=String.concat "" ["#!/bin/sh"]
							in
							fprintf continue_scr "%s\n"  rm_cmd
						end
						;
						let rm_cmd=String.concat "" ["rm -f resolve_trace "]
						in
						fprintf continue_scr "%s\n"  rm_cmd
						;
						let nl_const_cmd=String.concat "" ["nl_const_minisat " ; nl_const_cnfname ; " 100 |tee nl_const.log"] (*use 100s as timeout value, to prevent us from stuck at a hopeless long run*)
						in
						fprintf continue_scr "%s\n"  nl_const_cmd
						;
						fprintf continue_scr "mv resulting_dual_cnf.v resulting_dual_cnf_%d.v\n"  dec_counter
						;
						close_out continue_scr
					end
					;
		end
	end
	
	(*src_i<dst_i*)
	method connect_dffpair src_i dst_i dffpair = begin
	   if (src_i>=dst_i) then begin
		Printf.printf "connect_dffpair src_i %d must smaller than dst_i %d\n" src_i dst_i;
		exit 1
	   end
	   else begin
		match dffpair with
		(nm,(current_idx,next_index)) -> begin
			(*make sure it is actually dff*)
			if self#isdff nm then begin
				let current_off=dst_i*final_index_oneinst
				and next_off   =src_i*final_index_oneinst
				in
				let new_current_idx=current_off+current_idx
				and new_next_index =next_off+next_index
				in 
				let (rli,rlr)=rng2lr (self#name2range nm)
				in
				let (rli_real_cur,rlr_real_cur)=rng2lr (construct_range_onidx new_current_idx rli rlr)
				and (rli_real_nxt,rlr_real_nxt)=rng2lr (construct_range_onidx new_next_index rli rlr)
				in begin
					if (rli_real_cur==new_current_idx) && (new_current_idx-new_next_index==final_index_oneinst*(dst_i-src_i)-(abs(rlr-rli)+1)) && (rli_real_cur-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1==rli_real_nxt) then begin
						(*encode every bit in this range*)
						let rec connect_1bitdff idxi idxr = begin
							if idxi>idxr then []
							else begin
								let oldcl = connect_1bitdff (idxi+1) idxr
								and newmapped = (self#encode_EQU idxi (idxi-final_index_oneinst*(dst_i-src_i)+abs(rlr-rli)+1))
								in
								let newmapped_commented= List.map (setcomment (sprintf "connecting dff %s from instance %d to %d" nm src_i dst_i)) newmapped 
								in
								newmapped_commented @ oldcl
							end
						end
						in
						connect_1bitdff rli_real_cur rlr_real_cur
					end
					else begin
						Printf.printf "fatal error : improper connect_dffpair\n";
						Printf.printf "rli_real_cur %d\n" rli_real_cur;
						Printf.printf "rlr_real_cur %d\n" rlr_real_cur;
						Printf.printf "new_current_idx %d\n" new_current_idx;
						Printf.printf "new_next_index %d\n" new_next_index;
						Printf.printf "rlr %d\n" rlr;
						Printf.printf "rli %d\n" rli;
						Printf.printf "final_index_oneinst %d\n" final_index_oneinst;
						Printf.printf "rli_real_nxt %d\n" rli_real_nxt;
						Printf.printf "rlr_real_nxt %d\n" rlr_real_nxt;
						exit 1
					end
				end
			end
			else begin
				Printf.printf "fatal error : it should be dff\n";
				exit 1
			end
		end
	   end
	end


	(*to connect next state of one instance to current state of last instance*)
	method connect_multiple_instance_step3 start_bound end_bound = begin
		let dff_idxpair=List.filter (isdff_name_index) name_index_lst
		in 
		let rec connect_inst i = begin
			if i == end_bound then []
			else begin
				let connect_current_instance = List.map (self#connect_dffpair i (i+1)) dff_idxpair
				and further_connection = connect_inst (i+1)
				in
				(List.concat connect_current_instance) @ further_connection
			end
		end
		in
		connect_inst start_bound
	end


	method encode_instance ii= begin
		let off=ii*final_index_oneinst
		in 
		let cls_off offf cls = begin
			let lit_off offff lit= begin
				if lit > 0 then lit+offff
				else lit -offff
			end
			in
			(List.map (lit_off offf) (fst cls)),(snd cls)
			(* avoiding adding comment to save time *)
			(*appendcomment (cat_string "instance " (string_of_int ii)) ((List.map (lit_off offf) (fst cls)),(snd cls)) *)
		end
		in
		List.map (cls_off off) clause_list
	end

	(*generate multiple instance, which bound is the number*)
	method gen_multiple_instance_step2 num = begin
		let lrlst=lr2list 0 (num-1)
		in
		let clslst_lst=List.map (self#encode_instance) lrlst
		in
		((List.concat clslst_lst),(final_index_oneinst*num))
	end

	(* encoding the transition relation*)
	method encode_oneInstance2SAT_step1  = begin
		(*index for explictly named vars, such as input output wire reg dff*)
		self#encode2SAT_explictname;
		(*this is the true encode*)

		(*Printf.printf "start to do 1 encode2SAT_explictname \n" ;*)


		(*encode the seq_always_list*)
		let seq_clslst=self#encode2SAT_seq_always_list truepred
		and comb_clslst=self#encode2SAT_comb_always_list truepred
		and cont_clslst=self#encode2SAT_contass_list
		in
		seq_clslst@comb_clslst@cont_clslst
	end
	
	method encode2SAT_contass_list = begin
		(*Printf.printf "start to do 1 encode2SAT_contass_list \n" ;*)
		List.concat (List.map (self#encode_ass) cont_ass_list)
	end
	
	method encode_ass ass = begin
		match ass with
		T_assignment(lv,exp) -> begin
			let truepred=1
			in 
			self#encode_nba_incomb (T_non_blocking_assignment_direct(lv,exp)) truepred
		end
	end
	
	method encode2SAT_comb_always_list envpred = begin
		(*Printf.printf "start to do 1 encode2SAT_comb_always_list \n" ;*)
		let encode_comb_always comb_always = begin
			match comb_always with
			(stat,_) -> self#encode_statement_incomb envpred stat   
		end
		in
		List.concat (List.map encode_comb_always comb_always_list)
	end
	
	method encode_statement_incomb envpred stat = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_incomb dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_incomb nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predclslst)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex ,(self#encode_Red_AND oldindex [envpred;expidx] ))
				end
				in
				newpred_clslst @ (self#encode_statement_incomb newpred stat_sub  ) @ predclslst
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predclslst)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in 
				let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
				and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
				in 
				predclslst @ thenpredclslist @ elsepredclslist @ (self#encode_statement_incomb thenpred stat1) @ (self#encode_statement_incomb elsepred stat2 )
			end
		end
		| T_case_statement(exp,cilst) -> begin
			let rec case2ifelse cl = begin
				match cl with
				[] -> begin
					Printf.printf "fatal error : you should not reach [] in case statement\n";
					exit 1
				end
				| [T_case_item_normal(explst,st1);T_case_item_default(stlast)] -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,stlast)
				end
				| (T_case_item_normal(explst,st1))::tl -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,(case2ifelse tl))
				end
				| _ -> begin
					Printf.printf "fatal error : you should not reach here in case statement\n";
					exit 1
				end
			end
			in
			self#encode_statement_incomb envpred (case2ifelse cilst)
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_incomb envpred) statlst  )
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	
	method encode2SAT_seq_always_list envpred= begin
		(*Printf.printf "start to do 1 encode2SAT_seq_always_list \n" ;*)
		let encode_seq_always seq_always = begin
			match seq_always with
			(stat,_) -> self#encode_statement_inseq envpred stat   
		end
		in
		List.concat (List.map encode_seq_always seq_always_list)
	end
	
	method encode_nba_incomb nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_incomb only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_incomb lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method encode_statement_inseq envpred stat  = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_inseq nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predcl)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex,(self#encode_Red_AND oldindex [envpred;expidx]))
				end
				in 
				predcl @ newpred_clslst @ (self#encode_statement_inseq newpred stat_sub)
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predcl)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in begin
					let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
					and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
					in 
					predcl @ (thenpredclslist @ elsepredclslist) @ (self#encode_statement_inseq thenpred stat1) @ (self#encode_statement_inseq elsepred stat2 )
				end
			end
		end
		| T_case_statement(exp,cilst) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_case_statement\n";
			exit 1
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_inseq envpred) statlst)
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	(*return positive , negative index and clause list*)
	method encode_pred exp = begin
		let (idxlst,cl)= self#encode_exp exp
		in 
		let idx=begin
			match idxlst with
			[pred] -> pred
			| _ -> begin
				Printf.printf "fatal error : invalid length of encode_pred\n";
				exit 1
			end
		end
		in 
		(*negative relationship*)
		let oldindex = self#alloc_index 1
		in
		(idx,oldindex,(self#encode_NEG idx oldindex)@cl)
	end
	(*return the list of exp bit and list of clause*)
	method encode_prim prim = begin
		match prim with
		T_primary_num(num) -> self#encode_number num 
		| T_primary_id([name]) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1  (*even for a dff, prim will always use current state*)
			end
			and rng=self#name2range name
			in 
			((rng_baseidx_2_idxlist rng baseidx),[])
		end
		| T_primary_id([]) -> begin
			Printf.printf "fatal error : not supported T_primary_id with zero string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_id(idlst) -> begin
			Printf.printf "fatal error : not supported T_primary_id with multiple string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)=rng2lr rng
					in 
					([offset2idx left right baseidx off],[])
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_primary_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=lr2list li ri
			and (left,right)=rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					((List.map (fun x -> offset2idx left right baseidx x) idxlst),[])
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| T_primary_minmaxexp(T_mintypmax_expression_1(exp)) -> self#encode_exp exp
		| T_primary_concat(explst) -> begin
			let (resv,rescls) = List.split (List.map (self#encode_exp) explst)
			in
			((List.concat resv),(List.concat rescls))
		end
		| _ -> begin
			Printf.printf "fatal error : not supported encode_prim\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
	end
	(*return the list of exp bit and list of clause*)
	method encode_number num = begin
		match num with
		T_number_unsign(i) -> begin
			let strlst=(List.rev (Misc2.int2bin i))
			in begin
				let rec proc_intlst slst = begin
					match slst with
					[] -> []
					| hd::tl -> begin
						match hd with
						"0" -> falsepred::(proc_intlst tl)
						| "1" -> truepred::(proc_intlst tl)
						| _ -> begin
							Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
							exit 1
						end
					end
				end 
				in
				((proc_intlst strlst),[])
			end
		end
		| T_number_base(len,base,str) -> begin
			if base=='b' || base=='B' then begin
				if String.length str == len then begin
					let numlst = Misc.string2charlist str 
					in begin
						let rec proc_numlst nl = begin
							match nl with
							[] -> []
							| hd::tl -> begin
								match hd with
								'0' -> 	falsepred::(proc_numlst tl)
								| '1' -> truepred::(proc_numlst tl)
								| _ -> begin
									Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
									exit 1
								end
							end
						end
						in
						((proc_numlst numlst),[])
					end
				end
				else begin
					Printf.printf "fatal error : encode_prim length is not matched\n";
					exit 1
				end
			end
			else begin
				Printf.printf "fatal error : not supported base other than b or B in encode_prim\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : T_number_float is not supported\n";
			exit 1
		end
	end
	
	(*return the list of exp bit and list of clause*)
	method encode_exp exp = begin
		match exp with
		T_primary(prim) -> self#encode_prim prim
		| T_primary_4arrayassign(_) -> begin
			Printf.printf "fatal error : not supported T_primary_4arrayassign\n";
			exit 1
		end
		| T_add1(prim) -> self#encode_prim prim
		| T_sub1(prim) -> begin
			Printf.printf "fatal error : not supported T_sub1\n";
			exit 1
		end
		| T_logicneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in begin
				match bitlst with
				[idx] -> begin
					let oldindex = self#alloc_index 1
					in 
					([oldindex],(self#encode_NEG_ASSIGN oldindex idx )@clst)
				end
				| _ -> begin
					Printf.printf "fatal error : invalid length in T_logicneg\n";
					exit 1
				end
			end
		end
		| T_bitneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in
			let rec proc_bitlst bl = begin
				match bl with
				[] -> ([],[])
				| hd::tl -> begin
					let oldindex = self#alloc_index 1
					and (oldblst,oldclst)=(proc_bitlst tl)
					in 
					((oldindex::oldblst),(self#encode_NEG_ASSIGN oldindex hd)@oldclst)
				end
			end
			in
			let (bl,cl)=proc_bitlst bitlst
			in
			(bl,cl@clst)
		end
		| T_reduce_and(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_AND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nand(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NAND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_or(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_OR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nor(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NOR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_xor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xor\n";
			exit 1
		end
		| T_reduce_xnor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xnor\n";
			exit 1
		end
		| T_add2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let (addblst,addclst)=(self#encode_ADD vec1 vec2)
					in
					(addblst,(clslst1 @ clslst2 @ addclst))
				end
				else begin
					Printf.printf "fatal error : T_add2 length should be of the same\n";
					exit 1
				end
			end
		end
		| T_sub2(_,_) -> begin
			Printf.printf "fatal error : not supported T_sub2\n";
			exit 1
		end
		| T_mul2(_,_) -> begin
			Printf.printf "fatal error : not supported T_mul2\n";
			exit 1
		end
		| T_div(_,_) -> begin
			Printf.printf "fatal error : not supported T_div\n";
			exit 1
		end
		| T_mod(_,_) -> begin
			Printf.printf "fatal error : not supported T_mod\n";
			exit 1
		end
		| T_logic_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_equ_formular (List.tl plist))
							in
							((oldindex::bl), (self#encode_EQU_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_equ_formular pl
						and oldindex = self#alloc_index 1
						in 
						([oldindex], clslst1 @ clslst2 @ resclslst @ (self#encode_Red_AND oldindex reslst ) );
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_logic_ine(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_ine_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_ine_formular (List.tl plist))
							in
							((oldindex::bl),(self#encode_INE_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_ine_formular pl
						in
						let oldindex = self#alloc_index 1
						in 
						([oldindex] , clslst1 @ clslst2 @ resclslst @ (self#encode_Red_OR oldindex reslst ))
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_case_equ(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_equ\n";
			exit 1
		end
		| T_case_ine(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_ine\n";
			exit 1
		end
		| T_logic_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_AND oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_logic_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_OR oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_lt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_lt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_lt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_lt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_lt case001 %d" oldindex))
									and case01=([b1;-b2;oldindex],(sprintf "T_lt case01 %d" oldindex))
									and case10=([-b1;b2;-oldindex],(sprintf "T_lt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_lt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_lt case111 %d" oldindex))
									in 
									( oldindex , [case000;case001;case01;case10;case110;case111] @ oldclslst)
								end
							end
						end
					end
					in 
					let (b,cl)=proc_lt_formular pl
					in
					([b],cl@clslst1@clslst2)
				end
				else begin
					Printf.printf "fatal error : T_lt length must be equ\n";
					exit 1
				end
			end
		end
		| T_le(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_lt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_gt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_gt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_gt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_gt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_gt case001 %d" oldindex))
									and case01=([b1;-b2;-oldindex],(sprintf "T_gt case01 %d" oldindex))
									and case10=([-b1;b2;oldindex],(sprintf "T_gt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_gt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_gt case111 %d" oldindex))
									in 
									(oldindex, [case000;case001;case01;case10;case110;case111]@oldclslst )
								end
							end
						end
					end
					in 
					let (b,cl)=proc_gt_formular pl
					in
					([b],cl @ clslst1 @ clslst2 )
				end
				else begin
					Printf.printf "fatal error : T_gt length must be equ\n";
					exit 1
				end
			end
		end
		| T_ge(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_gt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_bit_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_and2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_and2 tl
							in 
							let andres=self#encode_AND2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_and2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_and2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_or2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_or2 tl
							in 
							let andres=self#encode_OR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_or2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_or2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_xor2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_xor2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_xor2 tl
							in 
							let andres=self#encode_XOR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_xor2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_xor2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_equ2 tl
							in 
							let andres=self#encode_EQU_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_equ2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_equ length must be equ\n";
					exit 1
				end
			end
		end
		| T_leftshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_leftshift\n";
			exit 1
		end
		| T_rightshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_rightshift\n";
			exit 1
		end
		| T_selection(predexp,exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			and (predv,clslstpred)=self#encode_exp predexp
			in begin
				if ((List.length vec1) == (List.length vec2) && (List.length predv)==1) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_sel pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_sel tl
							in 
							let equres=self#encode_SEL_res oldindex b1 b2 (List.hd predv) 
							in 
							((oldindex::lastres),(equres @ cl))
						end
					end
					in 
					let (bl,cl)=proc_sel pl
					in
					(bl,cl @ clslst1 @ clslst2 @ clslstpred)
				end
				else begin
					Printf.printf "fatal error : T_selection length must be equ and predv must be 1\n";
					exit 1
				end
			end
		end
		| T_string(_) -> begin
			Printf.printf "fatal error : not supported T_string\n";
			exit 1
		end
		| T_expression_NOSPEC(_) -> begin
			Printf.printf "fatal error : not supported T_expression_NOSPEC\n";
			exit 1
		end
	end
	
	method encode_ADD vec1 vec2 = begin
		let oldindex = self#alloc_index (List.length vec1)
		and carryidx = self#alloc_index (List.length vec1)
		in begin
			(*from oldindex to oldindex+(List.length vec1)-1 are the result of add operation*)
			(*from oldindex+(List.length vec1) to oldindex+(List.length vec1)*2-1 are the carry of add operation*)
			(*proc_add will generate one more bit,which means the carry*)
			let rec proc_add v1 v2 residx cryidx= begin
				match v1 with
				[] -> begin
					if (List.length v2 == 0) && (residx == oldindex+(List.length vec1)) && (cryidx==oldindex+(List.length vec1)*2) then 
						([falsepred],[]) (*to enforce 0 cryidx*)
					else begin
						Printf.printf "fatal error : improper T_add2\n";
						Printf.printf "v2 len %d\n" (List.length v2);
						Printf.printf "v1 len %d\n" (List.length v1);
						Printf.printf "vec2 len %d\n" (List.length vec2);
						Printf.printf "vec1 len %d\n" (List.length vec1);
						Printf.printf "residx %d\n" residx;
						Printf.printf "cryidx %d\n" cryidx;
						Printf.printf "oldindex %d\n" oldindex;
						Printf.printf "carryidx %d\n" carryidx;
						exit 1
					end
				end
				| hd1::tl1 -> begin
					let hd2=List.hd v2
					and tl2=List.tl v2
					in begin
						let (reslst,resclslst) = proc_add tl1 tl2 (residx+1) (cryidx+1)
						in begin
							 let carry=List.hd reslst
							 in begin 
							 	(*we would like 
							 		hd2+hd1+carry==(cryidx,residx)
							 	*)
							 	(cryidx::(residx::(List.tl reslst)),resclslst@(self#encode_ADD_1bit hd1 hd2 carry cryidx residx))
							 	
							 end
						end
					end
				end
			end
			in
			let (bl,cl)=(proc_add vec1 vec2 oldindex carryidx) (*we dont want the hgihest carry*)
			in
			((List.tl bl),cl)
		end
	end
	
	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin
		let cry000 = ([hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry001 = ([hd1;		hd2;		-1*carry;	-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry010 = ([hd1;		-1*hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry011 = ([hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry100 = ([-1*hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry101 = ([-1*hd1;		hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry110 = ([-1*hd1;		-1*hd2;		carry;		cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry111 = ([-1*hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and res000 = ([hd1;		hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res001 = ([hd1;		hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res010 = ([hd1;		-1*hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res011 = ([hd1;		-1*hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res100 = ([-1*hd1;		hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res101 = ([-1*hd1;		hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res110 = ([-1*hd1;		-1*hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res111 = ([-1*hd1;		-1*hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		in
		[cry000;cry001;cry010;cry011;cry100;cry101;cry110;cry111;res000;res001;res010;res011;res100;res101;res110;res111]
	end
	
	method encode_nba_inseq nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_inseq only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_inseq lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method addGuard clslist pred = begin
	   if (pred==1) then clslist
	   else begin
		let proc_cls cls = appendcomment (sprintf "guarded by %d" pred) (((-1*pred)::(fst cls)),(snd cls)) 
		in
		List.map proc_cls clslist
	   end
	end
	
	
	(*the first is the destination*)
	method encode_ASSIGN idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_ASSIGN %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_EQU %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_EQU %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU_res r b1 b2 = begin
		(*Printf.printf  "encode_EQU_res %d %d %d\n" b1 b2 r;*)
		let initlst=[([b1;b2;r],"");([-b1;-b2;r],"");([b1;-b2;-r],"");([-b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_EQU_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_EQUV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let ov_pair=List.combine l1 l2
			in
			List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) ov_pair) 
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_EQUV_res l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len1=(List.length l1)
			in
			let new_base = self#alloc_index len1
			and red_and_res = self#alloc_index 1
			in
			let new_var_lst = lr2list new_base (new_base+len1-1)
			in
			let ov_pair=List.combine l1 l2
			in
			let ov_pair_res=List.combine ov_pair new_var_lst
			in
			let cls_equ=List.concat (List.map (fun x -> match x with ((b1,b2),res) -> (self#encode_EQU_res res b1 b2)) ov_pair_res) 
			and cls_reduce = self#encode_Red_AND red_and_res new_var_lst
			in (*the target and the cls list*)
			(red_and_res,(cls_equ@cls_reduce))
		end
		else begin
			Printf.printf "fatal error : encode_EQUV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INEV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len=(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx=self#alloc_index len
			in 
			let rec enc pl1 idx= begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)=enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)=enc pl residx
			and redoridx=self#alloc_index 1
			in
			([redoridx],"redoridx")::((self#encode_Red_OR redoridx idxlst )@clslst)
		end
		else begin
			Printf.printf "fatal error : encode_INEV disequ\n" ;
			exit 1
		end
	end
	
	method encode_INE_res r b1 b2  = begin
		(*Printf.printf  "encode_INE_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;b2;-r],"");([-b1;-b2;-r],"");([b1;-b2;r],"");([-b1;b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_INE_res %s %s %s" (self#idx2name  r) (self#idx2name b1) (self#idx2name b2) ))  initlst
	end
	
	method encode_AND2_res r b1 b2  = begin
		(*Printf.printf  "encode_AND2_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;-r],"");([b2;-r],"");([-b1;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_AND2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_OR2_res r b1 b2 = begin
		(*Printf.printf  "encode_OR2_res %d %d %d\n"  r b1 b2;*)
		let initlst=[([-b1;r],"");([-b2;r],"");([b1;b2;-r],"")]
		in
		List.map (setcomment (sprintf "encode_OR2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_SEL_res r b1 b2 pred = begin
		(*Printf.printf  "encode_SEL_res %d %d %d %d\n" r b1 b2 pred;*)
		let initlst=[([-pred;b1;-r],"");([-pred;-b1;r],"");([pred;b2;-r],"");([pred;-b2;r],"")]
		in
		List.map (setcomment (sprintf "encode_SEL_res %s %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) (self#idx2name pred) )) initlst
	end
	
	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 
	
	method encode_NEG idx1 idx2 = begin
		(*Printf.printf  "encode_NEG %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx1;idx2],"");([-1*idx1;-1*idx2],"")]
		in
		List.map (setcomment (sprintf "encode_NEG %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	(*first is the target*)
	method encode_NEG_ASSIGN idx1 idx2 = begin
		(*Printf.printf  "encode_NEG_ASSIGN %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx2;idx1],"");([-1*idx2;-1*idx1],"")]
		in
		List.map (setcomment (sprintf "encode_NEG_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_Red_AND li bitlst  = begin
		(*Printf.printf  "encode_Red_AND %d\n"   li;*)
		(*first the -1 -2 -3 ... li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[li]),(sprintf "encode_Red_AND %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then i -li*)
		let proc_b b = ([b;(-1*li)],(sprintf "encode_Red_AND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)) )
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NAND li bitlst  = begin
		(*Printf.printf  "encode_Red_NAND %d\n"   li;*)
		(*first the -1 -2 -3 ... -li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[(-1*li)]),(sprintf "encode_Red_NAND %d to %s" (List.length bitlst) (self#idx2name li) ))
		in
		(*then i li*)
		let proc_b b = ([b;(li)],(sprintf "encode_Red_NAND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_OR li bitlst  = begin
		(*Printf.printf  "encode_Red_OR %d\n"   li;*)
		(*first the 1 2 3 ... -li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(-1*li)]),(sprintf "encode_Red_OR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i li*)
		let proc_b b = ([(-1*b);li],(sprintf "encode_Red_OR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NOR li bitlst  = begin
		(*Printf.printf  "encode_Red_NOR %d\n"   li;*)
		(*first the 1 2 3 ... li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(li)]),(sprintf "encode_Red_NOR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i -li*)
		let proc_b b = ([(-1*b);(-1*li)],(sprintf "encode_Red_NOR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode2SAT_explictname = begin
		let encode_explictname key cont = begin
		  let duplst= List.filter (fun x -> match x with (nm,_)-> string_equ nm key) name_index_lst
		  in begin
		    if ((List.length duplst) == 0)   then begin
			let rng= self#name2range key
			and dff = self#isdff key
			in begin
				(*the index is for left side of range*)
				if dff then begin(*dff will has two index, one for current state, the other for next state*)
					name_index_lst <- (key,(last_index,last_index+(get_rng_width rng)))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)*2
				end
				else begin
					name_index_lst <- (key,(last_index,-1))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)
				end
			end
		    end
		    else if ((List.length duplst) == 1) && (string_equ key "assertion_shengyushen") && (match (cont#get_obj) with Tobj_net_declaration(_)->true | Tobj_output_declaration(_)-> true |_ -> false)==true then begin
			Printf.printf "warning : %s is defined multiple times with %d\n" key (List.length duplst);
		    end
		    else begin
			Printf.printf "fatal error : %s is defined multiple times with %d\n" key (List.length duplst);
			exit 1
		    end
		  end
		end
		in
		Hashtbl.iter encode_explictname circuit_hst
	end
	
	
	(*
		some misc functions
	*)
	method map_lv2index lv = begin (*return the list of index from left to right*)
		(*
			note that, for dff, lv must be a next state, so use the second index
					for non-dff one, just use the first one
		*)
		match lv with  
		T_lvalue_id([name]) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			in 
			rng_baseidx_2_idxlist rng baseidx
		end
		| T_lvalue_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if is_inrange rng off then begin
					let (left,right)=rng2lr rng
					in 
					[offset2idx left right baseidx off]
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_lvalue_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=lr2list li ri
			and (left,right)=rng2lr rng
			in begin
				if (is_inrange rng li ) && (is_inrange rng ri )  then begin
					List.map (fun x -> offset2idx left right baseidx x) idxlst
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| _ -> begin
			Printf.printf "fatal error : not supported lv\n";
			exit 1
		end
	end
	
	
	method isdff name = begin
		let co = self#findco name
		in begin
			match co#get_obj with
			Tobj_dff_declaration(_) -> true
			| _ -> false
		end
	end

	method name2range name = begin
			match (self#findco name)#get_obj with
			Tobj_input_declaration(rng) -> rng
			| Tobj_output_declaration(rng) -> rng
			| Tobj_net_declaration(rng) -> rng
			| Tobj_reg_declaration(rng) -> rng
			| Tobj_dff_declaration(rng) -> rng
			| _ -> begin
				Printf.printf "fatal error : name2range not support Tobj\n";
				exit 1
			end
	end
	
	method idx2name idx_unmapped = begin
		let idx= begin (*we must be careful that we may use idx2name before finish encoding the first instance*)
			if final_index_oneinst==0 then idx_unmapped
			else if last_index_f<=final_index_oneinst then idx_unmapped mod final_index_oneinst
			else (idx_unmapped mod last_index_f) mod final_index_oneinst
		end
		in
		(*let ssy=List.filter (fun x -> match x with (nm,(idx1,idx2)) -> if (idx1==idx || idx2==idx) then true else false) name_index_lst
		in *)
		begin
			(*if (List.length ssy) == 1 then fst (List.hd ssy)
			else if  (List.length ssy) == 0 then*)
			begin
				(*it may be in range of some defined data*)
				let nm_idx1_li_ri_idx2name nm idx1 li ri idx = 
					let off=(construct_offset idx1 li ri idx)
					in begin
						if (off == -1) then nm
						else sprintf "%s[%d]" nm off
					end
				in
				let pred_inrange ni = begin
					match ni with
					(nm,(idx1,-1)) -> begin
						let (li,ri)=rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else ""
					end
					| (nm,(idx1,idx2)) -> begin
						let (li,ri)=rng2lr (self#name2range nm)
						in 
						if (is_inrange (construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else if (is_inrange (construct_range_onidx idx2 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx2 li ri idx)
						else ""
					end
					| _ -> ""
				end
				in
				let res = List.map pred_inrange name_index_lst 
				in
				let res1 = List.filter (fun x -> (String.length x) !=0) res
				in begin
					if (List.length res1)==1 then List.hd res1
					else "unknown"
				end
			end
			(*else begin
				Printf.printf "warning : idx2name multiple matched , # of match %d , idx = %d , final_index_oneinst=%d\n" (List.length ssy)  idx final_index_oneinst;
				List.iter (fun x -> match x with (nm,_) -> print_string nm) ssy;
				(*sometimes we will use temp vars to record the add carry bit and so on, they dont has defined name and mapping*)
				(*print_string "name_index_lst:\n";
				List.iter (fun x -> match x with (nm,(id1,id2)) -> Printf.printf "%s %d %d\n" nm id1 id2) name_index_lst;*)
				"unknown"
			end*)
		end
	end
	
	(*print_cnf*)
	method print_cnf clslst dumpout_cnf dly len prefix forward = begin
		check_cnf clslst;
		
		fprintf dumpout_cnf "p cnf %d %d\n" (get_largest_varindex_inclslst clslst) (List.length clslst);
		
		fprintf dumpout_cnf "c module_name  %s \n" name;
		
		List.iter (fun x -> fprintf dumpout_cnf "c module_port  %s \n" (get_str_from_strlst x)) portlist;
		
		(*leave a blank line for awk to exit from printing module definition *)
		fprintf dumpout_cnf "c module_def_end\n"  ;
		
		fprintf dumpout_cnf "c clkname %s\n" clkname;
		
		fprintf dumpout_cnf "c for_rev_cz final_index_oneinst %d\n" final_index_oneinst;
		
		fprintf dumpout_cnf "c for_rev_cz dly %d\n" dly;
		
		fprintf dumpout_cnf "c for_rev_cz len %d\n" len;
		
		fprintf dumpout_cnf "c for_rev_cz prefix %d\n" prefix;
		
		fprintf dumpout_cnf "c for_rev_cz forward %d\n" forward;
		
		(*print out the truepred list*)
		let proc_truepred cls = begin
			match cls with
			([pred],_) -> begin
				if pred > 0 then 
					fprintf dumpout_cnf "c pre_truepred %d\n" pred
			end
			| _ -> ()
		end
		in
		List.iter proc_truepred clslst
		;
		
		let left nm = match (rng2lr (self#name2range nm)) with (left,_)->left
		and right nm= match (rng2lr (self#name2range nm)) with (_,right)->right
		in begin
			List.iter (fun instr ->  fprintf dumpout_cnf "c for_rev_cz input %s %d %d\n"  instr  (left instr)  (right instr))  instrlist;
			List.iter (fun outstr -> fprintf dumpout_cnf "c for_rev_cz output %s %d %d\n" outstr (left outstr) (right outstr)) outstrlist;
		end
		;
		
		let proc_hst key co = begin
			match co#get_obj with
			Tobj_input_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c input_port %s\n" key 
					else
						fprintf dumpout_cnf "c input_port [%d:%d] %s\n" left right key 
				end
			end
			| Tobj_output_declaration(rng) -> 	begin
				match (rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c output_port %s\n" key 
					else
						fprintf dumpout_cnf "c output_port [%d:%d] %s\n" left right key 
				end
			end
			| _ -> ()
		end
		in
		Hashtbl.iter proc_hst circuit_hst
		;
		
		let print_name_index name_index = begin
			match name_index with
			(nm,(curidx,nxtidx)) -> begin
				fprintf dumpout_cnf "c one instance mapping %s %d %d " nm curidx nxtidx;
				match (rng2lr (self#name2range nm)) with
				(left,right) -> 
					fprintf dumpout_cnf "%d %d\n" left right
			end
		end
		in
		List.iter print_name_index name_index_lst
		;
		
		let print_clause cls = begin
			match cls with
			(litlst,cmt) -> begin
				fprintf dumpout_cnf "c %s\n" cmt;
				(*List.iter (fun lit -> if ( lit != -1 && lit != 2 ) then begin fprintf dumpout_cnf "%d " lit end) litlst ;*)
				List.iter (fun lit -> fprintf dumpout_cnf "%d " lit ) litlst ;
				fprintf dumpout_cnf "0\n"
			end
		end
		in
		List.iter print_clause clslst
	end

	method print_itpo arr_itpo = begin
			let size=Array.length arr_itpo
			in
			let rec interpObj2str interpObj = begin
				match interpObj with
				TiterpCircuit_true -> "1'b1"
				| TiterpCircuit_false -> "1'b0"
				| TiterpCircuit_refcls(clsidx) -> begin
					let itpo_nxt=arr_itpo.(clsidx)
					in interpObj2str itpo_nxt
				end
				| TiterpCircuit_refvar(varidx) -> begin
					if (varidx>0) then begin
						self#idx2name varidx
					end
					else if (varidx<0) then begin
						sprintf "!%s" (self#idx2name (-varidx))
					end
					else assert false
				end
				| TiterpCircuit_and(interpObjlst) -> begin
					let objreslst=List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " & " objreslst);")"]
				end
				| TiterpCircuit_or(interpObjlst) -> begin
					let objreslst=List.map (interpObj2str ) interpObjlst
					in
					String.concat " " ["(" ;(String.concat " | " objreslst);")"]
				end
				| TiterpCircuit_not(interpObj) -> begin
					let objres=interpObj2str interpObj
					in
					sprintf "!%s" objres
				end
				| TiterpCircuit_printed(clsidx) -> assert false
				| _ -> assert false
			end
			and prt_trace_withInterp num iter_res  = begin
				match iter_res with
				TiterpCircuit_none -> ()
				| _ -> begin
					let str_of_itpo=interpObj2str  iter_res
					in
					printf "%s" str_of_itpo
				end
			end
			in begin
				prt_trace_withInterp (size-1) arr_itpo.(size-1)
			end
	end

	
	(*for one inst*)
	method set_lock_oneinst = begin
		lock_oneinst <- true
	end
	
	method set_unlock_oneinst = begin
		lock_oneinst <- false
	end
	
	method append_clause_list_oneinst newclslst = begin
		assert (lock_oneinst==false);
		clause_list <- newclslst @ clause_list;
	end
	
	method set_clause_list_oneinst newclslst = begin
		assert (lock_oneinst==false);
		clause_list <- newclslst;
	end
	
	method set_last_index_oneinst newidx = begin
		assert (lock_oneinst==false);
		final_index_oneinst <- newidx;
	end
	
	
	(*for multiple*)
	method set_lock_multiple = begin
		check_clslst_maxidx clause_list_multiple last_index;
		lock_multiple <- true
	end
	
	method set_unlock_multiple = begin
		lock_multiple <- false
	end
	
	method append_clause_list_multiple newclslst = begin
		assert (lock_multiple==false);
		clause_list_multiple <- newclslst @ clause_list_multiple;
	end
	
	method set_clause_list_multiple newclslst = begin
		assert (lock_multiple==false);
		clause_list_multiple <- newclslst;
	end
	
	method set_last_index newidx = begin
		assert (lock_multiple==false);
		last_index <- newidx;
	end
	
	(*allocate last_index to last_index+num-1 , and set last_index to last_index+num*)
	method alloc_index num= begin
		let oldindex = last_index
		in begin
			last_index <- last_index+num;
			oldindex
		end
	end
	

end
