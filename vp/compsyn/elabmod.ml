open Typedef
open Circuit_obj
open Print_v
open Misc2
open Misc
open Statement
open Printf
open Misc2
open Print_v
open Dependent

exception UNSAT

type result = SATISFIABLE | UNSATISFIABLE

class elabmod = 
object (self)

	(*these will be generated in init method*)
	val mutable name = ""
	val mutable portlist = []
	val mutable tempdirname = ""
	
	(*these will be generated in elaborate method*)
	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 
	val mutable clkname = "" 
	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)
	val mutable comb_always_list : (statement*(string list)) list = []
	val mutable cont_ass_list : assignment list = []

	(*these will be generatesd in encode_oneInstance2SAT_step1 method*)
	(*
		relation between varaibles name and its index
		the int pair in name_index_lst is for dff only, 
			the first one is current state, 
			the second one is for next state, which should be the first one plus rng width
		for other case
			only the first one is meaningful
			the second one must be -1
		
	*)
	val mutable name_index_lst : (string*(int*int)) list = []  
	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)
	val mutable final_index_oneinst = 0
	val truepred = 1
	val falsepred =2
	(*these will generated by multiple instance generation*)

	val mutable clause_list_multiple : ((int list)*string) list = []

	val mutable clause_list_multiple_saved : ((int list)*string) list = []
	val mutable last_index_saved = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)

	method print dumpout = begin
		fprintf dumpout "module %s (\n" name;
		list_iter_interleave (fun x -> fprintf dumpout "   %s " (get_str_from_strlst x)) (fun x -> fprintf dumpout " , \n") portlist;
		fprintf dumpout "\n);\n";
		
		(*print out all input*)
		let print_input key cont = begin
			match cont#get_obj with
			Tobj_input_declaration(rng) -> begin
				fprintf dumpout "   input ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_input circuit_hst
		;
		
		(*print out all output*)
		let print_output key cont = begin
			match cont#get_obj with
			Tobj_output_declaration(rng) -> begin
				fprintf dumpout "   output ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_output circuit_hst
		;
		
		(*print out all wire*)
		let print_wire key cont = begin
			match cont#get_obj with
			Tobj_net_declaration(rng) -> begin
				fprintf dumpout "   wire ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_wire circuit_hst
		;
		
		(*print out all reg*)
		let print_reg key cont = begin
			match cont#get_obj with
			Tobj_reg_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| Tobj_dff_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_reg circuit_hst
		;
		
		(*print out all seq*)
		let print_seq seq_always = begin
			match seq_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(posedge %s) begin\n" clkname;
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_seq seq_always_list
		;
		
		(*print out all comb*)
		let print_comb comb_always = begin
			match comb_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(\n";
				
				let deplist= dep_statement stat
				in
				list_iter_interleave (fun x -> fprintf dumpout " %s " x) (fun x -> fprintf dumpout " or ") deplist
				;
				
				fprintf dumpout ") begin\n";
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_comb comb_always_list
		;
		
		(*print out all cont assign*)
		let print_cont_ass cont_ass = begin
			match cont_ass with
			T_assignment(lv,exp) -> begin
				fprintf dumpout "assign  ";
				print_v_lvalue dumpout lv;
				fprintf dumpout " = ";
				print_v_expression dumpout exp;
				fprintf dumpout ";\n"
			end
			| _ -> ()
		end
		in
		List.iter print_cont_ass cont_ass_list
		;
		
		
		fprintf dumpout "endmodule\n"
	end

	method getname = name

	method addco hn co = begin
		(*Printf.printf "adding %s\n" hn#getname ;*)
		Hashtbl.add circuit_hst hn#getname co
	end

	method rplco hn co = begin
		(*Printf.printf "replacing %s\n" hn#getname ;*)
		Hashtbl.replace circuit_hst hn#getname co
	end

	method findco_str str = begin
		self#findco (new hierachcal_name [str])
	end

	method findco hn = begin
		try 
			Hashtbl.find circuit_hst hn#getname 
		with Not_found -> begin
			Printf.printf "fatal error : undefined hn %s are treated as wire\n" hn#getname;
			exit 1
			(*following code is for those large number of undefined net*)
			(*self#addco hn (new circuit_obj (Tobj_net_declaration(T_range_NOSPEC,T_expression_NOSPEC(1)))  hn);
			Hashtbl.find circuitobj_hst hn#getname *)
		end
	end

	method nameInportlist name1 = begin
		let check_portname pt= begin
			match pt with 
			[ptn] -> string_equ ptn name1
			|_ -> begin
				Printf.printf "fatal error : port name should not be a list\n";
				exit 1
			end
		end
		in 
		let portfound = List.filter check_portname  portlist
		in begin
			if (List.length portfound) != 1 then begin
				Printf.printf "fatal error : portfound is not unique\n";
				exit 1
			end
		end
	end
	
	method proc_T_input_declaration range namelst = begin
		let proc_one_input name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let inCircuitObj = new circuit_obj (Tobj_input_declaration(range))  newhn
			in
			self#addco newhn inCircuitObj
		end
		in 
		List.iter proc_one_input namelst
	end
	
	method proc_T_output_declaration range namelst = begin
		let proc_one_output name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let outCircuitObj = new circuit_obj (Tobj_output_declaration(range))  newhn
			in
			self#addco newhn outCircuitObj
		end
		in 
		List.iter proc_one_output namelst
	end
	
	method proc_T_net_declaration nettypename exprng namelst = begin
		if (string_equ nettypename "wire") != true then begin
			Printf.printf "fatal error : only supported wire\n";
			Printf.printf "%s\n" nettypename;
			exit 1
		end
		;
		let rng = match exprng with
		T_expandrange_range(rng1) -> rng1
		| T_expandrange_NOSPEC -> T_range_NOSPEC
		|_ -> begin
			Printf.printf "fatal error : only supported T_expandrange_range\n";
			exit 1
		end
		in begin
			let proc_one_net netn = begin
				(*add it to circuit object list*)
				let newhn=new hierachcal_name [netn]
				in
				let netCircuitObj = new circuit_obj (Tobj_net_declaration(rng))  newhn
				in
				self#addco newhn netCircuitObj
			end
			in 
			List.iter proc_one_net namelst
		end
	end
	
	method proc_T_reg_declaration  rng regvarlst = begin
		let proc_one_reg regvar = begin
			(*add it to circuit object list*)
			match regvar with
			T_register_variables_ID(regname) -> begin
				let newhn=new hierachcal_name [regname]
				in
				let regCircuitObj = new circuit_obj (Tobj_reg_declaration(rng))  newhn
				in
				self#addco newhn regCircuitObj
			end
			| T_register_variables_IDrange(regname,lexp,rexp) -> begin
				Printf.printf "fatal error : not supported T_register_variables_IDrange\n";
				exit 1
			end
		end
		in 
		List.iter proc_one_reg regvarlst
	end
	
	method proc_T_continuous_assign cont_ass = begin
		let asslst = begin
			match cont_ass with
			T_continuous_assign_assign(_,_,asslst1) -> asslst1
			| T_continuous_assign_net(nettypename,_,exprng,_,asslst1) -> begin
				(*i need to first put them into circuit object list*)
				begin
					let ass2name ass = begin
						match ass with 
						T_assignment(lv,_) -> begin
							match lv with 
							T_lvalue_id([nm]) -> nm
							| _ -> begin
								Printf.printf "fatal error : only supported T_lvalue_id 2\n";
								exit 1
							end
						end
					end
					in
					let namelst = List.map ass2name asslst1
					in
					self#proc_T_net_declaration nettypename exprng namelst
				end
				;
				asslst1
			end
		end
		in  cont_ass_list <- asslst @ cont_ass_list
		(*begin
			let proc_ass ass = begin
				match ass with
				T_assignment(lv,exp) -> begin
					match lv with
					T_lvalue_id([nm]) -> begin
						let hn = new hierachcal_name [nm]
						in
						let rngold = begin
							match ((self#findco hn)#get_obj) with
							Tobj_net_declaration(rngo,_) -> rngo
							| _ -> begin
								Printf.printf "fatal error : only should find Tobj_net_declaration \n";
								exit 1
							end
						end
						in
						let co =new circuit_obj (Tobj_net_declaration(rngold,exp)) hn
						in
						self#rplco hn co
					end
					| T_lvalue_arrbit
					| _ -> begin
						Printf.printf "fatal error : only supported T_lvalue_id 1\n";
						print_v_lvalue stdout lv;
						exit 1
					end
				end
			end
			in
			List.iter proc_ass asslst
		end*)
	end
	
	method proc_T_always_statement_seq stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				if (List.length evexplst) != 1 then begin
					Printf.printf "fatal error : only supported sync set and reset regs\n";
					exit 1
				end
				;
				(*set the clock*)
				let clkeve=(List.hd evexplst)
				in begin
					match clkeve with 
					T_event_expression_posedge(exp) -> begin
						match exp with
						T_primary(T_primary_id([clkn])) -> begin
							if (string_equ clkname "") then clkname <- clkn
							else if (string_equ clkname clkn) then clkname <- clkn
							else begin
								Printf.printf "fatal error : only supported one clock\n";
								exit 1
							end
						end
						| _ -> begin
							Printf.printf "fatal error : only supported id as clock name\n";
							exit 1
						end
					end
					| _ -> begin
						Printf.printf "fatal error : only supported T_event_expression_posedge\n";
						exit 1
					end
				end
				;
				(*extract the reg name list*)
				let regnamelist = statement2regnamelist stat_sub
				in begin
					(*add these reg's definition to list*)
					seq_always_list <- (stat_sub,regnamelist) :: seq_always_list
					;
					(*change them to dff*)
					let proc_reg regname = begin
						let hn= new hierachcal_name [regname]
						in
						let co = self#findco hn
						in begin
							match co#get_obj with
							Tobj_reg_declaration(rngr) -> begin
								self#rplco hn (new circuit_obj (Tobj_dff_declaration(rngr)) hn)
							end
							| Tobj_dff_declaration(_) -> begin
								Printf.printf "warning : why it is already dff?\n";
								Printf.printf "%s\n" regname;
							end
							| _ -> begin
								Printf.printf "fatal error : object in always statement should be declared as reg\n";
								Printf.printf "%s\n" regname;
								exit 1
							end
						end
					end
					in
					List.iter proc_reg regnamelist
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement_comb stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			let regnamelist = statement2regnamelist stat_sub
			in
			comb_always_list <- (stat_sub,regnamelist) :: comb_always_list
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				let isedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> true
					| T_event_expression_negedge(_) -> true
					| _ -> false
				end
				and notedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> false
					| T_event_expression_negedge(_) -> false
					| _ -> true
				end
				in
				if (List.for_all isedgeevent evexplst) then self#proc_T_always_statement_seq stat
				else if (List.for_all notedgeevent evexplst) then self#proc_T_always_statement_comb stat
				else begin
					Printf.printf "fatal error : edge and non edge event at the same time\n";
					exit 1
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_MI mi= begin
		match mi with
		T_parameter_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_declaration\n";
			exit 1
		end
		| T_input_declaration(range,namelst) -> 
			self#proc_T_input_declaration range namelst
		| T_output_declaration(range,namelst) -> 
			self#proc_T_output_declaration range namelst
		| T_inout_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_inout_declaration\n";
			exit 1
		end
		| T_net_declaration(netname,_,exprng,_,namelst) -> 
			self#proc_T_net_declaration netname exprng namelst
		| T_reg_declaration(rng,regvarlst) -> 
			self#proc_T_reg_declaration rng regvarlst
		| T_time_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_time_declaration\n";
			exit 1
		end
		| T_integer_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_integer_declaration\n";
			exit 1
		end
		| T_real_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_real_declaration\n";
			exit 1
		end
		| T_event_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_event_declaration\n";
			exit 1
		end
		| T_gate_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_gate_declaration\n";
			exit 1
		end
		| T_module_instantiation(_) -> begin
			Printf.printf "fatal error : not supported T_module_instantiation\n";
			exit 1
		end
		| T_parameter_override(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_override\n";
			exit 1
		end
		| T_continuous_assign(cont_ass) ->  
			self#proc_T_continuous_assign cont_ass
		| T_specify_block(_) -> begin
			Printf.printf "fatal error : not supported T_specify_block\n";
			exit 1
		end
		| T_initial_statement(_) -> begin
			Printf.printf "fatal error : not supported T_initial_statement\n";
			exit 1
		end
		| T_always_statement(stat) -> 
			self#proc_T_always_statement stat
		| T_task(_,_,_) -> begin
			Printf.printf "fatal error : not supported T_task\n";
			exit 1
		end
		| T_function_avoid_amb(_,_,_,_) -> begin
			Printf.printf "fatal error : not supported T_function_avoid_amb\n";
			exit 1
		end
	end

	method init module2beElaborated tempdirname1 = begin
		match module2beElaborated with
		T_module_def(modName,portlist1,milist) -> begin
			name <- modName;
			portlist <- portlist1;
			tempdirname <- tempdirname1;
			(*processing mi list*)
			List.iter (self#proc_MI) milist
		end
		| _ -> begin
			Printf.printf "fatal error : only T_module_def\n";
			exit 1
		end
	end

	method name2idxlist name = begin
		let baseidx = begin
			let (x1,_)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in 
		self#rng_baseidx_2_idxlist rng baseidx	
	end

	method name2idxlist_nxt name = begin
		let baseidx = begin
			let (_,x1)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in 
		self#rng_baseidx_2_idxlist rng baseidx	
	end


	method proc_try_delay_length_prefix_forward d l p f instrlist outstrlist= begin
		Printf.printf "proc_try_delay_length_prefix_forward delay=%d length=%d prefix = %d forward = %d\n" d l p f;
			
		let bound = d+l+p
		and cnfname=          String.concat "" [tempdirname ; "dumpout/"           ; name ;"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f);".cnf"]
		and reslogname=       String.concat "" [tempdirname ; "dumpout/"        ; "satres";"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f)]
		and rev_cz_cnfname=   String.concat "" [tempdirname ; "dumpout/rev_cz_"    ; name ;"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f);".cnf"]
		and rev_cz_reslogname=String.concat "" [tempdirname ; "dumpout/rev_cz_" ; "satres";"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f)]
		and nl_const_cnfname=   String.concat "" [tempdirname ; "dumpout/nl_const_"    ; name ;"_d";string_of_int(d);"_l";string_of_int(l);"_p";string_of_int(p);"_f";string_of_int(f);".cnf"]
		in
		let satcmd=String.concat "" ["zchaff " ; cnfname ; " > " ; reslogname]
		in
		begin
			clause_list_multiple <- clause_list_multiple_saved;
			last_index <- last_index_saved;
			
			(*constraint these two copy *)
			(*equal of output list on b-1 and 2b-1 instance*)
			let connect_equ li=begin(*li is the b-l to b-1 instance*)
				let ov=List.concat (List.map self#name2idxlist outstrlist)
				in 
				let ov_b_1 = List.map (fun x -> x+ li*final_index_oneinst) ov
				and ov_2b_1 = List.map (fun x -> x+ (li+bound)*final_index_oneinst) ov
				in
				let ov_pair=List.combine ov_b_1 ov_2b_1
				in
				let oclslist=List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) ov_pair) 
				in
				clause_list_multiple <- oclslist@clause_list_multiple
			end
			in
			let rec try_equ li=begin
				if(li<(bound-l-f)) then ()
				else begin
					connect_equ li;
					try_equ (li-1)
				end
			end
			in
			try_equ (bound-1)
			;
			(*this for considering state set, it is a must for xfi and scrambler*)
			(*equal of state at b-1 and 2b-1*)
			(*
			let dff_idxpair=List.filter (fun x -> match x with (_,(_,-1))-> false | _ -> true) name_index_lst
			in
			let next_state_dff_lst=List.concat (List.map (fun x -> match x with (_,(t,tn)) -> (self#rng2list (T_range_int(t,tn-1))) ) dff_idxpair)
			in
			let next_state_dff_lst_b =List.map (fun x -> x+  (bound-1)*final_index_oneinst) next_state_dff_lst
			and next_state_dff_lst_bb=List.map (fun x -> x+(2*bound-1)*final_index_oneinst) next_state_dff_lst
			in
			let next_state_pair=List.combine next_state_dff_lst_b next_state_dff_lst_bb
			in 
			let equcls_lst=List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) next_state_pair)  
			in
			clause_list_multiple <- equcls_lst@clause_list_multiple
			;
			*)
			(*disequ of input on instance 0 and b*) (*also the initial state at p and p+b*)
			let connect_inequ li = begin (*li is from p to p+l-1*)
				let ov=List.concat (List.map self#name2idxlist instrlist)
				in 
				let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
				and ov_b = List.map (fun x -> x+ (li+bound)*final_index_oneinst) ov
				in
				(ov_0,ov_b)
			end
			in
			let rec try_inequ li = begin
				if(li<p) then ([],[])
				else begin
					let (va1,vb1)=connect_inequ li
					and (va2,vb2)=try_inequ (li-1)
					in
					((va1@va2),(vb1@vb2))
				end
			end
			in
			let (ov_0,ov_b)=try_inequ (p+l-1)
			in begin
				(*this for considering state set, it is a must for xfi and scrambler*)
				(*find the init state at p and p+b*)
				(*
				let dff_idxpair=List.filter (fun x -> match x with (_,(_,-1))-> false | _ -> true) name_index_lst
				in
				let current_state_dff_lst=List.concat (List.map (fun x -> match x with (_,(t,tn)) -> (self#rng2list (T_range_int(t,tn-1))) ) dff_idxpair)
				in
				let current_state_dff_lst_p =List.map (fun x -> x+        p*final_index_oneinst) current_state_dff_lst
				and current_state_dff_lst_pb=List.map (fun x -> x+(p+bound)*final_index_oneinst) current_state_dff_lst
				in
				clause_list_multiple <- (self#encode_INEV (current_state_dff_lst_p @ ov_0) (current_state_dff_lst_pb @ ov_b)) @ clause_list_multiple
				*)
				clause_list_multiple <- (self#encode_INEV (ov_0) (ov_b)) @ clause_list_multiple
			end
			;
			
			(*dump to sat*)
			begin
				print_endline "";
				print_endline  cnfname
				;
			
				let dumpout_cnf = open_out cnfname
				in
				self#print_cnf clause_list_multiple dumpout_cnf d l p f instrlist outstrlist
				;
				close_out dumpout_cnf
			end
			;
		
			(*call sat solver*)
			print_endline  satcmd;
			Sys.command satcmd;
		
			(*map the sat result*)
			let satres11 = self#parse_satres reslogname
			in begin
				if satres11==SATISFIABLE then begin
					(*List.iter (Printf.printf "%d\n" ) res_intlst;
					self#map_ass2var (2*bound) res_intlst ;*)
					(SATISFIABLE,d,l,p,f)
				end
				else begin
					clause_list_multiple <- clause_list_multiple_saved;
					last_index <- last_index_saved;
					
					(*dump to sat*)
					begin
						print_endline "";
						print_endline  rev_cz_cnfname
						;
			
						let rev_cz_cnf = open_out rev_cz_cnfname
						in
						self#print_cnf clause_list_multiple rev_cz_cnf d l p f instrlist outstrlist
						;
						close_out rev_cz_cnf
					end
					;
					let bd=bound
					in begin
						(*to dump out an instance from 0 to bd-1*)
						(*nl_const cnf construction*)
						let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 bd)
						in begin
							clause_list_multiple <- clause_list_multiple_aux;
							last_index <- last_index_aux;
							()
						end
						;
						clause_list_multiple <- (self#connect_multiple_instance_step3 0 (bd-1)) @ clause_list_multiple;

						let assertion_shengyushen="assertion_shengyushen"
						in
						let constrain_assertion li = begin (*li is from bound-1 to 0*)
							let ov=List.concat (List.map self#name2idxlist [assertion_shengyushen])
							in 
							let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
							in
							List.map (fun x -> ([x],"assertion_shengyushen") ) ov_0
						end
						in
						let rec try_assertion li = begin
							if(li<0) then []
							else begin
								let old_assclslst=constrain_assertion li
								and cur_assclslst=try_assertion (li-1)
								in
								old_assclslst@cur_assclslst
							end
						end
						in begin
							if List.length (List.filter (fun x -> match x with (nm,_) -> string_equ nm assertion_shengyushen ) name_index_lst) > 0 then
								clause_list_multiple <- (try_assertion (bd-1)) @ clause_list_multiple
							else 
								print_endline "warning : not found assertion_shengyushen"
						end
						;
						let nl_const_cnf = open_out nl_const_cnfname
						in
						self#print_cnf clause_list_multiple nl_const_cnf d l p f instrlist outstrlist
						;
						close_out nl_const_cnf
					end
					;
					clause_list_multiple <- clause_list_multiple_saved;
					last_index <- last_index_saved;
					let continue_scr = open_out "continue.scr"
					in
					begin
						(*let rev_zc_cmd=String.concat "" ["gawk -f vp_find_equal.awk " ; rev_cz_cnfname ; " > equal_quatient" ]
						in
						fprintf continue_scr "%s\n" rev_zc_cmd
						;
						let rev_zc_cmd=String.concat "" ["rev_zc " ; rev_cz_cnfname ; " > " ; rev_cz_reslogname]
						in
						fprintf continue_scr "%s\n"  rev_zc_cmd
						;
						let gate_ext_cmd=String.concat "" ["gate_ext " ; rev_cz_cnfname ; " |tee gate_ext.log"]
						in
						fprintf continue_scr "%s\n"  gate_ext_cmd
						;
						let dep_cmd=String.concat "" ["grep  ======== gate_ext.log > depedent"]
						in
						fprintf continue_scr "%s\n"  dep_cmd
						;*)
						
						(*replace above anchor based appraoches with directly generated dependent file, from output to input*)
						let dependent_fl = open_out "dependent"
						in
						let iv=List.concat (List.map self#name2idxlist instrlist)
						and ov=List.concat (List.map self#name2idxlist outstrlist)
						in
						let iv_shift=List.map (fun x -> x+final_index_oneinst*p) iv
							and ov_all=begin
							let rec ov_all_rec s e = begin
								if(s<e) then (List.map (fun x -> x+final_index_oneinst*s) ov) @ (ov_all_rec (s+1) e)
								else []
							end
							in
							ov_all_rec (p+d-f) (p+d+l)
						end
						in
						let print_inshift_elem i = begin
							fprintf dependent_fl "%d ======== " i;
							List.iter (fun x -> fprintf dependent_fl " %d " x) ov_all;
							fprintf dependent_fl "\n";
						end
						in
						List.iter print_inshift_elem iv_shift
						;
						close_out dependent_fl
						;
						let rm_cmd=String.concat "" ["#!/bin/sh"]
						in
						fprintf continue_scr "%s\n"  rm_cmd
						;
						let rm_cmd=String.concat "" ["rm -f resolve_trace"]
						in
						fprintf continue_scr "%s\n"  rm_cmd
						;
						let nl_const_cmd=String.concat "" ["nl_const_zchaff " ; nl_const_cnfname ; " 100 |tee nl_const.log"] (*use 100s as timeout value, to prevent us from stuck at a hopeless long run*)
						in
						fprintf continue_scr "%s\n"  nl_const_cmd
						;
						(*let diff_cmd=String.concat "" ["vp_diff_dependent_nllog.scr"]
						in
						fprintf continue_scr "%s\n"  diff_cmd 
						;
						let fail_cmd=String.concat "" ["grep XXXX nl_const.log |grep fail|vp_trimfail.scr |tee failones"]
						in
						fprintf continue_scr "%s\n"  fail_cmd 
						;*)
						close_out continue_scr
					end
					;
					(*Sys.command satcmd;*)
					
					(UNSATISFIABLE,d,l,p,f)
				end
			end
		end
	end
	
	method proc_try_delay_length_prefix d l p f instrlist outstrlist = begin(*track forward*)
		if f > p then (SATISFIABLE,0,0,0,0)
		else begin
			let (res,md,ml,mp,mf)=self#proc_try_delay_length_prefix_forward d l p f instrlist outstrlist 
			in begin
				if(res==SATISFIABLE) then 
					self#proc_try_delay_length_prefix d l p (f+1) instrlist outstrlist 
				else
					(res,md,ml,mp,mf)
			end
		end
	end

	method proc_try_len_delay bd len dd instrlist outstrlist = begin
		if ((len+dd) > bd) then (SATISFIABLE,0,0,0,0)
		else begin
			let prefix=bd-len-dd
			in begin
				let (res,md,ml,mp,mf)=self#proc_try_delay_length_prefix dd len prefix 0 instrlist outstrlist 
				in begin
					if (res==SATISFIABLE) then 
						self#proc_try_len_delay bd len (dd+1) instrlist outstrlist 
					else 
						(res,md,ml,mp,mf)
				end
			end
		end
	end

	method proc_try_len bd len instrlist outstrlist = begin
		if (len > bd) then (SATISFIABLE,0,0,0,0)
		else begin
			let (res,md,ml,mp,mf)=self#proc_try_len_delay bd len 0 instrlist outstrlist 
			in begin
				if (res==SATISFIABLE) then  (*that means exist multiple reverse solution, we need to search further*)
					(*proc_try_len bd (len+1)*) (*this is for multiple length*)
					(SATISFIABLE,0,0,0,0) (*this is for length 1 only*)
				else (*found solution*)
					(res,md,ml,mp,mf)
			end
		end
	end

	method check_p (p:int) (instrlist:string list) (outstrlist:string list) = begin
		clause_list_multiple <- [];
		last_index <- final_index_oneinst;
		
		(*generate multiple instance, which bound is defined*)
		let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 (p*2))
		in begin
			clause_list_multiple <- clause_list_multiple_aux;
			last_index <- last_index_aux;
			()
		end
		;
		
		(*to connect next state of one instance to current state of last instance*)
		clause_list_multiple <- (self#connect_multiple_instance_step3 0 (p-1)) @ clause_list_multiple;
		clause_list_multiple <- (self#connect_multiple_instance_step3 p (2*p-1)) @ clause_list_multiple;

		(*constrain the assertion wire*)
		let assertion_shengyushen="assertion_shengyushen"
		in
		let constrain_assertion li = begin (*li is from bound-1 to 0*)
			let ov=List.concat (List.map self#name2idxlist [assertion_shengyushen])
			in 
			let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
			in
			List.map (fun x -> ([x],"assertion_shengyushen") ) ov_0
		end
		in
		let rec try_assertion li = begin
			if(li<0) then []
			else begin
				let old_assclslst=constrain_assertion li
				and cur_assclslst=try_assertion (li-1)
				in
				old_assclslst@cur_assclslst
			end
		end
		in begin
			if List.length (List.filter (fun x -> match x with (nm,_) -> string_equ nm assertion_shengyushen ) name_index_lst) > 0 then
				clause_list_multiple <- (try_assertion (2*p-1)) @ clause_list_multiple
			else 
				print_endline "warning : not found assertion_shengyushen"
		end
		;

		(*constraint these two copy *)
		(*equal of input list on p-1 and 2p-1 instance*)
		let connect_equ li=begin(*li is the p-l to 0 instance*)
			let iv=List.concat (List.map self#name2idxlist instrlist)
			in 
			let iv_p_1 = List.map (fun x -> x+ li*final_index_oneinst) iv
			and iv_2p_1 = List.map (fun x -> x+ (li+p)*final_index_oneinst) iv
			in
			let iv_pair=List.combine iv_p_1 iv_2p_1
			in
			let iclslist=List.concat (List.map (fun x -> match x with (b1,b2) -> (self#encode_EQU b1 b2)) iv_pair) 
			in
			clause_list_multiple <- iclslist@clause_list_multiple
		end
		in
		let rec try_equ li=begin
			if(li<0) then ()
			else begin
				connect_equ li;
				try_equ (li-1)
			end
		end
		in
		try_equ (p-1)
		;

		(*this for considering state set, it is a must for xfi and scrambler*)
		(*equal of state at b-1 and 2b-1*)

		let dff_idxpair=List.filter (fun x -> match x with (_,(_,-1))-> false | _ -> true) name_index_lst
		in
		let next_state_dff_lst=List.concat (List.map (fun x -> match x with (nmdff,_) -> self#name2idxlist_nxt nmdff ) dff_idxpair)
		in
		let next_state_dff_lst_b =List.map (fun x -> x+  (p-1)*final_index_oneinst) next_state_dff_lst
		and next_state_dff_lst_bb=List.map (fun x -> x+(2*p-1)*final_index_oneinst) next_state_dff_lst
		in
		clause_list_multiple <- (self#encode_INEV (next_state_dff_lst_b) (next_state_dff_lst_bb)) @ clause_list_multiple
		;
		
		(*dump to sat*)
		let cnfname=          String.concat "" [tempdirname ; "dumpout/prep_"           ; name ;"_p";string_of_int(p);".cnf"]
		and reslogname=       String.concat "" [tempdirname ; "dumpout/prep_"           ; "satres_p";string_of_int(p)]
		in
		let satcmd=String.concat "" ["zchaff " ; cnfname ; " > " ; reslogname]
		in
		begin
			print_endline "";
			print_endline  cnfname
			;
		
			let dumpout_cnf = open_out cnfname
			in
			self#print_cnf clause_list_multiple dumpout_cnf 0 0 p 0 instrlist outstrlist
			;
			close_out dumpout_cnf
			;
			(*call sat solver*)
			print_endline  satcmd;
			Sys.command satcmd;
		
			(*map the sat result*)
			let satres11 = self#parse_satres reslogname
			in begin
				if satres11==SATISFIABLE then false
				else true
			end
		end
		
	end

	method find_p (bound_dl:int) (p:int) (instrlist:string list) (outstrlist:string list)= begin
		if (p>bound_dl) then begin
			Printf.printf "fail to find proper p\n" ;
			exit 1;
		end
		else begin
			let result_p=self#check_p p instrlist outstrlist
			in begin
				if (result_p==true) then p
				else self#find_p bound_dl (p+1) instrlist outstrlist
			end
		end
	end


	method proc_try_bound (bd:int) (bound_dl:int) (instrlist:string list) (outstrlist:string list)= begin
		if (bd > bound_dl) then (SATISFIABLE,0,0,0,0)
		else begin
			(*clear the previously created clause list*)
			clause_list_multiple <- [];
			last_index <- final_index_oneinst;
		
			(*generate multiple instance, which bound is defined*)
			let (clause_list_multiple_aux,last_index_aux) = (self#gen_multiple_instance_step2 (bd*2))
			in begin
				clause_list_multiple <- clause_list_multiple_aux;
				last_index <- last_index_aux;
				()
			end
			;
			(*actually we need to encode two copy of multiple instance*)

			(*to connect next state of one instance to current state of last instance*)
			clause_list_multiple <- (self#connect_multiple_instance_step3 0 (bd-1)) @ clause_list_multiple;
			clause_list_multiple <- (self#connect_multiple_instance_step3 bd (2*bd-1)) @ clause_list_multiple;
			
			(*constrain the assertion wire*)
			let assertion_shengyushen="assertion_shengyushen"
			in
			let constrain_assertion li = begin (*li is from bound-1 to 0*)
				let ov=List.concat (List.map self#name2idxlist [assertion_shengyushen])
				in 
				let ov_0 = List.map (fun x -> x+ li*final_index_oneinst) ov
				in
				List.map (fun x -> ([x],"assertion_shengyushen") ) ov_0
			end
			in
			let rec try_assertion li = begin
				if(li<0) then []
				else begin
					let old_assclslst=constrain_assertion li
					and cur_assclslst=try_assertion (li-1)
					in
					old_assclslst@cur_assclslst
				end
			end
			in begin
				if List.length (List.filter (fun x -> match x with (nm,_) -> string_equ nm assertion_shengyushen ) name_index_lst) > 0 then
					clause_list_multiple <- (try_assertion (2*bd-1)) @ clause_list_multiple
				else 
					print_endline "warning : not found assertion_shengyushen"
			end
			;
		
			(*save these setting across multiple run with same bound*)
			clause_list_multiple_saved <- clause_list_multiple;
			last_index_saved <- last_index;

			let (res,md,ml,mp,mf)=self#proc_try_len bd 1  instrlist outstrlist 
			in begin
				if (res==SATISFIABLE) then  (*that means exist multiple reverse solution, we need to search further*)
					self#proc_try_bound (bd+1) bound_dl instrlist outstrlist
				else (*found solution*)
					(res,md,ml,mp,mf)
			end
			
		end
	end



	method compsyn (bound_dl:int) (instrlist:string list) (outstrlist:string list) = begin
		let cnfname_1inst=String.concat "" [tempdirname ; "dumpout/inst1_" ; name ;".cnf"]
		and cnfname_dualsyn=String.concat "" [tempdirname ; "dumpout/dualsyn_" ; name ;".cnf"]
		in 
		begin
			Printf.printf "start to do \n" ;
			clause_list <- (self#encode_oneInstance2SAT_step1) @ clause_list; (*encode one instance*)

			final_index_oneinst <- last_index;(*record the final largest index*)


			(*
				dump to sat *_1inst.cnf, for verification purpose,
				I will write another program to map the *_1inst.cnf back to verilog,
				such that it can be verified by formality
			*)
			Printf.printf "start to do 1 \n" ;
			begin
				print_endline "";
				print_endline  cnfname_1inst
				;
			
				let dumpout_cnf = open_out cnfname_1inst
				in
				self#print_cnf clause_list dumpout_cnf 0 1 0 0 instrlist outstrlist
				;
				close_out dumpout_cnf
			end
			;
			Printf.printf "start to do 2 \n" ;
			
			(*let p_pre=self#find_p bound_dl 1 instrlist outstrlist
			in begin
				Printf.printf "p_pre %d\n" p_pre;
				exit 1;*)
				self#proc_try_bound 1 bound_dl instrlist outstrlist 
			(*end*)
		end
	end

	method proc_name_index inst res_intlst ni = begin
		match ni with
		(nm,(cur,next)) -> begin
			let offset=inst*final_index_oneinst
			in begin
				let (left,right)=self#rng2lr (self#name2range nm)
				in 
				let strlr=begin
					if left== -1 && right== -1 then nm
					else sprintf "%s [%d:%d]" nm left right
				end
				in begin
					let vstart=cur+offset
					and vend=cur+offset+abs(right-left)
					in
					let idxlst=self#rng2list (T_range_int(vstart,vend))
					in
					let vmap=List.map (self#find_inass res_intlst) idxlst
					in
					let vvector=List.map (fun x -> if x > 0 then 1 else 0) vmap
					in begin
						Printf.printf "   %s = %d'b" strlr (List.length vvector);
						List.iter (Printf.printf "%d") vvector;
						Printf.printf "\n"
					end
				end
			end
		end
	end

	method find_inass res_intlst idx = begin
		List.find (fun x -> (abs(x))==idx) res_intlst
	end

	method map_ass2var bound res_intlst = begin
		let rec proc_inst inst = begin
			if inst == bound then ()
			else begin
				Printf.printf "============inst %d============\n" inst;
				List.iter (self#proc_name_index inst res_intlst) name_index_lst ;
				proc_inst (inst+1)
			end
		end
		in
		proc_inst 0
	end

	method parse_satres reslogname = begin
		(*try to find "Instance Satisfiable"*)
		let reslog_in = open_in reslogname
		in begin
		   try 
			let rec find_inssat ri= begin
				let str=input_line ri
				in begin
					if string_equ str "Instance Satisfiable" then (*we finnally find that start of SAT assignment*)
						(*find sat assignment*)
						(*we dont need any more*)
						let rec create_assignmentlist ri= begin
							let str=input_line ri
							in begin
								(*print_endline str;*)
								if (string_equ str "end") then []
								else begin
									(Scanf.sscanf str "%d" (fun x->x))::(create_assignmentlist ri)
								end
							end
						end
						in 
						let reslst=create_assignmentlist reslog_in
						in begin
							close_in reslog_in (*;
							
							List.iter (fun x -> if(x>0) then Printf.printf "%s %d 1\n" (self#idx2name x ) x else Printf.printf "%s %d 0\n" (self#idx2name (-x) ) (-x) )  reslst*)
						end
						
						;
						SATISFIABLE
					else if string_equ str "Instance Unsatisfiable" then
						UNSATISFIABLE
					else find_inssat ri
						
				end
			end
			in find_inssat reslog_in
		   with End_of_file -> begin
		   	Printf.printf "fatal error : improper end of zchaff log file \n";
			exit 1
		   end
		   | Failure "int_of_string" -> begin
		   	Printf.printf "fatal error : improper assignment \n";
			exit 1
		   end
		end
	end

	(*to connect next state of one instance to current state of last instance*)
	method connect_multiple_instance_step3 start_bound end_bound = begin
		let dff_idxpair=List.filter (fun x -> match x with (_,(_,-1))-> false | _ -> true) name_index_lst
		in 
		let rec connect_inst i = begin
			if i == end_bound then []
			else begin
				let connect_dffpair dffpair = begin
					match dffpair with
					(nm,(current_idx,next_index)) -> begin
						(*make sure it is actually dff*)
						if self#isdff nm then begin
							let current_off=(i+1)*final_index_oneinst
							and next_off = i*final_index_oneinst
							in
							let new_current_idx=current_off+current_idx
							and new_next_index=next_off+next_index
							in 
							let (rli,rlr)=self#rng2lr (self#name2range nm)
							in
							let (rli_real_cur,rlr_real_cur)=self#rng2lr (self#construct_range_onidx new_current_idx rli rlr)
							and (rli_real_nxt,rlr_real_nxt)=self#rng2lr (self#construct_range_onidx new_next_index rli rlr)
							in begin
								if (rli_real_cur==new_current_idx) && (new_current_idx-new_next_index==final_index_oneinst-(abs(rlr-rli)+1)) && (rli_real_cur-final_index_oneinst+abs(rlr-rli)+1==rli_real_nxt) then begin
									(*encode every bit in this range*)
									let rec connect_1bitdff idxi idxr = begin
										if idxi>idxr then []
										else begin
											let oldcl = connect_1bitdff (idxi+1) idxr
											and newmapped = (self#encode_EQU idxi (idxi-final_index_oneinst+abs(rlr-rli)+1))
											in
											let newmapped_commented= List.map (self#setcomment (sprintf "connecting dff %s from instance %d to %d" nm i (i+1))) newmapped 
											in
											newmapped_commented @ oldcl
										end
									end
									in
									connect_1bitdff rli_real_cur rlr_real_cur
								end
								else begin
									Printf.printf "fatal error : improper connect_dffpair\n";
									Printf.printf "rli_real_cur %d\n" rli_real_cur;
									Printf.printf "rlr_real_cur %d\n" rlr_real_cur;
									Printf.printf "new_current_idx %d\n" new_current_idx;
									Printf.printf "new_next_index %d\n" new_next_index;
									Printf.printf "rlr %d\n" rlr;
									Printf.printf "rli %d\n" rli;
									Printf.printf "final_index_oneinst %d\n" final_index_oneinst;
									Printf.printf "rli_real_nxt %d\n" rli_real_nxt;
									Printf.printf "rlr_real_nxt %d\n" rlr_real_nxt;
									exit 1
								end
							end
						end
						else begin
							Printf.printf "fatal error : it should be dff\n";
							exit 1
						end
					end
				end
				in 
				(List.concat (List.map connect_dffpair dff_idxpair)) @ connect_inst (i+1)
			end
		end
		in
		connect_inst start_bound
	end

	method setcomment str cls = begin
		match cls with
		(intlst,_) -> (intlst,str)
	end
	
	method appendcomment str cls = begin
		match cls with
		(intlst,strold) -> (intlst,(self#cat_string strold str))
	end
	
	method cat_string str1 str2 = begin
		String.concat ":::" [str1;str2]
	end
	
	(*generate multiple instance, which bound is defined*)
	method gen_multiple_instance_step2 bound = begin
		let rec gen_instance inst = begin
		   if inst == bound then []
		   else begin
			let oclslst=gen_instance (inst+1)
			in
			let encode_instance ii= begin
				let off=ii*final_index_oneinst
				in 
				let cls_off offf cls = begin
					let lit_off offff lit= begin
						if lit > 0 then lit+offff
						else lit -offff
					end
					in
					self#appendcomment (self#cat_string "instance " (string_of_int ii)) ((List.map (lit_off offf) (fst cls)),(snd cls)) 
				end
				in
				List.map (cls_off off) clause_list
			end
			in
			(encode_instance inst)@oclslst
		   end
		end
		in 
		let clslst=gen_instance 0
		in 
		(clslst,(final_index_oneinst*bound))
	end

	method encode_oneInstance2SAT_step1  = begin
		(*index for explictly named vars, such as input output wire reg dff*)
		self#encode2SAT_explictname;
		(*this is the true encode*)

		Printf.printf "start to do 1 encode2SAT_explictname \n" ;


		(*encode the seq_always_list*)
		let seq_clslst=self#encode2SAT_seq_always_list truepred
		and comb_clslst=self#encode2SAT_comb_always_list truepred
		and cont_clslst=self#encode2SAT_contass_list
		in
		seq_clslst@comb_clslst@cont_clslst
	end
	
	method encode2SAT_contass_list = begin
		Printf.printf "start to do 1 encode2SAT_contass_list \n" ;
		List.concat (List.map (self#encode_ass) cont_ass_list)
	end
	
	method encode_ass ass = begin
		match ass with
		T_assignment(lv,exp) -> begin
			let truepred=1
			in 
			self#encode_nba_incomb (T_non_blocking_assignment_direct(lv,exp)) truepred
		end
	end
	
	method encode2SAT_comb_always_list envpred = begin
		Printf.printf "start to do 1 encode2SAT_comb_always_list \n" ;
		let encode_comb_always comb_always = begin
			match comb_always with
			(stat,_) -> self#encode_statement_incomb envpred stat   
		end
		in
		List.concat (List.map encode_comb_always comb_always_list)
	end
	
	method encode_statement_incomb envpred stat = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_incomb dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_incomb nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predclslst)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex ,(self#encode_Red_AND oldindex [envpred;expidx] ))
				end
				in
				newpred_clslst @ (self#encode_statement_incomb newpred stat_sub  ) @ predclslst
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predclslst)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in 
				let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
				and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
				in 
				predclslst @ thenpredclslist @ elsepredclslist @ (self#encode_statement_incomb thenpred stat1) @ (self#encode_statement_incomb elsepred stat2 )
			end
		end
		| T_case_statement(exp,cilst) -> begin
			let rec case2ifelse cl = begin
				match cl with
				[] -> begin
					Printf.printf "fatal error : you should not reach [] in case statement\n";
					exit 1
				end
				| [T_case_item_normal(explst,st1);T_case_item_default(stlast)] -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,stlast)
				end
				| (T_case_item_normal(explst,st1))::tl -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,(case2ifelse tl))
				end
				| _ -> begin
					Printf.printf "fatal error : you should not reach here in case statement\n";
					exit 1
				end
			end
			in
			self#encode_statement_incomb envpred (case2ifelse cilst)
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_incomb envpred) statlst  )
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	
	method encode2SAT_seq_always_list envpred= begin
		Printf.printf "start to do 1 encode2SAT_seq_always_list \n" ;
		let encode_seq_always seq_always = begin
			match seq_always with
			(stat,_) -> self#encode_statement_inseq envpred stat   
		end
		in
		List.concat (List.map encode_seq_always seq_always_list)
	end
	
	method encode_nba_incomb nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_incomb only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_incomb lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method encode_statement_inseq envpred stat  = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_inseq nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predcl)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex,(self#encode_Red_AND oldindex [envpred;expidx]))
				end
				in 
				predcl @ newpred_clslst @ (self#encode_statement_inseq newpred stat_sub)
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predcl)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in begin
					let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
					and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
					in 
					predcl @ (thenpredclslist @ elsepredclslist) @ (self#encode_statement_inseq thenpred stat1) @ (self#encode_statement_inseq elsepred stat2 )
				end
			end
		end
		| T_case_statement(exp,cilst) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_case_statement\n";
			exit 1
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_inseq envpred) statlst)
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	(*return positive , negative index and clause list*)
	method encode_pred exp = begin
		let (idxlst,cl)= self#encode_exp exp
		in 
		let idx=begin
			match idxlst with
			[pred] -> pred
			| _ -> begin
				Printf.printf "fatal error : invalid length of encode_pred\n";
				exit 1
			end
		end
		in 
		(*negative relationship*)
		let oldindex = self#alloc_index 1
		in
		(idx,oldindex,(self#encode_NEG idx oldindex)@cl)
	end
	(*return the list of exp bit and list of clause*)
	method encode_prim prim = begin
		match prim with
		T_primary_num(num) -> self#encode_number num 
		| T_primary_id([name]) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1  (*even for a dff, prim will always use current state*)
			end
			and rng=self#name2range name
			in 
			((self#rng_baseidx_2_idxlist rng baseidx),[])
		end
		| T_primary_id([]) -> begin
			Printf.printf "fatal error : not supported T_primary_id with zero string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_id(idlst) -> begin
			Printf.printf "fatal error : not supported T_primary_id with multiple string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if self#is_inrange rng off then begin
					let (left,right)=self#rng2lr rng
					in 
					([self#offset2idx left right baseidx off],[])
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_primary_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=self#lr2list li ri
			and (left,right)=self#rng2lr rng
			in begin
				if (self#is_inrange rng li ) && (self#is_inrange rng ri )  then begin
					((List.map (fun x -> self#offset2idx left right baseidx x) idxlst),[])
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| T_primary_minmaxexp(T_mintypmax_expression_1(exp)) -> self#encode_exp exp
		| T_primary_concat(explst) -> begin
			let (resv,rescls) = List.split (List.map (self#encode_exp) explst)
			in
			((List.concat resv),(List.concat rescls))
		end
		| _ -> begin
			Printf.printf "fatal error : not supported encode_prim\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
	end
	(*return the list of exp bit and list of clause*)
	method encode_number num = begin
		match num with
		T_number_unsign(i) -> begin
			let strlst=(List.rev (Misc2.int2bin i))
			in begin
				let rec proc_intlst slst = begin
					match slst with
					[] -> []
					| hd::tl -> begin
						match hd with
						"0" -> falsepred::(proc_intlst tl)
						| "1" -> truepred::(proc_intlst tl)
						| _ -> begin
							Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
							exit 1
						end
					end
				end 
				in
				((proc_intlst strlst),[])
			end
		end
		| T_number_base(len,base,str) -> begin
			if base=='b' || base=='B' then begin
				if String.length str == len then begin
					let numlst = Misc.string2charlist str 
					in begin
						let rec proc_numlst nl = begin
							match nl with
							[] -> []
							| hd::tl -> begin
								match hd with
								'0' -> 	falsepred::(proc_numlst tl)
								| '1' -> truepred::(proc_numlst tl)
								| _ -> begin
									Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
									exit 1
								end
							end
						end
						in
						((proc_numlst numlst),[])
					end
				end
				else begin
					Printf.printf "fatal error : encode_prim length is not matched\n";
					exit 1
				end
			end
			else begin
				Printf.printf "fatal error : not supported base other than b or B in encode_prim\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : T_number_float is not supported\n";
			exit 1
		end
	end
	
	(*return the list of exp bit and list of clause*)
	method encode_exp exp = begin
		match exp with
		T_primary(prim) -> self#encode_prim prim
		| T_primary_4arrayassign(_) -> begin
			Printf.printf "fatal error : not supported T_primary_4arrayassign\n";
			exit 1
		end
		| T_add1(prim) -> self#encode_prim prim
		| T_sub1(prim) -> begin
			Printf.printf "fatal error : not supported T_sub1\n";
			exit 1
		end
		| T_logicneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in begin
				match bitlst with
				[idx] -> begin
					let oldindex = self#alloc_index 1
					in 
					([oldindex],(self#encode_NEG_ASSIGN oldindex idx )@clst)
				end
				| _ -> begin
					Printf.printf "fatal error : invalid length in T_logicneg\n";
					exit 1
				end
			end
		end
		| T_bitneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in
			let rec proc_bitlst bl = begin
				match bl with
				[] -> ([],[])
				| hd::tl -> begin
					let oldindex = self#alloc_index 1
					and (oldblst,oldclst)=(proc_bitlst tl)
					in 
					((oldindex::oldblst),(self#encode_NEG_ASSIGN oldindex hd)@oldclst)
				end
			end
			in
			let (bl,cl)=proc_bitlst bitlst
			in
			(bl,cl@clst)
		end
		| T_reduce_and(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_AND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nand(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NAND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_or(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_OR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nor(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NOR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_xor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xor\n";
			exit 1
		end
		| T_reduce_xnor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xnor\n";
			exit 1
		end
		| T_add2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let (addblst,addclst)=(self#encode_ADD vec1 vec2)
					in
					(addblst,(clslst1 @ clslst2 @ addclst))
				end
				else begin
					Printf.printf "fatal error : T_add2 length should be of the same\n";
					exit 1
				end
			end
		end
		| T_sub2(_,_) -> begin
			Printf.printf "fatal error : not supported T_sub2\n";
			exit 1
		end
		| T_mul2(_,_) -> begin
			Printf.printf "fatal error : not supported T_mul2\n";
			exit 1
		end
		| T_div(_,_) -> begin
			Printf.printf "fatal error : not supported T_div\n";
			exit 1
		end
		| T_mod(_,_) -> begin
			Printf.printf "fatal error : not supported T_mod\n";
			exit 1
		end
		| T_logic_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_equ_formular (List.tl plist))
							in
							((oldindex::bl), (self#encode_EQU_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_equ_formular pl
						and oldindex = self#alloc_index 1
						in 
						([oldindex], clslst1 @ clslst2 @ resclslst @ (self#encode_Red_AND oldindex reslst ) );
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_logic_ine(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_ine_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_ine_formular (List.tl plist))
							in
							((oldindex::bl),(self#encode_INE_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_ine_formular pl
						in
						let oldindex = self#alloc_index 1
						in 
						([oldindex] , clslst1 @ clslst2 @ resclslst @ (self#encode_Red_OR oldindex reslst ))
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_case_equ(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_equ\n";
			exit 1
		end
		| T_case_ine(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_ine\n";
			exit 1
		end
		| T_logic_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_AND oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_logic_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_OR oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_lt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_lt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_lt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_lt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_lt case001 %d" oldindex))
									and case01=([b1;-b2;oldindex],(sprintf "T_lt case01 %d" oldindex))
									and case10=([-b1;b2;-oldindex],(sprintf "T_lt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_lt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_lt case111 %d" oldindex))
									in 
									( oldindex , [case000;case001;case01;case10;case110;case111] @ oldclslst)
								end
							end
						end
					end
					in 
					let (b,cl)=proc_lt_formular pl
					in
					([b],cl@clslst1@clslst2)
				end
				else begin
					Printf.printf "fatal error : T_lt length must be equ\n";
					exit 1
				end
			end
		end
		| T_le(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_lt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_gt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_gt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_gt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_gt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_gt case001 %d" oldindex))
									and case01=([b1;-b2;-oldindex],(sprintf "T_gt case01 %d" oldindex))
									and case10=([-b1;b2;oldindex],(sprintf "T_gt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_gt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_gt case111 %d" oldindex))
									in 
									(oldindex, [case000;case001;case01;case10;case110;case111]@oldclslst )
								end
							end
						end
					end
					in 
					let (b,cl)=proc_gt_formular pl
					in
					([b],cl @ clslst1 @ clslst2 )
				end
				else begin
					Printf.printf "fatal error : T_gt length must be equ\n";
					exit 1
				end
			end
		end
		| T_ge(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_gt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_bit_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_and2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_and2 tl
							in 
							let andres=self#encode_AND2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_and2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_and2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_or2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_or2 tl
							in 
							let andres=self#encode_OR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_or2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_or2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_xor2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_xor2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_xor2 tl
							in 
							let andres=self#encode_XOR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_xor2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_xor2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_equ2 tl
							in 
							let andres=self#encode_EQU_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_equ2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_equ length must be equ\n";
					exit 1
				end
			end
		end
		| T_leftshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_leftshift\n";
			exit 1
		end
		| T_rightshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_rightshift\n";
			exit 1
		end
		| T_selection(predexp,exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			and (predv,clslstpred)=self#encode_exp predexp
			in begin
				if ((List.length vec1) == (List.length vec2) && (List.length predv)==1) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_sel pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_sel tl
							in 
							let equres=self#encode_SEL_res oldindex b1 b2 (List.hd predv) 
							in 
							((oldindex::lastres),(equres @ cl))
						end
					end
					in 
					let (bl,cl)=proc_sel pl
					in
					(bl,cl @ clslst1 @ clslst2 @ clslstpred)
				end
				else begin
					Printf.printf "fatal error : T_selection length must be equ and predv must be 1\n";
					exit 1
				end
			end
		end
		| T_string(_) -> begin
			Printf.printf "fatal error : not supported T_string\n";
			exit 1
		end
		| T_expression_NOSPEC(_) -> begin
			Printf.printf "fatal error : not supported T_expression_NOSPEC\n";
			exit 1
		end
	end
	
	method encode_ADD vec1 vec2 = begin
		let oldindex = self#alloc_index (List.length vec1)
		and carryidx = self#alloc_index (List.length vec1)
		in begin
			(*from oldindex to oldindex+(List.length vec1)-1 are the result of add operation*)
			(*from oldindex+(List.length vec1) to oldindex+(List.length vec1)*2-1 are the carry of add operation*)
			(*proc_add will generate one more bit,which means the carry*)
			let rec proc_add v1 v2 residx cryidx= begin
				match v1 with
				[] -> begin
					if (List.length v2 == 0) && (residx == oldindex+(List.length vec1)) && (cryidx==oldindex+(List.length vec1)*2) then 
						([falsepred],[]) (*to enforce 0 cryidx*)
					else begin
						Printf.printf "fatal error : improper T_add2\n";
						Printf.printf "v2 len %d\n" (List.length v2);
						Printf.printf "v1 len %d\n" (List.length v1);
						Printf.printf "vec2 len %d\n" (List.length vec2);
						Printf.printf "vec1 len %d\n" (List.length vec1);
						Printf.printf "residx %d\n" residx;
						Printf.printf "cryidx %d\n" cryidx;
						Printf.printf "oldindex %d\n" oldindex;
						Printf.printf "carryidx %d\n" carryidx;
						exit 1
					end
				end
				| hd1::tl1 -> begin
					let hd2=List.hd v2
					and tl2=List.tl v2
					in begin
						let (reslst,resclslst) = proc_add tl1 tl2 (residx+1) (cryidx+1)
						in begin
							 let carry=List.hd reslst
							 in begin 
							 	(*we would like 
							 		hd2+hd1+carry==(cryidx,residx)
							 	*)
							 	(cryidx::(residx::(List.tl reslst)),resclslst@(self#encode_ADD_1bit hd1 hd2 carry cryidx residx))
							 	
							 end
						end
					end
				end
			end
			in
			let (bl,cl)=(proc_add vec1 vec2 oldindex carryidx) (*we dont want the hgihest carry*)
			in
			((List.tl bl),cl)
		end
	end
	
	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin
		let cry000 = ([hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry001 = ([hd1;		hd2;		-1*carry;	-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry010 = ([hd1;		-1*hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry011 = ([hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry100 = ([-1*hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry101 = ([-1*hd1;		hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry110 = ([-1*hd1;		-1*hd2;		carry;		cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry111 = ([-1*hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and res000 = ([hd1;		hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res001 = ([hd1;		hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res010 = ([hd1;		-1*hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res011 = ([hd1;		-1*hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res100 = ([-1*hd1;		hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res101 = ([-1*hd1;		hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res110 = ([-1*hd1;		-1*hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res111 = ([-1*hd1;		-1*hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		in
		[cry000;cry001;cry010;cry011;cry100;cry101;cry110;cry111;res000;res001;res010;res011;res100;res101;res110;res111]
	end
	
	method encode_nba_inseq nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_inseq only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_inseq lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method addGuard clslist pred = begin
		let proc_cls cls = self#appendcomment (sprintf "guarded by %d" pred) (((-1*pred)::(fst cls)),(snd cls)) 
		in
		List.map proc_cls clslist
	end
	
	
	(*the first is the destination*)
	method encode_ASSIGN idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_ASSIGN %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_EQU %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_EQU %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU_res r b1 b2 = begin
		(*Printf.printf  "encode_EQU_res %d %d %d\n" b1 b2 r;*)
		let initlst=[([b1;b2;r],"");([-b1;-b2;r],"");([b1;-b2;-r],"");([-b1;b2;-r],"")]
		in
		List.map (self#setcomment (sprintf "encode_EQU_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_INEV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len=(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx=self#alloc_index len
			in 
			let rec enc pl1 idx= begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)=enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)=enc pl residx
			and redoridx=self#alloc_index 1
			in
			([redoridx],"redoridx")::((self#encode_Red_OR redoridx idxlst )@clslst)
		end
		else begin
			Printf.printf "fatal error : encode_INEV_res disequ\n" ;
			exit 1
		end
	end
	
	method encode_INE_res r b1 b2  = begin
		(*Printf.printf  "encode_INE_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;b2;-r],"");([-b1;-b2;-r],"");([b1;-b2;r],"");([-b1;b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_INE_res %s %s %s" (self#idx2name  r) (self#idx2name b1) (self#idx2name b2) ))  initlst
	end
	
	method encode_AND2_res r b1 b2  = begin
		(*Printf.printf  "encode_AND2_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;-r],"");([b2;-r],"");([-b1;-b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_AND2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_OR2_res r b1 b2 = begin
		(*Printf.printf  "encode_OR2_res %d %d %d\n"  r b1 b2;*)
		let initlst=[([-b1;r],"");([-b2;r],"");([b1;b2;-r],"")]
		in
		List.map (self#setcomment (sprintf "encode_OR2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_SEL_res r b1 b2 pred = begin
		(*Printf.printf  "encode_SEL_res %d %d %d %d\n" r b1 b2 pred;*)
		let initlst=[([-pred;b1;-r],"");([-pred;-b1;r],"");([pred;b2;-r],"");([pred;-b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_SEL_res %s %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) (self#idx2name pred) )) initlst
	end
	
	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 
	
	method encode_NEG idx1 idx2 = begin
		(*Printf.printf  "encode_NEG %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx1;idx2],"");([-1*idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_NEG %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	(*first is the target*)
	method encode_NEG_ASSIGN idx1 idx2 = begin
		(*Printf.printf  "encode_NEG_ASSIGN %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx2;idx1],"");([-1*idx2;-1*idx1],"")]
		in
		List.map (self#setcomment (sprintf "encode_NEG_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_Red_AND li bitlst  = begin
		(*Printf.printf  "encode_Red_AND %d\n"   li;*)
		(*first the -1 -2 -3 ... li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[li]),(sprintf "encode_Red_AND %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then i -li*)
		let proc_b b = ([b;(-1*li)],(sprintf "encode_Red_AND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)) )
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NAND li bitlst  = begin
		(*Printf.printf  "encode_Red_NAND %d\n"   li;*)
		(*first the -1 -2 -3 ... -li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[(-1*li)]),(sprintf "encode_Red_NAND %d to %s" (List.length bitlst) (self#idx2name li) ))
		in
		(*then i li*)
		let proc_b b = ([b;(li)],(sprintf "encode_Red_NAND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_OR li bitlst  = begin
		(*Printf.printf  "encode_Red_OR %d\n"   li;*)
		(*first the 1 2 3 ... -li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(-1*li)]),(sprintf "encode_Red_OR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i li*)
		let proc_b b = ([(-1*b);li],(sprintf "encode_Red_OR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NOR li bitlst  = begin
		(*Printf.printf  "encode_Red_NOR %d\n"   li;*)
		(*first the 1 2 3 ... li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(li)]),(sprintf "encode_Red_NOR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i -li*)
		let proc_b b = ([(-1*b);(-1*li)],(sprintf "encode_Red_NOR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode2SAT_explictname = begin
		let encode_explictname key cont = begin
		  Printf.printf "doing %s\n" key ;
		  let duplst= List.filter (fun x -> match x with (nm,_)-> string_equ nm key) name_index_lst
		  in begin
		    if (List.length duplst) == 0 then begin
			let rng= self#name2range key
			and dff = self#isdff key
			in begin
				(*the index is for left side of range*)
				if dff then begin(*dff will has two index, one for current state, the other for next state*)
					name_index_lst <- (key,(last_index,last_index+(get_rng_width rng)))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)*2
				end
				else begin
					name_index_lst <- (key,(last_index,-1))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)
				end
			end
		    end
		    else begin
			Printf.printf "warning : %s is defined multiple times %d\n" key (List.length duplst) (*;
			List.iter (fun x -> match x with (nn,_)-> printf "duplst %s\n" nn) duplst;
			exit 1*)
		    end
		  end
		end
		in
		Hashtbl.iter encode_explictname circuit_hst
	end
	
	
	(*
		some misc functions
	*)
	method map_lv2index lv = begin (*return the list of index from left to right*)
		(*
			note that, for dff, lv must be a next state, so use the second index
					for non-dff one, just use the first one
		*)
		match lv with  
		T_lvalue_id([name]) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			in 
			self#rng_baseidx_2_idxlist rng baseidx
		end
		| T_lvalue_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if self#is_inrange rng off then begin
					let (left,right)=self#rng2lr rng
					in 
					[self#offset2idx left right baseidx off]
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_lvalue_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=self#lr2list li ri
			and (left,right)=self#rng2lr rng
			in begin
				if (self#is_inrange rng li ) && (self#is_inrange rng ri )  then begin
					List.map (fun x -> self#offset2idx left right baseidx x) idxlst
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| _ -> begin
			Printf.printf "fatal error : not supported lv\n";
			exit 1
		end
	end
	
	method lr2list li ri = begin
		if li> ri then li::(self#lr2list (li-1) ri)
		else if li< ri then li::(self#lr2list (li+1) ri)
		else [ri]
	end
	
	method is_inrange rng off = begin
		let (left,right)=self#rng2lr rng
		in
		if ((left >= off && off >= right)||(left <= off && off <= right)) then true
		else false
	end
	
	method offset2idx left right baseidx offset = baseidx + abs(offset - left)
	
	method rng_baseidx_2_idxlist rng baseidx = begin
		let (l,r) = self#rng2lr rng
		in 
		let lst=self#rng2list (T_range_int((min l r),(max l r)))
		in
		let delta = baseidx-(List.hd lst)
		in
		List.map (fun x -> (x+delta)) lst
	end
	
	method rng2list rng = begin
		let (l,r) = self#rng2lr rng
		in begin
			let rec runlist li ri = begin
				if li > ri then li::(runlist (li-1) ri)
				else if li< ri then li::(runlist (li+1) ri)
				else [ri]
			end
			in 
			runlist l r
		end
	end
	
	method rng2lr rng= begin
			match rng with
			T_range(expl,expr) -> begin
				let idxl= Expression.exp2int_simple expl
				and idxr= Expression.exp2int_simple expr
				in
				(idxl,idxr)
			end
			| T_range_int(li,ri) -> (li,ri)
			| T_range_NOSPEC -> (-1,-1)
	end
	
	method isdff name = begin
		let co = self#findco (new hierachcal_name [name])
		in begin
			match co#get_obj with
			Tobj_dff_declaration(_) -> true
			| _ -> false
		end
	end
	

	method name2range name = begin
			match (self#findco (new hierachcal_name [name]))#get_obj with
			Tobj_input_declaration(rng) -> rng
			| Tobj_output_declaration(rng) -> rng
			| Tobj_net_declaration(rng) -> rng
			| Tobj_reg_declaration(rng) -> rng
			| Tobj_dff_declaration(rng) -> rng
			| _ -> begin
				Printf.printf "fatal error : name2range not support Tobj\n";
				exit 1
			end
	end
	
	method idx2name idx_unmapped = begin
		let idx= begin (*we must be careful that we may use idx2name before finish encoding the first instance*)
			if final_index_oneinst==0 then idx_unmapped
			else idx_unmapped mod final_index_oneinst
		end
		in
		(*let ssy=List.filter (fun x -> match x with (nm,(idx1,idx2)) -> if (idx1==idx || idx2==idx) then true else false) name_index_lst
		in *)
		begin
			(*if (List.length ssy) == 1 then fst (List.hd ssy)
			else if  (List.length ssy) == 0 then*)
			begin
				(*it may be in range of some defined data*)
				let nm_idx1_li_ri_idx2name nm idx1 li ri idx = 
					let off=(self#construct_offset idx1 li ri idx)
					in begin
						if (off == -1) then nm
						else sprintf "%s[%d]" nm off
					end
				in
				let pred_inrange ni = begin
					match ni with
					(nm,(idx1,-1)) -> begin
						let (li,ri)=self#rng2lr (self#name2range nm)
						in 
						if (self#is_inrange (self#construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else ""
					end
					| (nm,(idx1,idx2)) -> begin
						let (li,ri)=self#rng2lr (self#name2range nm)
						in 
						if (self#is_inrange (self#construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else if (self#is_inrange (self#construct_range_onidx idx2 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx2 li ri idx)
						else ""
					end
					| _ -> ""
				end
				in
				let res = List.map pred_inrange name_index_lst 
				in
				let res1 = List.filter (fun x -> (String.length x) !=0) res
				in begin
					if (List.length res1)==1 then List.hd res1
					else "unknown"
				end
			end
			(*else begin
				Printf.printf "warning : idx2name multiple matched , # of match %d , idx = %d , final_index_oneinst=%d\n" (List.length ssy)  idx final_index_oneinst;
				List.iter (fun x -> match x with (nm,_) -> print_string nm) ssy;
				(*sometimes we will use temp vars to record the add carry bit and so on, they dont has defined name and mapping*)
				(*print_string "name_index_lst:\n";
				List.iter (fun x -> match x with (nm,(id1,id2)) -> Printf.printf "%s %d %d\n" nm id1 id2) name_index_lst;*)
				"unknown"
			end*)
		end
	end
	
	(*print_cnf*)
	method print_cnf clslst dumpout_cnf dly len prefix forward instrlist outstrlist= begin
		fprintf dumpout_cnf "p cnf %d %d\n" (self#get_largest_varindex_inclslst clslst) (List.length clslst);
		
		fprintf dumpout_cnf "c module_name  %s \n" name;
		
		List.iter (fun x -> fprintf dumpout_cnf "c module_port  %s \n" (get_str_from_strlst x)) portlist;
		
		(*leave a blank line for awk to exit from printing module definition *)
		fprintf dumpout_cnf "c module_def_end\n"  ;
		
		fprintf dumpout_cnf "c clkname %s\n" clkname;
		
		fprintf dumpout_cnf "c for_rev_cz final_index_oneinst %d\n" final_index_oneinst;
		
		fprintf dumpout_cnf "c for_rev_cz dly %d\n" dly;
		
		fprintf dumpout_cnf "c for_rev_cz len %d\n" len;
		
		fprintf dumpout_cnf "c for_rev_cz prefix %d\n" prefix;
		
		fprintf dumpout_cnf "c for_rev_cz forward %d\n" forward;
		
		(*print out the truepred list*)
		let proc_truepred cls = begin
			match cls with
			([pred],_) -> begin
				if pred > 0 then 
					fprintf dumpout_cnf "c pre_truepred %d\n" pred
			end
			| _ -> ()
		end
		in
		List.iter proc_truepred clslst
		;
		
		let left nm = match (self#rng2lr (self#name2range nm)) with (left,_)->left
		and right nm= match (self#rng2lr (self#name2range nm)) with (_,right)->right
		in begin
			List.iter (fun instr ->  fprintf dumpout_cnf "c for_rev_cz input %s %d %d\n"  instr  (left instr)  (right instr))  instrlist;
			List.iter (fun outstr -> fprintf dumpout_cnf "c for_rev_cz output %s %d %d\n" outstr (left outstr) (right outstr)) outstrlist;
		end
		;
		
		let proc_hst key co = begin
			match co#get_obj with
			Tobj_input_declaration(rng) -> 	begin
				match (self#rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c input_port %s\n" key 
					else
						fprintf dumpout_cnf "c input_port [%d:%d] %s\n" left right key 
				end
			end
			| Tobj_output_declaration(rng) -> 	begin
				match (self#rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c output_port %s\n" key 
					else
						fprintf dumpout_cnf "c output_port [%d:%d] %s\n" left right key 
				end
			end
			| _ -> ()
		end
		in
		Hashtbl.iter proc_hst circuit_hst
		;
		
		let print_name_index name_index = begin
			match name_index with
			(nm,(curidx,nxtidx)) -> begin
				fprintf dumpout_cnf "c one instance mapping %s %d %d " nm curidx nxtidx;
				match (self#rng2lr (self#name2range nm)) with
				(left,right) -> 
					fprintf dumpout_cnf "%d %d\n" left right
			end
		end
		in
		List.iter print_name_index name_index_lst
		;
		
		let print_clause cls = begin
			match cls with
			(litlst,cmt) -> begin
				fprintf dumpout_cnf "c %s\n" cmt;
				(*List.iter (fun lit -> if ( lit != -1 && lit != 2 ) then begin fprintf dumpout_cnf "%d " lit end) litlst ;*)
				List.iter (fun lit -> fprintf dumpout_cnf "%d " lit ) litlst ;
				fprintf dumpout_cnf "0\n"
			end
		end
		in
		List.iter print_clause clslst
	end
	
	method get_largest_varindex_incls cls = begin
		match cls with
		(litlst,_) -> 
			List.fold_left (fun x y -> max (abs x) (abs y)) 0 litlst
	end
	
	method get_largest_varindex_inclslst clslst= begin
		let maxlist=List.map (self#get_largest_varindex_incls) clslst
		in
		List.fold_left (fun x y -> max (abs x) (abs y)) 0 maxlist
	end
	
	method construct_range_onidx baseidx li ri = begin
		(*actualy li may > ri*)
		if li < ri then T_range_int(baseidx,baseidx+ri-li)
		else T_range_int(baseidx,baseidx+li-ri)
	end
	
	method construct_offset baseidx li ri idx2beoff= begin
		(*actualy li may > ri*)
		if li<ri then 	li+idx2beoff-baseidx
		else li+baseidx-idx2beoff
	end

	(*allocate last_index to last_index+num-1 , and set last_index to last_index+num*)
	method alloc_index num= begin
		let oldindex = last_index
		in begin
			last_index <- last_index+num;
			oldindex
		end
	end
	
end
