open Typedef
open Circuit_obj
open Print_v
open Misc2
open Misc
open Statement
open Printf
open Misc2
open Print_v
open Dependent

exception UNSAT

type result = SATISFIABLE | UNSATISFIABLE

class elabmod = 
object (self)

	(*these will be generated in init method*)
	val mutable name = ""
	val mutable portlist = []
	val mutable tempdirname = ""
	
	(*these will be generated in elaborate method*)
	val circuit_hst : (string, Circuit_obj.circuit_obj) Hashtbl.t = Hashtbl.create 1 
	val mutable clkname = "" 
	val mutable seq_always_list : (statement*(string list)) list = [] (*string list is the list of result*)
	val mutable comb_always_list : (statement*(string list)) list = []
	val mutable cont_ass_list : assignment list = []

	(*these will be generatesd in encode_oneInstance2SAT_step1 method*)
	(*
		relation between varaibles name and its index
		the int pair in name_index_lst is for dff only, 
			the first one is current state, 
			the second one is for next state, which should be the first one plus rng width
		for other case
			only the first one is meaningful
			the second one must be -1
		
	*)
	val mutable name_index_lst : (string*(int*int)) list = []  
	val mutable clause_list : ((int list)*string) list = [([1],"truepred");([-2],"falsepred")]
	val mutable last_index = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)
	val mutable final_index_oneinst = 0
	val truepred = 1
	val falsepred =2
	(*these will generated by multiple instance generation*)

	val mutable clause_list_multiple : ((int list)*string) list = []

	val mutable clause_list_multiple_saved : ((int list)*string) list = []
	val mutable last_index_saved = 3 (*1 is preserved for true predicate, 2 preserved for falsepred*)
	
	val mutable regcnt = 0 ;

	method print dumpout = begin
		fprintf dumpout "module %s (\n" name;
		list_iter_interleave (fun x -> fprintf dumpout "   %s " (get_str_from_strlst x)) (fun x -> fprintf dumpout " , \n") portlist;
		fprintf dumpout "\n);\n";
		
		(*print out all input*)
		let print_input key cont = begin
			match cont#get_obj with
			Tobj_input_declaration(rng) -> begin
				fprintf dumpout "   input ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_input circuit_hst
		;
		
		(*print out all output*)
		let print_output key cont = begin
			match cont#get_obj with
			Tobj_output_declaration(rng) -> begin
				fprintf dumpout "   output ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_output circuit_hst
		;
		
		(*print out all wire*)
		let print_wire key cont = begin
			match cont#get_obj with
			Tobj_net_declaration(rng) -> begin
				fprintf dumpout "   wire ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_wire circuit_hst
		;
		
		(*print out all reg*)
		let print_reg key cont = begin
			match cont#get_obj with
			Tobj_reg_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| Tobj_dff_declaration(rng) -> begin
				fprintf dumpout "   reg ";
				print_v_range dumpout rng;
				fprintf dumpout "   %s ; \n" key
			end
			| _ -> ()
		end
		in
		Hashtbl.iter print_reg circuit_hst
		;
		
		(*print out all seq*)
		let print_seq seq_always = begin
			match seq_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(posedge %s) begin\n" clkname;
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_seq seq_always_list
		;
		
		(*print out all comb*)
		let print_comb comb_always = begin
			match comb_always with
			(stat,reglist) -> begin
				fprintf dumpout "always  @(\n";
				
				let deplist= dep_statement stat
				in
				list_iter_interleave (fun x -> fprintf dumpout " %s " x) (fun x -> fprintf dumpout " or ") deplist
				;
				
				fprintf dumpout ") begin\n";
				print_v_statement dumpout stat;
				fprintf dumpout "end \n" 
			end
			| _ -> ()
		end
		in
		List.iter print_comb comb_always_list
		;
		
		(*print out all cont assign*)
		let print_cont_ass cont_ass = begin
			match cont_ass with
			T_assignment(lv,exp) -> begin
				fprintf dumpout "assign  ";
				print_v_lvalue dumpout lv;
				fprintf dumpout " = ";
				print_v_expression dumpout exp;
				fprintf dumpout ";\n"
			end
			| _ -> ()
		end
		in
		List.iter print_cont_ass cont_ass_list
		;
		
		
		fprintf dumpout "endmodule\n"
	end

	method getname = name

	method addco hn co = begin
		Printf.printf "adding %s\n" hn#getname ;
		Hashtbl.add circuit_hst hn#getname co
	end

	method rplco hn co = begin
		Printf.printf "replacing %s\n" hn#getname ;
		Hashtbl.replace circuit_hst hn#getname co
	end

	method findco_str str = begin
		self#findco (new hierachcal_name [str])
	end

	method findco hn = begin
		try 
			Hashtbl.find circuit_hst hn#getname 
		with Not_found -> begin
			Printf.printf "fatal error : undefined hn %s are treated as wire\n" hn#getname;
			exit 1
			(*following code is for those large number of undefined net*)
			(*self#addco hn (new circuit_obj (Tobj_net_declaration(T_range_NOSPEC,T_expression_NOSPEC(1)))  hn);
			Hashtbl.find circuitobj_hst hn#getname *)
		end
	end

	method nameInportlist name1 = begin
		let check_portname pt= begin
			match pt with 
			[ptn] -> string_equ ptn name1
			|_ -> begin
				Printf.printf "fatal error : port name should not be a list\n";
				exit 1
			end
		end
		in 
		let portfound = List.filter check_portname  portlist
		in begin
			if (List.length portfound) != 1 then begin
				Printf.printf "fatal error : portfound is not unique\n";
				exit 1
			end
		end
	end
	
	method proc_T_input_declaration range namelst = begin
		let proc_one_input name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let inCircuitObj = new circuit_obj (Tobj_input_declaration(range))  newhn
			in
			self#addco newhn inCircuitObj
		end
		in 
		List.iter proc_one_input namelst
	end
	
	method proc_T_output_declaration range namelst = begin
		let proc_one_output name1 = begin
			(*first check that they are actually in portlist*)
			self#nameInportlist name1
			;
			(*add it to circuit object list*)
			let newhn=new hierachcal_name [name1]
			in
			let outCircuitObj = new circuit_obj (Tobj_output_declaration(range))  newhn
			in
			self#addco newhn outCircuitObj
		end
		in 
		List.iter proc_one_output namelst
	end
	
	method proc_T_net_declaration nettypename exprng namelst = begin
		if (string_equ nettypename "wire") != true then begin
			Printf.printf "fatal error : only supported wire\n";
			Printf.printf "%s\n" nettypename;
			exit 1
		end
		;
		let rng = match exprng with
		T_expandrange_range(rng1) -> rng1
		| T_expandrange_NOSPEC -> T_range_NOSPEC
		|_ -> begin
			Printf.printf "fatal error : only supported T_expandrange_range\n";
			exit 1
		end
		in begin
			let proc_one_net netn = begin
				(*add it to circuit object list*)
				let newhn=new hierachcal_name [netn]
				in
				let netCircuitObj = new circuit_obj (Tobj_net_declaration(rng))  newhn
				in
				self#addco newhn netCircuitObj
			end
			in 
			List.iter proc_one_net namelst
		end
	end
	
	method proc_T_reg_declaration  rng regvarlst = begin
		let proc_one_reg regvar = begin
			(*add it to circuit object list*)
			match regvar with
			T_register_variables_ID(regname) -> begin
				let newhn=new hierachcal_name [regname]
				in
				let regCircuitObj = new circuit_obj (Tobj_reg_declaration(rng))  newhn
				in
				self#addco newhn regCircuitObj
			end
			| T_register_variables_IDrange(regname,lexp,rexp) -> begin
				Printf.printf "fatal error : not supported T_register_variables_IDrange\n";
				exit 1
			end
		end
		in 
		List.iter proc_one_reg regvarlst
	end
	
	method proc_T_continuous_assign cont_ass = begin
		let asslst = begin
			match cont_ass with
			T_continuous_assign_assign(_,_,asslst1) -> asslst1
			| T_continuous_assign_net(nettypename,_,exprng,_,asslst1) -> begin
				(*i need to first put them into circuit object list*)
				begin
					let ass2name ass = begin
						match ass with 
						T_assignment(lv,_) -> begin
							match lv with 
							T_lvalue_id([nm]) -> nm
							| _ -> begin
								Printf.printf "fatal error : only supported T_lvalue_id 2\n";
								exit 1
							end
						end
					end
					in
					let namelst = List.map ass2name asslst1
					in
					self#proc_T_net_declaration nettypename exprng namelst
				end
				;
				asslst1
			end
		end
		in  cont_ass_list <- asslst @ cont_ass_list
		(*begin
			let proc_ass ass = begin
				match ass with
				T_assignment(lv,exp) -> begin
					match lv with
					T_lvalue_id([nm]) -> begin
						let hn = new hierachcal_name [nm]
						in
						let rngold = begin
							match ((self#findco hn)#get_obj) with
							Tobj_net_declaration(rngo,_) -> rngo
							| _ -> begin
								Printf.printf "fatal error : only should find Tobj_net_declaration \n";
								exit 1
							end
						end
						in
						let co =new circuit_obj (Tobj_net_declaration(rngold,exp)) hn
						in
						self#rplco hn co
					end
					| T_lvalue_arrbit
					| _ -> begin
						Printf.printf "fatal error : only supported T_lvalue_id 1\n";
						print_v_lvalue stdout lv;
						exit 1
					end
				end
			end
			in
			List.iter proc_ass asslst
		end*)
	end
	
	method proc_T_always_statement_seq stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				if (List.length evexplst) != 1 then begin
					Printf.printf "fatal error : only supported sync set and reset regs\n";
					exit 1
				end
				;
				(*set the clock*)
				let clkeve=(List.hd evexplst)
				in begin
					match clkeve with 
					T_event_expression_posedge(exp) -> begin
						match exp with
						T_primary(T_primary_id([clkn])) -> begin
							if (string_equ clkname "") then clkname <- clkn
							else if (string_equ clkname clkn) then clkname <- clkn
							else begin
								Printf.printf "fatal error : only supported one clock\n";
								exit 1
							end
						end
						| _ -> begin
							Printf.printf "fatal error : only supported id as clock name\n";
							exit 1
						end
					end
					| _ -> begin
						Printf.printf "fatal error : only supported T_event_expression_posedge\n";
						exit 1
					end
				end
				;
				(*extract the reg name list*)
				let regnamelist = statement2regnamelist stat_sub
				in begin
					(*add these reg's definition to list*)
					seq_always_list <- (stat_sub,regnamelist) :: seq_always_list
					;
					(*change them to dff*)
					let proc_reg regname = begin
						let hn= new hierachcal_name [regname]
						in
						let co = self#findco hn
						in begin
							match co#get_obj with
							Tobj_reg_declaration(rngr) -> begin
								self#rplco hn (new circuit_obj (Tobj_dff_declaration(rngr)) hn)
							end
							| Tobj_dff_declaration(_) -> begin
								Printf.printf "warning : why it is already dff?\n";
								Printf.printf "%s\n" regname;
							end
							| _ -> begin
								Printf.printf "fatal error : object in always statement should be declared as reg\n";
								Printf.printf "%s\n" regname;
								exit 1
							end
						end
					end
					in
					List.iter proc_reg regnamelist
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement_comb stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			let regnamelist = statement2regnamelist stat_sub
			in
			comb_always_list <- (stat_sub,regnamelist) :: comb_always_list
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_T_always_statement stat = begin
		match stat with
		T_event_statement(evctl,stat_sub) -> begin
			match evctl with
			T_event_control_evexp(evexplst) -> begin
				let isedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> true
					| T_event_expression_negedge(_) -> true
					| _ -> false
				end
				and notedgeevent evexp = begin
					match evexp with
					T_event_expression_posedge(_) -> false
					| T_event_expression_negedge(_) -> false
					| _ -> true
				end
				in
				if (List.for_all isedgeevent evexplst) then self#proc_T_always_statement_seq stat
				else if (List.for_all notedgeevent evexplst) then self#proc_T_always_statement_comb stat
				else begin
					Printf.printf "fatal error : edge and non edge event at the same time\n";
					exit 1
				end
			end
			| _ -> begin
				Printf.printf "fatal error : only supported T_event_control_evexp\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : only supported T_event_statement\n";
			exit 1
		end
	end
	
	method proc_MI mi= begin
		match mi with
		T_parameter_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_declaration\n";
			exit 1
		end
		| T_input_declaration(range,namelst) -> 
			self#proc_T_input_declaration range namelst
		| T_output_declaration(range,namelst) -> 
			self#proc_T_output_declaration range namelst
		| T_inout_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_inout_declaration\n";
			exit 1
		end
		| T_net_declaration(netname,_,exprng,_,namelst) -> 
			self#proc_T_net_declaration netname exprng namelst
		| T_reg_declaration(rng,regvarlst) -> 
			self#proc_T_reg_declaration rng regvarlst
		| T_time_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_time_declaration\n";
			exit 1
		end
		| T_integer_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_integer_declaration\n";
			exit 1
		end
		| T_real_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_real_declaration\n";
			exit 1
		end
		| T_event_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_event_declaration\n";
			exit 1
		end
		| T_gate_declaration(_) -> begin
			Printf.printf "fatal error : not supported T_gate_declaration\n";
			exit 1
		end
		| T_module_instantiation(defname,_,_,minstlst) -> begin
		  match minstlst with
		  [T_module_instance(instname,T_list_of_module_connections_named(npclst))] -> begin
			printf "defname %s instname %s\n" defname instname;
			match defname with
			"FD1" -> begin
				let dexp=  self#find_pin_exp "D" npclst
				and cpexp= self#find_pin_exp "CP" npclst
				and qexp=  self#find_pin_exp "Q" npclst
				and qnexp= self#find_pin_exp "QN" npclst
				in begin
					match qexp with
					T_expression_NOSPEC(_) -> begin
						match qnexp with
						T_expression_NOSPEC(_) -> begin
							()
						end
						| _ -> begin
							(*let regname=String.concat "" ["regssy_";(string_of_int(regcnt))]*)
(*above is used to hide the reg name
following is used to expose them for debugging*)
							let regname=instname
							in begin
								regcnt <- regcnt +1 
								;
								self#proc_T_reg_declaration (T_range_NOSPEC) [T_register_variables_ID(regname)]
								;
								printf "added 1\n"
								;
								self#proc_T_always_statement (T_event_statement(T_event_control_evexp([T_event_expression_posedge(cpexp)]),T_non_blocking_assignment(T_non_blocking_assignment_direct(T_lvalue_id([regname]),dexp))))
								;
								self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv qnexp),T_logicneg(T_primary_id([regname])))]))
								;
								()
							end
						end
					end
					| _ -> begin
						(*let regname=String.concat "" ["regssy_";(string_of_int(regcnt))]*)
(*above is used to hide the reg name
following is used to expose them for debugging*)
						let regname=instname
						in begin
							regcnt <- regcnt +1 
							;
							self#proc_T_reg_declaration (T_range_NOSPEC) [T_register_variables_ID(regname)]
							;
							self#proc_T_always_statement (T_event_statement(T_event_control_evexp([T_event_expression_posedge(cpexp)]),T_non_blocking_assignment(T_non_blocking_assignment_direct(T_lvalue_id([regname]),dexp))))
							;
							self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv qexp),T_primary(T_primary_id([regname])))]))
							;
							match qnexp with
							T_expression_NOSPEC(_) -> begin
							end
							| _ -> begin
								self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv qnexp),T_logicneg(T_primary_id([regname])))]))
							end
							;
							printf "added 2\n"
							;
							()
						end
					end
				end
			end
			| "AN2" -> begin
				printf "added AN2\n"
				;
				let zexp= self#find_pin_exp "Z" npclst
				and aexp= self#find_pin_exp "A" npclst
				and bexp= self#find_pin_exp "B" npclst
				in
				self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv zexp),T_logic_and2(aexp,bexp))]))
			end
			| "IV" -> begin
				printf "added IV\n"
				;
				let zexp= self#find_pin_exp "Z" npclst
				and aexp= self#find_pin_exp "A" npclst
				in begin
					match aexp with
					T_primary(aprim) -> begin
						self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv zexp),T_logicneg(aprim))]))
					end
					| _ -> begin
						Printf.printf "fatal error : aexp is not T_primary form\n";
						exit 1
					end
				end
			end
			| "OR2" -> begin
				printf "added OR2\n"
				;
				let zexp= self#find_pin_exp "Z" npclst
				and aexp= self#find_pin_exp "A" npclst
				and bexp= self#find_pin_exp "B" npclst
				in
				self#proc_T_continuous_assign (T_continuous_assign_assign(T_drive_strength_NOSPEC,T_delay_NOSPEC,[T_assignment((exp2lv zexp),T_logic_or2(aexp,bexp))]))
			end
			| _ -> begin
				Printf.printf "fatal error : T_module_instantiation only support FD1 AN2 IV and OR2 cells of lsi10k\n";
				exit 1
			end
		  end
		  | _ -> begin
			Printf.printf "fatal error : T_module_instantiation only support 1 minst in minstlst\n";
			exit 1
		  end
		end
		| T_parameter_override(_) -> begin
			Printf.printf "fatal error : not supported T_parameter_override\n";
			exit 1
		end
		| T_continuous_assign(cont_ass) ->  
			self#proc_T_continuous_assign cont_ass
		| T_specify_block(_) -> begin
			Printf.printf "fatal error : not supported T_specify_block\n";
			exit 1
		end
		| T_initial_statement(_) -> begin
			Printf.printf "fatal error : not supported T_initial_statement\n";
			exit 1
		end
		| T_always_statement(stat) -> 
			self#proc_T_always_statement stat
		| T_task(_,_,_) -> begin
			Printf.printf "fatal error : not supported T_task\n";
			exit 1
		end
		| T_function_avoid_amb(_,_,_,_) -> begin
			Printf.printf "fatal error : not supported T_function_avoid_amb\n";
			exit 1
		end
	end

	method init module2beElaborated tempdirname1 = begin
		match module2beElaborated with
		T_module_def(modName,portlist1,milist) -> begin
			name <- modName;
			portlist <- portlist1;
			tempdirname <- tempdirname1;
			(*processing mi list*)
			List.iter (self#proc_MI) milist
		end
		| _ -> begin
			Printf.printf "fatal error : only T_module_def\n";
			exit 1
		end
	end

	method name2idxlist name = begin
		let baseidx = begin
			let (x1,_)=List.assoc name name_index_lst
			in x1
		end
		and rng=self#name2range name
		in 
		self#rng_baseidx_2_idxlist rng baseidx	
	end


	method proc_name_index inst res_intlst ni = begin
		match ni with
		(nm,(cur,next)) -> begin
			let offset=inst*final_index_oneinst
			in begin
				let (left,right)=self#rng2lr (self#name2range nm)
				in 
				let strlr=begin
					if left== -1 && right== -1 then nm
					else sprintf "%s [%d:%d]" nm left right
				end
				in begin
					let vstart=cur+offset
					and vend=cur+offset+abs(right-left)
					in
					let idxlst=self#rng2list (T_range_int(vstart,vend))
					in
					let vmap=List.map (self#find_inass res_intlst) idxlst
					in
					let vvector=List.map (fun x -> if x > 0 then 1 else 0) vmap
					in begin
						Printf.printf "   %s = %d'b" strlr (List.length vvector);
						List.iter (Printf.printf "%d") vvector;
						Printf.printf "\n"
					end
				end
			end
		end
	end

	method find_inass res_intlst idx = begin
		List.find (fun x -> (abs(x))==idx) res_intlst
	end

	method map_ass2var bound res_intlst = begin
		let rec proc_inst inst = begin
			if inst == bound then ()
			else begin
				Printf.printf "============inst %d============\n" inst;
				List.iter (self#proc_name_index inst res_intlst) name_index_lst ;
				proc_inst (inst+1)
			end
		end
		in
		proc_inst 0
	end


	(*to connect next state of one instance to current state of last instance*)
	method connect_multiple_instance_step3 start_bound end_bound = begin
		let dff_idxpair=List.filter (fun x -> match x with (_,(_,-1))-> false | _ -> true) name_index_lst
		in 
		let rec connect_inst i = begin
			if i == end_bound then []
			else begin
				let connect_dffpair dffpair = begin
					match dffpair with
					(nm,(current_idx,next_index)) -> begin
						(*make sure it is actually dff*)
						if self#isdff nm then begin
							let current_off=(i+1)*final_index_oneinst
							and next_off = i*final_index_oneinst
							in
							let new_current_idx=current_off+current_idx
							and new_next_index=next_off+next_index
							in 
							let (rli,rlr)=self#rng2lr (self#name2range nm)
							in
							let (rli_real_cur,rlr_real_cur)=self#rng2lr (self#construct_range_onidx new_current_idx rli rlr)
							and (rli_real_nxt,rlr_real_nxt)=self#rng2lr (self#construct_range_onidx new_next_index rli rlr)
							in begin
								if (rli_real_cur==new_current_idx) && (new_current_idx-new_next_index==final_index_oneinst-(abs(rlr-rli)+1)) && (rli_real_cur-final_index_oneinst+abs(rlr-rli)+1==rli_real_nxt) then begin
									(*encode every bit in this range*)
									let rec connect_1bitdff idxi idxr = begin
										if idxi>idxr then []
										else begin
											let oldcl = connect_1bitdff (idxi+1) idxr
											and newmapped = (self#encode_EQU idxi (idxi-final_index_oneinst+abs(rlr-rli)+1))
											in
											let newmapped_commented= List.map (self#setcomment (sprintf "connecting dff %s from instance %d to %d" nm i (i+1))) newmapped 
											in
											newmapped_commented @ oldcl
										end
									end
									in
									connect_1bitdff rli_real_cur rlr_real_cur
								end
								else begin
									Printf.printf "fatal error : improper connect_dffpair\n";
									Printf.printf "rli_real_cur %d\n" rli_real_cur;
									Printf.printf "rlr_real_cur %d\n" rlr_real_cur;
									Printf.printf "new_current_idx %d\n" new_current_idx;
									Printf.printf "new_next_index %d\n" new_next_index;
									Printf.printf "rlr %d\n" rlr;
									Printf.printf "rli %d\n" rli;
									Printf.printf "final_index_oneinst %d\n" final_index_oneinst;
									Printf.printf "rli_real_nxt %d\n" rli_real_nxt;
									Printf.printf "rlr_real_nxt %d\n" rlr_real_nxt;
									exit 1
								end
							end
						end
						else begin
							Printf.printf "fatal error : it should be dff\n";
							exit 1
						end
					end
				end
				in 
				(List.concat (List.map connect_dffpair dff_idxpair)) @ connect_inst (i+1)
			end
		end
		in
		connect_inst start_bound
	end

	method setcomment str cls = begin
		match cls with
		(intlst,_) -> (intlst,str)
	end
	
	method appendcomment str cls = begin
		match cls with
		(intlst,strold) -> (intlst,(self#cat_string strold str))
	end
	
	method cat_string str1 str2 = begin
		String.concat ":::" [str1;str2]
	end
	
	(*generate multiple instance, which bound is defined*)
	method gen_multiple_instance_step2 bound = begin
		let rec gen_instance inst = begin
		   if inst == bound then []
		   else begin
			let oclslst=gen_instance (inst+1)
			in
			let encode_instance ii= begin
				let off=ii*final_index_oneinst
				in 
				let cls_off offf cls = begin
					let lit_off offff lit= begin
						if lit > 0 then lit+offff
						else lit -offff
					end
					in
					self#appendcomment (self#cat_string "instance " (string_of_int ii)) ((List.map (lit_off offf) (fst cls)),(snd cls)) 
				end
				in
				List.map (cls_off off) clause_list
			end
			in
			(encode_instance inst)@oclslst
		   end
		end
		in 
		let clslst=gen_instance 0
		in 
		(clslst,(final_index_oneinst*bound))
	end

	method encode_oneInstance2SAT_step1  = begin
		(*index for explictly named vars, such as input output wire reg dff*)
		self#encode2SAT_explictname;
		(*this is the true encode*)

		Printf.printf "start to do 1 encode2SAT_explictname \n" ;


		(*encode the seq_always_list*)
		let seq_clslst=self#encode2SAT_seq_always_list truepred
		and comb_clslst=self#encode2SAT_comb_always_list truepred
		and cont_clslst=self#encode2SAT_contass_list
		in
		seq_clslst@comb_clslst@cont_clslst
	end
	
	method encode2SAT_contass_list = begin
		Printf.printf "start to do 1 encode2SAT_contass_list \n" ;
		List.concat (List.map (self#encode_ass) cont_ass_list)
	end
	
	method encode_ass ass = begin
		match ass with
		T_assignment(lv,exp) -> begin
			let truepred=1
			in 
			self#encode_nba_incomb (T_non_blocking_assignment_direct(lv,exp)) truepred
		end
	end
	
	method encode2SAT_comb_always_list envpred = begin
		Printf.printf "start to do 1 encode2SAT_comb_always_list \n" ;
		let encode_comb_always comb_always = begin
			match comb_always with
			(stat,_) -> self#encode_statement_incomb envpred stat   
		end
		in
		List.concat (List.map encode_comb_always comb_always_list)
	end
	
	method encode_statement_incomb envpred stat = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_incomb dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_incomb nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predclslst)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex ,(self#encode_Red_AND oldindex [envpred;expidx] ))
				end
				in
				newpred_clslst @ (self#encode_statement_incomb newpred stat_sub  ) @ predclslst
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predclslst)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in 
				let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
				and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
				in 
				predclslst @ thenpredclslist @ elsepredclslist @ (self#encode_statement_incomb thenpred stat1) @ (self#encode_statement_incomb elsepred stat2 )
			end
		end
		| T_case_statement(exp,cilst) -> begin
			let rec case2ifelse cl = begin
				match cl with
				[] -> begin
					Printf.printf "fatal error : you should not reach [] in case statement\n";
					exit 1
				end
				| [T_case_item_normal(explst,st1);T_case_item_default(stlast)] -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,stlast)
				end
				| (T_case_item_normal(explst,st1))::tl -> begin
					let newexp = T_reduce_or(T_primary_concat((List.map (fun e -> T_logic_equ(exp,e)) explst)))
					in
					T_if_else_statement(newexp,st1,(case2ifelse tl))
				end
				| _ -> begin
					Printf.printf "fatal error : you should not reach here in case statement\n";
					exit 1
				end
			end
			in
			self#encode_statement_incomb envpred (case2ifelse cilst)
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_incomb envpred) statlst  )
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	
	method encode2SAT_seq_always_list envpred= begin
		Printf.printf "start to do 1 encode2SAT_seq_always_list \n" ;
		let encode_seq_always seq_always = begin
			match seq_always with
			(stat,_) -> self#encode_statement_inseq envpred stat   
		end
		in
		List.concat (List.map encode_seq_always seq_always_list)
	end
	
	method encode_nba_incomb nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_incomb only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_incomb lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method encode_statement_inseq envpred stat  = begin
		match stat with
		T_blocking_assignment(ba) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_blocking_assignment\n";
			exit 1
		end
		| T_non_blocking_assignment(nba) -> self#encode_nba_inseq nba envpred
		| T_if_statement(exp,stat_sub) -> begin
			let (expidx,_,predcl)=self#encode_pred exp  (*produce the positive exp and negative exp*)
			in begin
				let (newpred,newpred_clslst)= begin
					let oldindex = self#alloc_index 1
					in 
					(oldindex,(self#encode_Red_AND oldindex [envpred;expidx]))
				end
				in 
				predcl @ newpred_clslst @ (self#encode_statement_inseq newpred stat_sub)
			end
		end
		| T_if_else_statement(exp,stat1,stat2) -> begin
			let (expidx1,expidx2,predcl)=self#encode_pred exp
			in begin
				let thenpred = self#alloc_index 1
				and elsepred = self#alloc_index 1
				in begin
					let thenpredclslist=self#encode_Red_AND thenpred [envpred;expidx1] 
					and elsepredclslist=self#encode_Red_AND elsepred [envpred;expidx2] 
					in 
					predcl @ (thenpredclslist @ elsepredclslist) @ (self#encode_statement_inseq thenpred stat1) @ (self#encode_statement_inseq elsepred stat2 )
				end
			end
		end
		| T_case_statement(exp,cilst) -> begin
			Printf.printf "fatal error : encode_statement_inseq dont support T_case_statement\n";
			exit 1
		end
		| T_seq_block(_,_,statlst) -> 
			List.concat (List.map (self#encode_statement_inseq envpred) statlst)
		| _ -> begin
			Printf.printf "fatal error : not supported statement\n";
			exit 1
		end
		(*| T_statement_NOSPEC
		| T_forever_statement of statement
		| T_repeat_statement of expression*statement
		| T_while_statement of expression*statement
		| T_for_statement of assignment*expression*assignment*statement
		| T_event_statement of event_control*statement
		| T_wait_statement of expression*statement
		| T_leadto_event of string
		| T_par_block of string*(module_item list)*(statement list)
		| T_task_enable of string*(expression list)		
		| T_system_task_enable of string*(expression list)
		| T_disable_statement of string  
		| T_force_statement of assignment
		| T_release_statement of lvalue
		| T_casez_statement of expression*(case_item list)
		| T_casex_statement of expression*(case_item list)
		| T_delay_statement of delay_control*statement*)
	end
	(*return positive , negative index and clause list*)
	method encode_pred exp = begin
		let (idxlst,cl)= self#encode_exp exp
		in 
		let idx=begin
			match idxlst with
			[pred] -> pred
			| _ -> begin
				Printf.printf "fatal error : invalid length of encode_pred\n";
				exit 1
			end
		end
		in 
		(*negative relationship*)
		let oldindex = self#alloc_index 1
		in
		(idx,oldindex,(self#encode_NEG idx oldindex)@cl)
	end
	(*return the list of exp bit and list of clause*)
	method encode_prim prim = begin
		match prim with
		T_primary_num(num) -> self#encode_number num 
		| T_primary_id([name]) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1  (*even for a dff, prim will always use current state*)
			end
			and rng=self#name2range name
			in 
			((self#rng_baseidx_2_idxlist rng baseidx),[])
		end
		| T_primary_id([]) -> begin
			Printf.printf "fatal error : not supported T_primary_id with zero string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_id(idlst) -> begin
			Printf.printf "fatal error : not supported T_primary_id with multiple string\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
		| T_primary_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if self#is_inrange rng off then begin
					let (left,right)=self#rng2lr rng
					in 
					([self#offset2idx left right baseidx off],[])
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_primary_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,_)=List.assoc name name_index_lst
				in  x1
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=self#lr2list li ri
			and (left,right)=self#rng2lr rng
			in begin
				if (self#is_inrange rng li ) && (self#is_inrange rng ri )  then begin
					((List.map (fun x -> self#offset2idx left right baseidx x) idxlst),[])
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| T_primary_minmaxexp(T_mintypmax_expression_1(exp)) -> self#encode_exp exp
		| T_primary_concat(explst) -> begin
			let (resv,rescls) = List.split (List.map (self#encode_exp) explst)
			in
			((List.concat resv),(List.concat rescls))
		end
		| _ -> begin
			Printf.printf "fatal error : not supported encode_prim\n";
			Print_v.print_v_primary  stdout prim;
			exit 1
		end
	end
	(*return the list of exp bit and list of clause*)
	method encode_number num = begin
		match num with
		T_number_unsign(i) -> begin
			let strlst=(List.rev (Misc2.int2bin i))
			in begin
				let rec proc_intlst slst = begin
					match slst with
					[] -> []
					| hd::tl -> begin
						match hd with
						"0" -> falsepred::(proc_intlst tl)
						| "1" -> truepred::(proc_intlst tl)
						| _ -> begin
							Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
							exit 1
						end
					end
				end 
				in
				((proc_intlst strlst),[])
			end
		end
		| T_number_base(len,base,str) -> begin
			if base=='b' || base=='B' then begin
				if String.length str == len then begin
					let numlst = Misc.string2charlist str 
					in begin
						let rec proc_numlst nl = begin
							match nl with
							[] -> []
							| hd::tl -> begin
								match hd with
								'0' -> 	falsepred::(proc_numlst tl)
								| '1' -> truepred::(proc_numlst tl)
								| _ -> begin
									Printf.printf "fatal error : proc_intlst other than 0 and 1\n";
									exit 1
								end
							end
						end
						in
						((proc_numlst numlst),[])
					end
				end
				else begin
					Printf.printf "fatal error : encode_prim length is not matched\n";
					exit 1
				end
			end
			else begin
				Printf.printf "fatal error : not supported base other than b or B in encode_prim\n";
				exit 1
			end
		end
		| _ -> begin
			Printf.printf "fatal error : T_number_float is not supported\n";
			exit 1
		end
	end
	
	(*return the list of exp bit and list of clause*)
	method encode_exp exp = begin
		match exp with
		T_primary(prim) -> self#encode_prim prim
		| T_primary_4arrayassign(_) -> begin
			Printf.printf "fatal error : not supported T_primary_4arrayassign\n";
			exit 1
		end
		| T_add1(prim) -> self#encode_prim prim
		| T_sub1(prim) -> begin
			Printf.printf "fatal error : not supported T_sub1\n";
			exit 1
		end
		| T_logicneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in begin
				match bitlst with
				[idx] -> begin
					let oldindex = self#alloc_index 1
					in 
					([oldindex],(self#encode_NEG_ASSIGN oldindex idx )@clst)
				end
				| _ -> begin
					Printf.printf "fatal error : invalid length in T_logicneg\n";
					exit 1
				end
			end
		end
		| T_bitneg(prim) -> begin
			let (bitlst,clst) = self#encode_prim prim
			in
			let rec proc_bitlst bl = begin
				match bl with
				[] -> ([],[])
				| hd::tl -> begin
					let oldindex = self#alloc_index 1
					and (oldblst,oldclst)=(proc_bitlst tl)
					in 
					((oldindex::oldblst),(self#encode_NEG_ASSIGN oldindex hd)@oldclst)
				end
			end
			in
			let (bl,cl)=proc_bitlst bitlst
			in
			(bl,cl@clst)
		end
		| T_reduce_and(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_AND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nand(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NAND oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_or(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_OR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_nor(prim) -> begin
			let oldindex = self#alloc_index 1
			and (oldbcls,oldclst)=(self#encode_prim prim)
			in 
			([oldindex] , ((self#encode_Red_NOR oldindex oldbcls ) @ oldclst) )
		end
		| T_reduce_xor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xor\n";
			exit 1
		end
		| T_reduce_xnor(prim) -> begin
			Printf.printf "fatal error : not supported T_reduce_xnor\n";
			exit 1
		end
		| T_add2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let (addblst,addclst)=(self#encode_ADD vec1 vec2)
					in
					(addblst,(clslst1 @ clslst2 @ addclst))
				end
				else begin
					Printf.printf "fatal error : T_add2 length should be of the same\n";
					exit 1
				end
			end
		end
		| T_sub2(_,_) -> begin
			Printf.printf "fatal error : not supported T_sub2\n";
			exit 1
		end
		| T_mul2(_,_) -> begin
			Printf.printf "fatal error : not supported T_mul2\n";
			exit 1
		end
		| T_div(_,_) -> begin
			Printf.printf "fatal error : not supported T_div\n";
			exit 1
		end
		| T_mod(_,_) -> begin
			Printf.printf "fatal error : not supported T_mod\n";
			exit 1
		end
		| T_logic_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_equ_formular (List.tl plist))
							in
							((oldindex::bl), (self#encode_EQU_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_equ_formular pl
						and oldindex = self#alloc_index 1
						in 
						([oldindex], clslst1 @ clslst2 @ resclslst @ (self#encode_Red_AND oldindex reslst ) );
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_logic_ine(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if (List.length vec1) == (List.length vec2) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_ine_formular plist = begin
						match plist with
						[] -> ([],[])
						| _ -> begin
							let oldindex=self#alloc_index 1
							in 
							let (bl,cl)=(proc_ine_formular (List.tl plist))
							in
							((oldindex::bl),(self#encode_INE_res oldindex (fst (List.hd plist)) (snd (List.hd plist)) ) @ cl)
						end
					end
					in begin
						let (reslst,resclslst)=proc_ine_formular pl
						in
						let oldindex = self#alloc_index 1
						in 
						([oldindex] , clslst1 @ clslst2 @ resclslst @ (self#encode_Red_OR oldindex reslst ))
					end
				end
				else begin
					Printf.printf "fatal error : T_logic_equ length should be of the same\n";
					exit 1
				end
			end
		end
		| T_case_equ(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_equ\n";
			exit 1
		end
		| T_case_ine(_,_) -> begin
			Printf.printf "fatal error : not supported T_case_ine\n";
			exit 1
		end
		| T_logic_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_AND oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_logic_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in
			let oldindex = self#alloc_index 1
			in begin
				if ((List.length vec1) ==1) && ((List.length vec2) ==1) then 
					([oldindex],clslst1 @ clslst2 @ (self#encode_Red_OR oldindex [(List.hd vec1);(List.hd vec2)] ))
				else begin
					Printf.printf "fatal error : T_logic_and2 length must be both 1\n";
					exit 1
				end
			end
		end
		| T_lt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_lt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_lt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_lt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_lt case001 %d" oldindex))
									and case01=([b1;-b2;oldindex],(sprintf "T_lt case01 %d" oldindex))
									and case10=([-b1;b2;-oldindex],(sprintf "T_lt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_lt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_lt case111 %d" oldindex))
									in 
									( oldindex , [case000;case001;case01;case10;case110;case111] @ oldclslst)
								end
							end
						end
					end
					in 
					let (b,cl)=proc_lt_formular pl
					in
					([b],cl@clslst1@clslst2)
				end
				else begin
					Printf.printf "fatal error : T_lt length must be equ\n";
					exit 1
				end
			end
		end
		| T_le(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_lt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_gt(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_gt_formular pl1 = begin
						match pl1 with 
						[] -> (falsepred,[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in begin
								let (lastres,oldclslst)= proc_gt_formular tl
								in begin
									let case000=([b1;b2;lastres;-oldindex],(sprintf "T_gt case000 %d" oldindex))
									and case001=([b1;b2;-lastres;oldindex],(sprintf "T_gt case001 %d" oldindex))
									and case01=([b1;-b2;-oldindex],(sprintf "T_gt case01 %d" oldindex))
									and case10=([-b1;b2;oldindex],(sprintf "T_gt case10 %d" oldindex))
									and case110=([-b1;-b2;lastres;-oldindex],(sprintf "T_gt case110 %d" oldindex))
									and case111=([-b1;-b2;-lastres;oldindex],(sprintf "T_gt case111 %d" oldindex))
									in 
									(oldindex, [case000;case001;case01;case10;case110;case111]@oldclslst )
								end
							end
						end
					end
					in 
					let (b,cl)=proc_gt_formular pl
					in
					([b],cl @ clslst1 @ clslst2 )
				end
				else begin
					Printf.printf "fatal error : T_gt length must be equ\n";
					exit 1
				end
			end
		end
		| T_ge(exp1,exp2) -> begin
			let newexp=T_logic_or2(T_gt(exp1,exp2),T_logic_equ(exp1,exp2))
			in self#encode_exp newexp
		end
		| T_bit_and2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_and2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_and2 tl
							in 
							let andres=self#encode_AND2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_and2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_and2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_or2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_or2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_or2 tl
							in 
							let andres=self#encode_OR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_or2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_or2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_xor2(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_xor2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_xor2 tl
							in 
							let andres=self#encode_XOR2_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_xor2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_xor2 length must be equ\n";
					exit 1
				end
			end
		end
		| T_bit_equ(exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			in begin
				if ((List.length vec1) == (List.length vec2) ) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_equ2 pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_equ2 tl
							in 
							let andres=self#encode_EQU_res oldindex b1 b2 
							in 
							((oldindex::lastres), andres @ cl)
						end
					end
					in 
					let (bl,cl)=proc_equ2 pl
					in
					(bl,cl @ clslst1 @ clslst2)
				end
				else begin
					Printf.printf "fatal error : T_bit_equ length must be equ\n";
					exit 1
				end
			end
		end
		| T_leftshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_leftshift\n";
			exit 1
		end
		| T_rightshift(_,_) -> begin
			Printf.printf "fatal error : not supported T_rightshift\n";
			exit 1
		end
		| T_selection(predexp,exp1,exp2) -> begin
			let (vec1,clslst1)=self#encode_exp exp1
			and (vec2,clslst2)=self#encode_exp exp2
			and (predv,clslstpred)=self#encode_exp predexp
			in begin
				if ((List.length vec1) == (List.length vec2) && (List.length predv)==1) then begin
					let pl=List.combine vec1 vec2
					in
					let rec proc_sel pl1 = begin
						match pl1 with 
						[] -> ([],[])
						| (b1,b2)::tl -> begin
							let oldindex = self#alloc_index 1
							in 
							let (lastres,cl)= proc_sel tl
							in 
							let equres=self#encode_SEL_res oldindex b1 b2 (List.hd predv) 
							in 
							((oldindex::lastres),(equres @ cl))
						end
					end
					in 
					let (bl,cl)=proc_sel pl
					in
					(bl,cl @ clslst1 @ clslst2 @ clslstpred)
				end
				else begin
					Printf.printf "fatal error : T_selection length must be equ and predv must be 1\n";
					exit 1
				end
			end
		end
		| T_string(_) -> begin
			Printf.printf "fatal error : not supported T_string\n";
			exit 1
		end
		| T_expression_NOSPEC(_) -> begin
			Printf.printf "fatal error : not supported T_expression_NOSPEC\n";
			exit 1
		end
	end
	
	method encode_ADD vec1 vec2 = begin
		let oldindex = self#alloc_index (List.length vec1)
		and carryidx = self#alloc_index (List.length vec1)
		in begin
			(*from oldindex to oldindex+(List.length vec1)-1 are the result of add operation*)
			(*from oldindex+(List.length vec1) to oldindex+(List.length vec1)*2-1 are the carry of add operation*)
			(*proc_add will generate one more bit,which means the carry*)
			let rec proc_add v1 v2 residx cryidx= begin
				match v1 with
				[] -> begin
					if (List.length v2 == 0) && (residx == oldindex+(List.length vec1)) && (cryidx==oldindex+(List.length vec1)*2) then 
						([falsepred],[]) (*to enforce 0 cryidx*)
					else begin
						Printf.printf "fatal error : improper T_add2\n";
						Printf.printf "v2 len %d\n" (List.length v2);
						Printf.printf "v1 len %d\n" (List.length v1);
						Printf.printf "vec2 len %d\n" (List.length vec2);
						Printf.printf "vec1 len %d\n" (List.length vec1);
						Printf.printf "residx %d\n" residx;
						Printf.printf "cryidx %d\n" cryidx;
						Printf.printf "oldindex %d\n" oldindex;
						Printf.printf "carryidx %d\n" carryidx;
						exit 1
					end
				end
				| hd1::tl1 -> begin
					let hd2=List.hd v2
					and tl2=List.tl v2
					in begin
						let (reslst,resclslst) = proc_add tl1 tl2 (residx+1) (cryidx+1)
						in begin
							 let carry=List.hd reslst
							 in begin 
							 	(*we would like 
							 		hd2+hd1+carry==(cryidx,residx)
							 	*)
							 	(cryidx::(residx::(List.tl reslst)),resclslst@(self#encode_ADD_1bit hd1 hd2 carry cryidx residx))
							 	
							 end
						end
					end
				end
			end
			in
			let (bl,cl)=(proc_add vec1 vec2 oldindex carryidx) (*we dont want the hgihest carry*)
			in
			((List.tl bl),cl)
		end
	end
	
	method encode_ADD_1bit hd1 hd2 carry cryidx residx = begin
		let cry000 = ([hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry001 = ([hd1;		hd2;		-1*carry;	-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry010 = ([hd1;		-1*hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry011 = ([hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry100 = ([-1*hd1;		hd2;		carry;		-1*cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry101 = ([-1*hd1;		hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry110 = ([-1*hd1;		-1*hd2;		carry;		cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and cry111 = ([-1*hd1;		-1*hd2;		-1*carry;	cryidx],(sprintf "encode_ADD_1bit_cry %d" cryidx))
		and res000 = ([hd1;		hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res001 = ([hd1;		hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res010 = ([hd1;		-1*hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res011 = ([hd1;		-1*hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res100 = ([-1*hd1;		hd2;		carry;		residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res101 = ([-1*hd1;		hd2;		-1*carry;	-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res110 = ([-1*hd1;		-1*hd2;		carry;		-1*residx],(sprintf "encode_ADD_1bit_res %d" residx))
		and res111 = ([-1*hd1;		-1*hd2;		-1*carry;	residx],(sprintf "encode_ADD_1bit_res %d" residx))
		in
		[cry000;cry001;cry010;cry011;cry100;cry101;cry110;cry111;res000;res001;res010;res011;res100;res101;res110;res111]
	end
	
	method encode_nba_inseq nba envpred = begin
		let (lv,exp) = begin
			match nba with
			T_non_blocking_assignment_direct(lv,exp) -> (lv,exp)
			| _ -> begin
				Printf.printf "fatal error : encode_nba_inseq only support T_non_blocking_assignment_direct\n";
				exit 1
			end
		end
		in begin
			let (expidx_lst,cl)=self#encode_exp exp
			and lvidx_lst=self#map_lv2index lv
			in begin
				if (List.length expidx_lst) != (List.length lvidx_lst) then begin
					Printf.printf "fatal error : encode_nba_inseq lv and exp length must be same\n";
					print_v_expression stderr exp;
					Printf.fprintf stderr "\n";
					print_v_lvalue stderr lv;
					exit 1
				end
				
				;
				
				let commonlen=min (List.length expidx_lst) (List.length lvidx_lst)
				in
				let expidx_lst_common=Misc.lst_lastn expidx_lst commonlen
				and lvidx_lst_common=Misc.lst_lastn lvidx_lst commonlen
				in
				let pairlst=List.combine lvidx_lst_common expidx_lst_common
				in
				let proc_pair pl = begin (*dont forget to guard them with envpred*)
					match pl with
					(lvidx,expidx) -> (self#addGuard (self#encode_ASSIGN lvidx expidx) envpred)
				end
				in
				cl@(List.concat (List.map proc_pair pairlst))
			end
		end
	end
	
	method addGuard clslist pred = begin
		let proc_cls cls = self#appendcomment (sprintf "guarded by %d" pred) (((-1*pred)::(fst cls)),(snd cls)) 
		in
		List.map proc_cls clslist
	end
	
	
	(*the first is the destination*)
	method encode_ASSIGN idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_ASSIGN %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU idx1 idx2 = begin
		(*code the equality *)
		(*Printf.printf  "encode_EQU %d %d\n" idx1 idx2;*)
		let initlst=[([-1*idx1;idx2],"");([idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_EQU %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_EQU_res r b1 b2 = begin
		(*Printf.printf  "encode_EQU_res %d %d %d\n" b1 b2 r;*)
		let initlst=[([b1;b2;r],"");([-b1;-b2;r],"");([b1;-b2;-r],"");([-b1;b2;-r],"")]
		in
		List.map (self#setcomment (sprintf "encode_EQU_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_INEV l1 l2 = begin
		if (List.length l1) == (List.length l2) then  begin
			let len=(List.length l1)
			in
			let pl = List.combine l1 l2
			and residx=self#alloc_index len
			in 
			let rec enc pl1 idx= begin
				match pl1 with
				[] -> ([],[])
				| (b1,b2)::pltl -> begin
					let (resl,resv)=enc pltl (idx+1)
					in 
					((idx::resl),((self#encode_INE_res idx b1 b2 )@resv))
				end
			end
			in
			let (idxlst,clslst)=enc pl residx
			and redoridx=self#alloc_index 1
			in
			([redoridx],"redoridx")::((self#encode_Red_OR redoridx idxlst )@clslst)
		end
		else begin
			Printf.printf "fatal error : encode_INEV_res disequ\n" ;
			exit 1
		end
	end
	
	method encode_INE_res r b1 b2  = begin
		(*Printf.printf  "encode_INE_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;b2;-r],"");([-b1;-b2;-r],"");([b1;-b2;r],"");([-b1;b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_INE_res %s %s %s" (self#idx2name  r) (self#idx2name b1) (self#idx2name b2) ))  initlst
	end
	
	method encode_AND2_res r b1 b2  = begin
		(*Printf.printf  "encode_AND2_res %d %d %d\n" r b1 b2 ;*)
		let initlst=[([b1;-r],"");([b2;-r],"");([-b1;-b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_AND2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_OR2_res r b1 b2 = begin
		(*Printf.printf  "encode_OR2_res %d %d %d\n"  r b1 b2;*)
		let initlst=[([-b1;r],"");([-b2;r],"");([b1;b2;-r],"")]
		in
		List.map (self#setcomment (sprintf "encode_OR2_res %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) )) initlst
	end
	
	method encode_SEL_res r b1 b2 pred = begin
		(*Printf.printf  "encode_SEL_res %d %d %d %d\n" r b1 b2 pred;*)
		let initlst=[([-pred;b1;-r],"");([-pred;-b1;r],"");([pred;b2;-r],"");([pred;-b2;r],"")]
		in
		List.map (self#setcomment (sprintf "encode_SEL_res %s %s %s %s" (self#idx2name r) (self#idx2name b1) (self#idx2name b2) (self#idx2name pred) )) initlst
	end
	
	method encode_XOR2_res r b1 b2  = self#encode_INE_res r b1 b2 
	
	method encode_NEG idx1 idx2 = begin
		(*Printf.printf  "encode_NEG %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx1;idx2],"");([-1*idx1;-1*idx2],"")]
		in
		List.map (self#setcomment (sprintf "encode_NEG %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	(*first is the target*)
	method encode_NEG_ASSIGN idx1 idx2 = begin
		(*Printf.printf  "encode_NEG_ASSIGN %d %d\n"  idx1 idx2;*)
		(*code the equality *)
		let initlst=[([idx2;idx1],"");([-1*idx2;-1*idx1],"")]
		in
		List.map (self#setcomment (sprintf "encode_NEG_ASSIGN %s %s" (self#idx2name idx1) (self#idx2name idx2))) initlst
	end
	
	method encode_Red_AND li bitlst  = begin
		(*Printf.printf  "encode_Red_AND %d\n"   li;*)
		(*first the -1 -2 -3 ... li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[li]),(sprintf "encode_Red_AND %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then i -li*)
		let proc_b b = ([b;(-1*li)],(sprintf "encode_Red_AND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)) )
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NAND li bitlst  = begin
		(*Printf.printf  "encode_Red_NAND %d\n"   li;*)
		(*first the -1 -2 -3 ... -li  *)
		let allcase=(((List.map (fun x -> -1*x) bitlst)@[(-1*li)]),(sprintf "encode_Red_NAND %d to %s" (List.length bitlst) (self#idx2name li) ))
		in
		(*then i li*)
		let proc_b b = ([b;(li)],(sprintf "encode_Red_NAND %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_OR li bitlst  = begin
		(*Printf.printf  "encode_Red_OR %d\n"   li;*)
		(*first the 1 2 3 ... -li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(-1*li)]),(sprintf "encode_Red_OR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i li*)
		let proc_b b = ([(-1*b);li],(sprintf "encode_Red_OR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode_Red_NOR li bitlst  = begin
		(*Printf.printf  "encode_Red_NOR %d\n"   li;*)
		(*first the 1 2 3 ... li  *)
		let allcase=(((List.map (fun x -> x) bitlst)@[(li)]),(sprintf "encode_Red_NOR %d to %s" (List.length bitlst) (self#idx2name li)))
		in
		(*then -i -li*)
		let proc_b b = ([(-1*b);(-1*li)],(sprintf "encode_Red_NOR %d from %s to %s" (List.length bitlst) (self#idx2name b) (self#idx2name li)))
		in
		allcase::(List.map proc_b bitlst)
	end
	
	method encode2SAT_explictname = begin
		let encode_explictname key cont = begin
		  let duplst= List.filter (fun x -> match x with (nm,_)-> string_equ nm key) name_index_lst
		  in begin
		    if (List.length duplst) == 0 then begin
			let rng= self#name2range key
			and dff = self#isdff key
			in begin
				(*the index is for left side of range*)
				if dff then begin(*dff will has two index, one for current state, the other for next state*)
					name_index_lst <- (key,(last_index,last_index+(get_rng_width rng)))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)*2
				end
				else begin
					name_index_lst <- (key,(last_index,-1))::name_index_lst;
					last_index <- last_index + (get_rng_width rng)
				end
			end
		    end
		    else begin
			Printf.printf "fatal error : %s is defined multiple times\n" key;
			exit 1
		    end
		  end
		end
		in
		Hashtbl.iter encode_explictname circuit_hst
	end
	
	
	(*
		some misc functions
	*)
	method map_lv2index lv = begin (*return the list of index from left to right*)
		(*
			note that, for dff, lv must be a next state, so use the second index
					for non-dff one, just use the first one
		*)
		match lv with  
		T_lvalue_id([name]) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			in 
			self#rng_baseidx_2_idxlist rng baseidx
		end
		| T_lvalue_arrbit([name],exp) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and off=Expression.exp2int_simple exp
			in begin
				if self#is_inrange rng off then begin
					let (left,right)=self#rng2lr rng
					in 
					[self#offset2idx left right baseidx off]
				end
				else begin
					Printf.printf "fatal error : not in range\n";
					exit 1
				end
			end
		end
		| T_lvalue_arrrange([name],expl,expr) -> begin
			let baseidx = begin
				let (x1,x2)=List.assoc name name_index_lst
				in begin
					if (self#isdff name) then x2 
					else x1
				end
			end
			and rng=self#name2range name
			and li = Expression.exp2int_simple expl
			and ri = Expression.exp2int_simple expr
			in
			let idxlst=self#lr2list li ri
			and (left,right)=self#rng2lr rng
			in begin
				if (self#is_inrange rng li ) && (self#is_inrange rng ri )  then begin
					List.map (fun x -> self#offset2idx left right baseidx x) idxlst
				end
				else begin
					Printf.printf "fatal error : not in range 2\n";
					exit 1
				end
			end
		end
		| _ -> begin
			Printf.printf "fatal error : not supported lv\n";
			exit 1
		end
	end
	
	method lr2list li ri = begin
		if li> ri then li::(self#lr2list (li-1) ri)
		else if li< ri then li::(self#lr2list (li+1) ri)
		else [ri]
	end
	
	method is_inrange rng off = begin
		let (left,right)=self#rng2lr rng
		in
		if ((left >= off && off >= right)||(left <= off && off <= right)) then true
		else false
	end
	
	method offset2idx left right baseidx offset = baseidx + abs(offset - left)
	
	method rng_baseidx_2_idxlist rng baseidx = begin
		let (l,r) = self#rng2lr rng
		in 
		let lst=self#rng2list (T_range_int((min l r),(max l r)))
		in
		let delta = baseidx-(List.hd lst)
		in
		List.map (fun x -> (x+delta)) lst
	end
	
	method rng2list rng = begin
		let (l,r) = self#rng2lr rng
		in begin
			let rec runlist li ri = begin
				if li > ri then li::(runlist (li-1) ri)
				else if li< ri then li::(runlist (li+1) ri)
				else [ri]
			end
			in 
			runlist l r
		end
	end
	
	method rng2lr rng= begin
			match rng with
			T_range(expl,expr) -> begin
				let idxl= Expression.exp2int_simple expl
				and idxr= Expression.exp2int_simple expr
				in
				(idxl,idxr)
			end
			| T_range_int(li,ri) -> (li,ri)
			| T_range_NOSPEC -> (-1,-1)
	end
	
	method isdff name = begin
		let co = self#findco (new hierachcal_name [name])
		in begin
			match co#get_obj with
			Tobj_dff_declaration(_) -> true
			| _ -> false
		end
	end
	

	method name2range name = begin
			match (self#findco (new hierachcal_name [name]))#get_obj with
			Tobj_input_declaration(rng) -> rng
			| Tobj_output_declaration(rng) -> rng
			| Tobj_net_declaration(rng) -> rng
			| Tobj_reg_declaration(rng) -> rng
			| Tobj_dff_declaration(rng) -> rng
			| _ -> begin
				Printf.printf "fatal error : name2range not support Tobj\n";
				exit 1
			end
	end
	
	method idx2name idx_unmapped = begin
		let idx= begin (*we must be careful that we may use idx2name before finish encoding the first instance*)
			if final_index_oneinst==0 then idx_unmapped
			else idx_unmapped mod final_index_oneinst
		end
		in
		(*let ssy=List.filter (fun x -> match x with (nm,(idx1,idx2)) -> if (idx1==idx || idx2==idx) then true else false) name_index_lst
		in *)
		begin
			(*if (List.length ssy) == 1 then fst (List.hd ssy)
			else if  (List.length ssy) == 0 then*)
			begin
				(*it may be in range of some defined data*)
				let nm_idx1_li_ri_idx2name nm idx1 li ri idx = 
					let off=(self#construct_offset idx1 li ri idx)
					in begin
						if (off == -1) then nm
						else sprintf "%s[%d]" nm off
					end
				in
				let pred_inrange ni = begin
					match ni with
					(nm,(idx1,-1)) -> begin
						let (li,ri)=self#rng2lr (self#name2range nm)
						in 
						if (self#is_inrange (self#construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else ""
					end
					| (nm,(idx1,idx2)) -> begin
						let (li,ri)=self#rng2lr (self#name2range nm)
						in 
						if (self#is_inrange (self#construct_range_onidx idx1 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx1 li ri idx)
						else if (self#is_inrange (self#construct_range_onidx idx2 li ri) idx) then (nm_idx1_li_ri_idx2name nm idx2 li ri idx)
						else ""
					end
					| _ -> ""
				end
				in
				let res = List.map pred_inrange name_index_lst 
				in
				let res1 = List.filter (fun x -> (String.length x) !=0) res
				in begin
					if (List.length res1)==1 then List.hd res1
					else "unknown"
				end
			end
			(*else begin
				Printf.printf "warning : idx2name multiple matched , # of match %d , idx = %d , final_index_oneinst=%d\n" (List.length ssy)  idx final_index_oneinst;
				List.iter (fun x -> match x with (nm,_) -> print_string nm) ssy;
				(*sometimes we will use temp vars to record the add carry bit and so on, they dont has defined name and mapping*)
				(*print_string "name_index_lst:\n";
				List.iter (fun x -> match x with (nm,(id1,id2)) -> Printf.printf "%s %d %d\n" nm id1 id2) name_index_lst;*)
				"unknown"
			end*)
		end
	end
	
	(*print_cnf*)
	method print_cnf clslst dumpout_cnf dly len prefix forward instrlist outstrlist= begin
		fprintf dumpout_cnf "p cnf %d %d\n" (self#get_largest_varindex_inclslst clslst) (List.length clslst);
		
		fprintf dumpout_cnf "c module_name  %s \n" name;
		
		List.iter (fun x -> fprintf dumpout_cnf "c module_port  %s \n" (get_str_from_strlst x)) portlist;
		
		(*leave a blank line for awk to exit from printing module definition *)
		fprintf dumpout_cnf "c module_def_end\n"  ;
		
		fprintf dumpout_cnf "c clkname %s\n" clkname;
		
		fprintf dumpout_cnf "c for_rev_cz final_index_oneinst %d\n" final_index_oneinst;
		
		fprintf dumpout_cnf "c for_rev_cz dly %d\n" dly;
		
		fprintf dumpout_cnf "c for_rev_cz len %d\n" len;
		
		fprintf dumpout_cnf "c for_rev_cz prefix %d\n" prefix;
		
		fprintf dumpout_cnf "c for_rev_cz forward %d\n" forward;
		
		(*print out the truepred list*)
		let proc_truepred cls = begin
			match cls with
			([pred],_) -> begin
				if pred > 0 then 
					fprintf dumpout_cnf "c pre_truepred %d\n" pred
			end
			| _ -> ()
		end
		in
		List.iter proc_truepred clslst
		;
		
		let left nm = match (self#rng2lr (self#name2range nm)) with (left,_)->left
		and right nm= match (self#rng2lr (self#name2range nm)) with (_,right)->right
		in begin
			List.iter (fun instr ->  fprintf dumpout_cnf "c for_rev_cz input %s %d %d\n"  instr  (left instr)  (right instr))  instrlist;
			List.iter (fun outstr -> fprintf dumpout_cnf "c for_rev_cz output %s %d %d\n" outstr (left outstr) (right outstr)) outstrlist;
		end
		;
		
		let proc_hst key co = begin
			match co#get_obj with
			Tobj_input_declaration(rng) -> 	begin
				match (self#rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c input_port %s\n" key 
					else
						fprintf dumpout_cnf "c input_port [%d:%d] %s\n" left right key 
				end
			end
			| Tobj_output_declaration(rng) -> 	begin
				match (self#rng2lr rng) with
				(left,right) -> begin
					if (left == -1) || (right == -1) then
						fprintf dumpout_cnf "c output_port %s\n" key 
					else
						fprintf dumpout_cnf "c output_port [%d:%d] %s\n" left right key 
				end
			end
			| _ -> ()
		end
		in
		Hashtbl.iter proc_hst circuit_hst
		;
		
		let print_name_index name_index = begin
			match name_index with
			(nm,(curidx,nxtidx)) -> begin
				fprintf dumpout_cnf "c one instance mapping %s %d %d " nm curidx nxtidx;
				match (self#rng2lr (self#name2range nm)) with
				(left,right) -> 
					fprintf dumpout_cnf "%d %d\n" left right
			end
		end
		in
		List.iter print_name_index name_index_lst
		;
		
		let print_clause cls = begin
			match cls with
			(litlst,cmt) -> begin
				fprintf dumpout_cnf "c %s\n" cmt;
				(*List.iter (fun lit -> if ( lit != -1 && lit != 2 ) then begin fprintf dumpout_cnf "%d " lit end) litlst ;*)
				List.iter (fun lit -> fprintf dumpout_cnf "%d " lit ) litlst ;
				fprintf dumpout_cnf "0\n"
			end
		end
		in
		List.iter print_clause clslst
	end
	
	method get_largest_varindex_incls cls = begin
		match cls with
		(litlst,_) -> 
			List.fold_left (fun x y -> max (abs x) (abs y)) 0 litlst
	end
	
	method get_largest_varindex_inclslst clslst= begin
		let maxlist=List.map (self#get_largest_varindex_incls) clslst
		in
		List.fold_left (fun x y -> max (abs x) (abs y)) 0 maxlist
	end
	
	method construct_range_onidx baseidx li ri = begin
		(*actualy li may > ri*)
		if li < ri then T_range_int(baseidx,baseidx+ri-li)
		else T_range_int(baseidx,baseidx+li-ri)
	end
	
	method construct_offset baseidx li ri idx2beoff= begin
		(*actualy li may > ri*)
		if li<ri then 	li+idx2beoff-baseidx
		else li+baseidx-idx2beoff
	end

	(*allocate last_index to last_index+num-1 , and set last_index to last_index+num*)
	method alloc_index num= begin
		let oldindex = last_index
		in begin
			last_index <- last_index+num;
			oldindex
		end
	end
	
	method find_pin_exp pinname npclst = begin
		try 
			let cmp_pin x = begin
				match x with
				T_named_port_connection(str1,_) -> begin
					if(string_equ pinname str1) then true
					else false
				end
				| _ -> false
			end
			in
			let pin = List.find cmp_pin npclst
			in begin
				match pin with 
				T_named_port_connection(str1,pinexp) -> begin
					if ( string_equ str1 pinname ) then pinexp
					else begin
						printf "Warning 1: finding %s return empty string\n" pinname;
						List.iter (fun x ->match x with T_named_port_connection(pn,_) -> printf "pn %s\n" pn) npclst
						;
						T_expression_NOSPEC(1)
					end
				end
				| _ -> begin
					printf "Warning 2: finding %s return empty string\n" pinname;
					List.iter (fun x ->match x with T_named_port_connection(pn,_) -> printf "pn %s\n" pn) npclst
					;
					T_expression_NOSPEC(1)
				end
			end
		with Not_found -> begin
			printf "Warning Not_found : finding %s return empty string\n" pinname;
			List.iter (fun x ->match x with T_named_port_connection(pn,_) -> printf "pn %s\n" pn) npclst
			;
			T_expression_NOSPEC(1)
		end
	end	
end
